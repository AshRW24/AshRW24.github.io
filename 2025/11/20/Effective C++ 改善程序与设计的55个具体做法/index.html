

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="真新镇之小智">
  <meta name="keywords" content="C++,Go,Vue3,HPC,SIMD,CUDA,Qt,Linux,软件工程,真新镇之小智">
  
    <meta name="description" content="《Effective C++》是 Scott Meyers 的经典之作，被誉为C++程序员的必读圣经。这本书不仅仅是语法层面的讲解，更多的是关于如何”正确”、”高效”地使用C++的思维模式。 书中的55个条款涵盖了从基础语法到高级模板编程的方方面面。与其说它是教程，不如说它是一本”避坑指南”和”最佳实践手册”。 以下是我对这55个具体做法的深度总结与思考，旨在提炼出最核心的编程智慧，摒弃冗余的废话">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ 改善程序与设计的55个具体做法">
<meta property="og:url" content="https://ashrw24.github.io/2025/11/20/Effective%20C++%20%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95/index.html">
<meta property="og:site_name" content="真新镇之小智の修行工坊">
<meta property="og:description" content="《Effective C++》是 Scott Meyers 的经典之作，被誉为C++程序员的必读圣经。这本书不仅仅是语法层面的讲解，更多的是关于如何”正确”、”高效”地使用C++的思维模式。 书中的55个条款涵盖了从基础语法到高级模板编程的方方面面。与其说它是教程，不如说它是一本”避坑指南”和”最佳实践手册”。 以下是我对这55个具体做法的深度总结与思考，旨在提炼出最核心的编程智慧，摒弃冗余的废话">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-20T02:00:00.000Z">
<meta property="article:modified_time" content="2025-11-20T07:23:57.669Z">
<meta property="article:author" content="真新镇之小智">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="最佳实践">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Effective C++ 改善程序与设计的55个具体做法 - 真新镇之小智の修行工坊</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ashrw24.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"scrollDown":true},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>真新镇之小智</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://images.unsplash.com/photo-1555066931-4365d14bab8c?q=80&w=2070&auto=format&fit=crop') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Effective C++ 改善程序与设计的55个具体做法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-20 10:00" pubdate>
          2025年11月20日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          65k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          542 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Effective C++ 改善程序与设计的55个具体做法</h1>
            
            
              <div class="markdown-body">
                
                <p>《Effective C++》是 Scott Meyers 的经典之作，被誉为C++程序员的必读圣经。这本书不仅仅是语法层面的讲解，更多的是关于如何”正确”、”高效”地使用C++的思维模式。</p>
<p>书中的55个条款涵盖了从基础语法到高级模板编程的方方面面。与其说它是教程，不如说它是一本”避坑指南”和”最佳实践手册”。</p>
<p>以下是我对这55个具体做法的深度总结与思考，旨在提炼出最核心的编程智慧，摒弃冗余的废话，直击C++开发的痛点。</p>
<span id="more"></span>

<h2 id="条款01：-视C-为一个语言联邦"><a href="#条款01：-视C-为一个语言联邦" class="headerlink" title="条款01： 视C++为一个语言联邦"></a>条款01： 视C++为一个语言联邦</h2><blockquote>
<p><em>View C++ as a federation of languages</em></p>
</blockquote>
<h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><p>C++不是一门单纯的语言，而是由四个相互关联但各有特色的<strong>子语言</strong>组成的联邦。理解这种分层结构是掌握现代C++的关键，因为<strong>高效编程守则会根据你使用的C++子语言部分而变化</strong>。认识到这四个子语言的特点和适用场景，能帮助你在不同情境下选择最合适的编程风格和技术。</p>
<h3 id="深度解析"><a href="#深度解析" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-C语言子集（C-Sublanguage）"><a href="#1-C语言子集（C-Sublanguage）" class="headerlink" title="1. C语言子集（C Sublanguage）"></a>1. <strong>C语言子集（C Sublanguage）</strong></h4><p><strong>核心特征：</strong></p>
<ul>
<li>基础的块结构、语句、预处理器</li>
<li>内置数据类型（int、char、double等）</li>
<li>数组和指针的基本操作</li>
<li>控制流结构（if、while、for等）</li>
</ul>
<p><strong>实践建议：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ C风格代码的最佳实践</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">size_t</span> size)</span> </span>&#123;  <span class="hljs-comment">// 显式传递大小</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-comment">// 处理 arr[i]</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ❌ 避免的C风格问题</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))  <span class="hljs-comment">// 用const或template替代</span></span><br><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];  <span class="hljs-comment">// 考虑使用std::array或std::vector</span><br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>与C库交互</li>
<li>底层性能关键代码</li>
<li>嵌入式系统编程</li>
</ul>
<h4 id="2-面向对象C-（Object-Oriented-C-）"><a href="#2-面向对象C-（Object-Oriented-C-）" class="headerlink" title="2. 面向对象C++（Object-Oriented C++）"></a>2. <strong>面向对象C++（Object-Oriented C++）</strong></h4><p><strong>核心特征：</strong></p>
<ul>
<li>类（classes）、对象（objects）</li>
<li>封装（encapsulation）、继承（inheritance）、多态（polymorphism）</li>
<li>虚函数、动态绑定</li>
</ul>
<p><strong>实践建议：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 面向对象设计原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;           <span class="hljs-comment">// 虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-comment">// 纯虚函数定义接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;                    <span class="hljs-comment">// 保护构造，防止直接实例化</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius_;                       <span class="hljs-comment">// 封装数据成员</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> : radius_(r) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;          <span class="hljs-comment">// 明确标记override</span><br>        <span class="hljs-comment">// 绘制圆形</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius_ * radius_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 多态的威力</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawShapes</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt;&amp; shapes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) &#123;<br>        shape-&gt;<span class="hljs-built_in">draw</span>();                    <span class="hljs-comment">// 运行时多态</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>大型系统设计</li>
<li>需要多态和继承的场景</li>
<li>面向对象建模</li>
</ul>
<h4 id="3-模板C-（Template-C-）"><a href="#3-模板C-（Template-C-）" class="headerlink" title="3. 模板C++（Template C++）"></a>3. <strong>模板C++（Template C++）</strong></h4><p><strong>核心特征：</strong></p>
<ul>
<li>模板（templates）</li>
<li>泛型编程（generic programming）</li>
<li>编译时计算和类型推导</li>
<li>元编程技术</li>
</ul>
<p><strong>实践建议：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 现代模板编程实践</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;  <span class="hljs-comment">// C++20概念</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Arithmetic T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">square</span><span class="hljs-params">(T value)</span> </span>&#123;                 <span class="hljs-comment">// constexpr函数模板</span><br>    <span class="hljs-keyword">return</span> value * value;<br>&#125;<br><br><span class="hljs-comment">// SFINAE和类型特性</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::<span class="hljs-type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, T&gt;<br><span class="hljs-built_in">safe_divide</span>(T a, T b) &#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-comment">// 可变参数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...));<br>&#125;<br><br><span class="hljs-comment">// 编译时计算</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N<span class="hljs-number">-1</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>库设计（如STL）</li>
<li>性能关键的泛型代码</li>
<li>编译时计算需求</li>
</ul>
<h4 id="4-STL（Standard-Template-Library）"><a href="#4-STL（Standard-Template-Library）" class="headerlink" title="4. STL（Standard Template Library）"></a>4. <strong>STL（Standard Template Library）</strong></h4><p><strong>核心特征：</strong></p>
<ul>
<li>容器（containers）</li>
<li>迭代器（iterators）  </li>
<li>算法（algorithms）</li>
<li>函数对象（function objects）</li>
</ul>
<p><strong>实践建议：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ STL最佳实践</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSTL</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 容器选择：根据需求选择合适的容器</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>    <br>    <span class="hljs-comment">// 算法优于手写循环</span><br>    <span class="hljs-comment">// 计算总和</span><br>    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), <br>                          [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">5</span>; &#125;);<br>    <br>    <span class="hljs-comment">// 变换数据</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; squares;<br>    squares.<span class="hljs-built_in">reserve</span>(data.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 预分配内存</span><br>    std::<span class="hljs-built_in">transform</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), <br>                   std::<span class="hljs-built_in">back_inserter</span>(squares),<br>                   [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;);<br>    <br>    <span class="hljs-comment">// 排序和去重</span><br>    std::<span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    data.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>()), data.<span class="hljs-built_in">end</span>());<br>&#125;<br><br><span class="hljs-comment">// 自定义函数对象</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyBy</span> &#123;<br>    <span class="hljs-type">int</span> factor;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MultiplyBy</span><span class="hljs-params">(<span class="hljs-type">int</span> f)</span> : factor(f) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * factor;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>数据处理和算法实现</li>
<li>高效的容器使用</li>
<li>函数式编程风格</li>
</ul>
<h4 id="5-子语言间的交互和转换"><a href="#5-子语言间的交互和转换" class="headerlink" title="5. 子语言间的交互和转换"></a>5. <strong>子语言间的交互和转换</strong></h4><p><strong>混合使用的智慧：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 综合运用四个子语言的示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data_;              <span class="hljs-comment">// STL容器</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// C风格接口兼容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadFromCArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>* arr, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        data_.<span class="hljs-built_in">assign</span>(arr, arr + size);      <span class="hljs-comment">// STL + C</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 面向对象设计</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DataProcessor</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 模板成员函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Predicate&gt;</span><br><span class="hljs-function">    <span class="hljs-type">size_t</span> <span class="hljs-title">countIf</span><span class="hljs-params">(Predicate pred)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">count_if</span>(data_.<span class="hljs-built_in">begin</span>(), data_.<span class="hljs-built_in">end</span>(), pred);  <span class="hljs-comment">// STL算法</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取C风格数组（兼容性）</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span>* <span class="hljs-title">getCArray</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">data</span>();                <span class="hljs-comment">// STL到C的桥接</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StatisticsProcessor</span> : <span class="hljs-keyword">public</span> DataProcessor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;               <span class="hljs-comment">// OOP虚函数</span><br>        <span class="hljs-comment">// 使用STL算法进行统计计算</span><br>        <span class="hljs-keyword">auto</span> minmax = std::<span class="hljs-built_in">minmax_element</span>(data_.<span class="hljs-built_in">begin</span>(), data_.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-comment">// 模板和lambda结合</span><br>        <span class="hljs-type">double</span> avg = std::<span class="hljs-built_in">accumulate</span>(data_.<span class="hljs-built_in">begin</span>(), data_.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0.0</span>) / data_.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-comment">// C风格的性能关键部分</span><br>        <span class="hljs-type">double</span> variance = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">double</span>* raw_data = data_.<span class="hljs-built_in">data</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; data_.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">double</span> diff = raw_data[i] - avg;<br>            variance += diff * diff;<br>        &#125;<br>        variance /= data_.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-选择合适子语言的指导原则"><a href="#6-选择合适子语言的指导原则" class="headerlink" title="6. 选择合适子语言的指导原则"></a>6. <strong>选择合适子语言的指导原则</strong></h4><p><strong>性能优先的场景：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C子语言：底层操作，直接内存访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fastMemoryCopy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    std::<span class="hljs-built_in">memcpy</span>(dest, src, size);  <span class="hljs-comment">// C标准库函数</span><br>&#125;<br><br><span class="hljs-comment">// Template C++：编译时优化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::array&lt;<span class="hljs-type">int</span>, N&gt; <span class="hljs-title">generateSequence</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, N&gt; result&#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        result[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>维护性优先的场景：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// OOP：清晰的接口和职责分离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentManager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">saveDocument</span><span class="hljs-params">(<span class="hljs-type">const</span> Document&amp; doc)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;Document&gt; <span class="hljs-title">loadDocument</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// STL：表达力强的代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processDocuments</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; paths)</span> </span>&#123;<br>    std::for_each(std::execution::par_unseq,  <span class="hljs-comment">// C++17并行算法</span><br>                  paths.<span class="hljs-built_in">begin</span>(), paths.<span class="hljs-built_in">end</span>(),<br>                  [](<span class="hljs-type">const</span> std::string&amp; path) &#123;<br>                      <span class="hljs-comment">// 处理每个文档</span><br>                  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>核心认知：</strong></p>
<ol>
<li><strong>C++是四种子语言的联邦</strong>，每种都有其最佳实践</li>
<li><strong>高效编程守则会根据使用的子语言而变化</strong></li>
<li><strong>理解何时使用哪种子语言是C++高手的标志</strong></li>
</ol>
<p><strong>实用指导：</strong></p>
<ul>
<li><strong>性能关键</strong>：优先考虑C子语言和模板</li>
<li><strong>大型系统</strong>：面向对象设计提供结构化</li>
<li><strong>库开发</strong>：模板提供泛型和复用性</li>
<li><strong>数据处理</strong>：STL提供高效算法</li>
</ul>
<p><strong>切换原则：</strong></p>
<ul>
<li>在同一个程序中可以自由切换子语言</li>
<li>根据具体问题选择最合适的工具</li>
<li>避免为了使用某种范式而强行使用</li>
</ul>
<p><strong>记住：C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。掌握这种灵活性，是成为C++专家的第一步。</strong></p>
<h2 id="条款02：-尽量以const，-enum-inline-替换-define"><a href="#条款02：-尽量以const，-enum-inline-替换-define" class="headerlink" title="条款02： 尽量以const， enum, inline 替换 #define"></a>条款02： 尽量以const， enum, inline 替换 #define</h2><blockquote>
<p><em>Prefer consts, enums, and inlines to #defines</em></p>
</blockquote>
<h3 id="核心理念-1"><a href="#核心理念-1" class="headerlink" title="核心理念"></a>核心理念</h3><p><code>#define</code> 宏定义是<strong>预处理器</strong>操作，不受 C++ 语言规则约束，可能导致<strong>调试困难</strong>、<strong>类型不安全</strong>、<strong>作用域污染</strong>等问题。使用 <code>const</code>、<code>enum</code> 和 <code>inline</code> 可以提供<strong>类型安全</strong>、<strong>作用域控制</strong>和<strong>更好的调试体验</strong>，同时保持相同或更好的性能。</p>
<h3 id="深度解析-1"><a href="#深度解析-1" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-define-的问题根源"><a href="#1-define-的问题根源" class="headerlink" title="1. #define 的问题根源"></a>1. <strong>#define 的问题根源</strong></h4><p><strong>预处理器 vs 编译器</strong></p>
<ul>
<li><code>#define</code> 在预处理阶段文本替换，编译器看不到原始符号名</li>
<li>调试时符号表中没有宏名，只有替换后的值</li>
<li>错误信息中显示的是替换后的内容，不是原始宏名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br><br><span class="hljs-comment">// 编译器看到的是：</span><br><span class="hljs-type">double</span> area = width * height * <span class="hljs-number">1.653</span>;  <span class="hljs-comment">// 而不是 ASPECT_RATIO</span><br><br><span class="hljs-comment">// 调试时的问题：</span><br><span class="hljs-comment">// 1. 符号表中没有 ASPECT_RATIO</span><br><span class="hljs-comment">// 2. 错误信息中只显示 1.653</span><br><span class="hljs-comment">// 3. 无法跟踪 ASPECT_RATIO 的使用</span><br></code></pre></td></tr></table></figure>

<h4 id="2-常量替代：const-对象"><a href="#2-常量替代：const-对象" class="headerlink" title="2. 常量替代：const 对象"></a>2. <strong>常量替代：const 对象</strong></h4><p><strong>基本常量替代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 不推荐：使用 #define</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-comment">// ✅ 推荐：使用 const 对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ASPECT_RATIO = <span class="hljs-number">1.653</span>;    <span class="hljs-comment">// 类型安全，可调试</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>

<p><strong>优势对比：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>#define</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型检查</strong></td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
<tr>
<td><strong>作用域</strong></td>
<td>❌ 全局</td>
<td>✅ 可控</td>
</tr>
<tr>
<td><strong>调试友好</strong></td>
<td>❌ 符号表无记录</td>
<td>✅ 保留符号信息</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>❌ 可能多次复制</td>
<td>✅ 通常只有一份</td>
</tr>
<tr>
<td><strong>编译时检查</strong></td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
</tbody></table>
<h4 id="3-类作用域常量"><a href="#3-类作用域常量" class="headerlink" title="3. 类作用域常量"></a>3. <strong>类作用域常量</strong></h4><p><strong>类内常量的正确定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>;     <span class="hljs-comment">// 声明式（declaration）</span><br>    <span class="hljs-type">int</span> scores[NumTurns];              <span class="hljs-comment">// 使用该常量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 在实现文件中定义（definition）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns;       <span class="hljs-comment">// 定义式，无需重复赋值</span><br></code></pre></td></tr></table></figure>

<p><strong>旧编译器的处理方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostEstimate</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> FudgeFactor;   <span class="hljs-comment">// 声明式</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 在实现文件中</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> CostEstimate::FudgeFactor = <span class="hljs-number">1.35</span>;  <span class="hljs-comment">// 定义式</span><br></code></pre></td></tr></table></figure>

<h4 id="4-enum-hack-技巧"><a href="#4-enum-hack-技巧" class="headerlink" title="4. enum hack 技巧"></a>4. <strong>enum hack 技巧</strong></h4><p>当需要<strong>编译时常量</strong>且不想为常量分配内存时，可以使用 enum：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123; NumTurns = <span class="hljs-number">5</span> &#125;;             <span class="hljs-comment">// enum hack</span><br>    <span class="hljs-type">int</span> scores[NumTurns];              <span class="hljs-comment">// 编译时常量，不占内存</span><br>&#125;;<br><br><span class="hljs-comment">// enum hack 的特点：</span><br><span class="hljs-comment">// 1. 不能取地址（和 #define 类似）</span><br><span class="hljs-comment">// 2. 不会导致非必要的内存分配</span><br><span class="hljs-comment">// 3. 是合法的编译时常量</span><br></code></pre></td></tr></table></figure>

<p><strong>enum hack vs const vs #define</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_TURNS_MACRO 5              <span class="hljs-comment">// 可能在多处复制</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_TURNS_CONST = <span class="hljs-number">5</span>;         <span class="hljs-comment">// 可能分配内存</span><br><span class="hljs-keyword">enum</span> &#123; NUM_TURNS_ENUM = <span class="hljs-number">5</span> &#125;;          <span class="hljs-comment">// 不分配内存，不能取地址</span><br><br><span class="hljs-type">int</span> array1[NUM_TURNS_MACRO];          <span class="hljs-comment">// ✅ 有效</span><br><span class="hljs-type">int</span> array2[NUM_TURNS_CONST];          <span class="hljs-comment">// ✅ 有效（C++11后）</span><br><span class="hljs-type">int</span> array3[NUM_TURNS_ENUM];           <span class="hljs-comment">// ✅ 有效</span><br><br><span class="hljs-comment">// 取地址测试</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;NUM_TURNS_CONST;     <span class="hljs-comment">// ✅ 有效</span><br><span class="hljs-comment">// const int* p2 = &amp;NUM_TURNS_ENUM;   // ❌ 错误：不能取地址</span><br><span class="hljs-comment">// const int* p3 = &amp;NUM_TURNS_MACRO;  // ❌ 错误：不是对象</span><br></code></pre></td></tr></table></figure>

<h4 id="5-函数式宏的替代：inline-函数"><a href="#5-函数式宏的替代：inline-函数" class="headerlink" title="5. 函数式宏的替代：inline 函数"></a>5. <strong>函数式宏的替代：inline 函数</strong></h4><p><strong>宏函数的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 问题重重的宏函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b);          <span class="hljs-comment">// a 被递增了两次！</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b + <span class="hljs-number">10</span>);     <span class="hljs-comment">// a 被递增了一次</span><br></code></pre></td></tr></table></figure>

<p>展开后的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f</span>((++a) &gt; (b) ? (++a) : (b));           <span class="hljs-comment">// ++a 执行了两次</span><br><span class="hljs-built_in">f</span>((++a) &gt; (b + <span class="hljs-number">10</span>) ? (++a) : (b + <span class="hljs-number">10</span>)); <span class="hljs-comment">// ++a 执行了一次</span><br></code></pre></td></tr></table></figure>

<p><strong>inline 函数的解决方案</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 类型安全的 inline 函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">callWithMax</span>(++a, b);            <span class="hljs-comment">// 行为可预测：a 只递增一次</span><br><span class="hljs-built_in">callWithMax</span>(++a, b + <span class="hljs-number">10</span>);       <span class="hljs-comment">// 行为可预测：a 只递增一次</span><br></code></pre></td></tr></table></figure>

<h4 id="6-复杂宏的-inline-替代"><a href="#6-复杂宏的-inline-替代" class="headerlink" title="6. 复杂宏的 inline 替代"></a>6. <strong>复杂宏的 inline 替代</strong></h4><p><strong>多语句宏的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 复杂宏：容易出错</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_PRINT(str) do &#123; \</span><br><span class="hljs-meta">    std::cout &lt;&lt; <span class="hljs-string">&quot;DEBUG: &quot;</span> &lt;&lt; str &lt;&lt; std::endl; \</span><br><span class="hljs-meta">    log_to_file(str); \</span><br><span class="hljs-meta">&#125; while(0)</span><br><br><span class="hljs-comment">// 使用时的问题</span><br><span class="hljs-keyword">if</span> (condition)<br>    <span class="hljs-built_in">DEBUG_PRINT</span>(<span class="hljs-string">&quot;message&quot;</span>);  <span class="hljs-comment">// 看起来没问题</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">other_action</span>();          <span class="hljs-comment">// 但可能不会如期执行</span><br></code></pre></td></tr></table></figure>

<p><strong>inline 函数替代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 类型安全的 inline 函数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">debugPrint</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DEBUG: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>    <span class="hljs-built_in">log_to_file</span>(str);<br>&#125;<br><br><span class="hljs-comment">// 使用时更安全</span><br><span class="hljs-keyword">if</span> (condition)<br>    <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">&quot;message&quot;</span>);   <span class="hljs-comment">// 行为明确</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">other_action</span>();          <span class="hljs-comment">// 确定会执行</span><br></code></pre></td></tr></table></figure>

<h4 id="7-性能对比分析"><a href="#7-性能对比分析" class="headerlink" title="7. 性能对比分析"></a>7. <strong>性能对比分析</strong></h4><p><strong>编译时常量性能</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 性能测试代码</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CONST_VALUE = <span class="hljs-number">1000000</span>;<br><span class="hljs-keyword">enum</span> &#123; ENUM_VALUE = <span class="hljs-number">1000000</span> &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MACRO_VALUE 1000000</span><br><br><span class="hljs-comment">// 现代编译器优化后，性能几乎相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CONST_VALUE; ++i) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ENUM_VALUE; ++i) &#123; <span class="hljs-comment">/* ... */</span> &#125;  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MACRO_VALUE; ++i) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>inline 函数 vs 宏性能</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// inline 函数通常生成相同或更好的汇编代码</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> result1 = <span class="hljs-built_in">square</span>(a);     <span class="hljs-comment">// 类型安全，性能相同</span><br><span class="hljs-type">int</span> result2 = <span class="hljs-built_in">SQUARE</span>(a);     <span class="hljs-comment">// 类型不安全，性能相同</span><br></code></pre></td></tr></table></figure>

<h4 id="8-最佳实践指南"><a href="#8-最佳实践指南" class="headerlink" title="8. 最佳实践指南"></a>8. <strong>最佳实践指南</strong></h4><p><strong>常量选择策略</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 简单数值常量：优先 const</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159265359</span>;<br><span class="hljs-type">const</span> std::string COMPANY_NAME = <span class="hljs-string">&quot;TechCorp&quot;</span>;<br><br><span class="hljs-comment">// 2. 数组大小等编译时常量：考虑 enum hack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    <span class="hljs-keyword">enum</span> &#123; BUFFER_SIZE = <span class="hljs-number">1024</span> &#125;;<br>    <span class="hljs-type">char</span> data[BUFFER_SIZE];<br>&#125;;<br><br><span class="hljs-comment">// 3. 类型相关常量：使用 const 模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">numeric_limits</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_signed = std::is_signed&lt;T&gt;::value;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>现代 C++ 的改进</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++11 及以后的最佳实践</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> VALUE = <span class="hljs-number">42</span>;        <span class="hljs-comment">// constexpr 替代 enum hack</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;   <span class="hljs-comment">// 编译时浮点常量</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-comment">// constexpr 函数</span><br>        <span class="hljs-keyword">return</span> VALUE * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// C++17 inline 变量</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> GLOBAL_CONSTANT = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 头文件中的全局常量</span><br></code></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用 <code>const</code>、<code>enum</code> 和 <code>inline</code> 替代 <code>#define</code> 是现代 C++ 的基本原则，带来多重好处：</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>类型安全</strong>：编译时类型检查，避免隐式转换错误</li>
<li><strong>作用域控制</strong>：避免全局命名空间污染</li>
<li><strong>调试友好</strong>：保留符号信息，便于调试和错误定位</li>
<li><strong>性能等价</strong>：现代编译器优化下性能相同或更好</li>
<li><strong>语义清晰</strong>：明确表达设计意图</li>
</ul>
<p><strong>选择指南：</strong></p>
<ul>
<li><strong>简单常量</strong>：使用 <code>const</code> 或 <code>constexpr</code></li>
<li><strong>编译时整数常量</strong>：优先 <code>constexpr</code>，考虑 <code>enum hack</code></li>
<li><strong>函数式操作</strong>：使用 <code>inline</code> 函数或 lambda</li>
<li><strong>复杂逻辑</strong>：避免宏，使用模板和 inline 函数</li>
</ul>
<p>记住：<strong>预处理器是为那些不懂语言本身的工具准备的</strong>，尽量使用语言本身的特性来达到相同的效果。</p>
<h2 id="条款03-尽量使用const"><a href="#条款03-尽量使用const" class="headerlink" title="条款03:  尽量使用const"></a>条款03:  尽量使用const</h2><blockquote>
<p><em>Use const whenever possible</em></p>
</blockquote>
<h3 id="核心理念-2"><a href="#核心理念-2" class="headerlink" title="核心理念"></a>核心理念</h3><p><code>const</code>是C++中最强大的关键字之一，它不仅能帮助编译器检测错误用法，更是表达设计意图、提升代码安全性和可维护性的重要工具。将某些东西声明为<code>const</code>可以在编译期就发现潜在问题，避免运行时错误。理解<code>const</code>的各种用法和最佳实践，是写出健壮C++代码的基础。</p>
<h3 id="深度解析-2"><a href="#深度解析-2" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-const的基本语法规则"><a href="#1-const的基本语法规则" class="headerlink" title="1. const的基本语法规则"></a>1. <strong>const的基本语法规则</strong></h4><p><strong>指针和const的组合：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr1;        <span class="hljs-comment">// ptr1是指向const int的指针</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* ptr2;        <span class="hljs-comment">// 等同于ptr1，指向const int的指针</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr3 = &amp;x;   <span class="hljs-comment">// ptr3是指向int的const指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr4 = &amp;x;  <span class="hljs-comment">// ptr4是指向const int的const指针</span><br><br><span class="hljs-comment">// 读法技巧：从右往左读</span><br><span class="hljs-comment">// const int* ptr1 → ptr1是指针，指向const int</span><br><span class="hljs-comment">// int* const ptr3 → ptr3是const指针，指向int</span><br></code></pre></td></tr></table></figure>

<p><strong>记忆口诀：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 如果const在*左边，所指物是常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1;    <span class="hljs-comment">// 所指的int是const</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* p2;    <span class="hljs-comment">// 同上</span><br><br><span class="hljs-comment">// 如果const在*右边，指针自身是常量  </span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p3;    <span class="hljs-comment">// 指针p3是const</span><br><br><span class="hljs-comment">// 两边都有const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p4;  <span class="hljs-comment">// 指针和所指物都是const</span><br></code></pre></td></tr></table></figure>

<h4 id="2-const在函数参数中的应用"><a href="#2-const在函数参数中的应用" class="headerlink" title="2. const在函数参数中的应用"></a>2. <strong>const在函数参数中的应用</strong></h4><p><strong>值传递参数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 对于内置类型，const value参数意义不大</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x)</span></span>;     <span class="hljs-comment">// 函数内部不能修改x，但调用者不受影响</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;           <span class="hljs-comment">// 对调用者而言，效果相同</span><br><br><span class="hljs-comment">// ✅ 但可以避免函数内部意外修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">// value = 100;  // 编译错误，防止意外修改</span><br>    <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>引用和指针参数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ const引用：高效且安全</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;  <span class="hljs-comment">// 不拷贝，不修改</span><br>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br>    <span class="hljs-comment">// str += &quot;modified&quot;;  // 编译错误</span><br>&#125;<br><br><span class="hljs-comment">// ✅ const指针参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 只读访问</span><br>        <span class="hljs-comment">// arr[i] = 0;  // 编译错误</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ✅ 指针本身是const</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processBuffer</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> buffer, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// buffer = nullptr;  // 编译错误，不能改变指针</span><br>    buffer[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;      <span class="hljs-comment">// 可以修改所指内容</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-const返回值的应用"><a href="#3-const返回值的应用" class="headerlink" title="3. const返回值的应用"></a>3. <strong>const返回值的应用</strong></h4><p><strong>返回const对象防止误用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_, denominator_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 返回const对象，防止(a*b)=c这样的误用</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(numerator_ * rhs.numerator_, <br>                       denominator_ * rhs.denominator_);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testRational</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// ❌ 如果operator*不返回const，这样的代码可能编译通过但逻辑错误</span><br>    <span class="hljs-comment">// (a * b) = c;  // 编译错误：不能给const对象赋值</span><br>    <br>    <span class="hljs-comment">// ✅ 正确用法</span><br>    Rational result = a * b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>返回const引用的场景：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string text_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ const版本返回const引用</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> text_[position];<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ non-const版本返回non-const引用</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) &#123;<br>        <span class="hljs-keyword">return</span> text_[position];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateConstReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-type">char</span> c1 = tb[<span class="hljs-number">0</span>];      <span class="hljs-comment">// 调用non-const版本</span><br>    <span class="hljs-type">char</span> c2 = ctb[<span class="hljs-number">0</span>];     <span class="hljs-comment">// 调用const版本</span><br>    <br>    tb[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;          <span class="hljs-comment">// 可以修改</span><br>    <span class="hljs-comment">// ctb[0] = &#x27;w&#x27;;      // 编译错误：const对象不能修改</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-const成员函数"><a href="#4-const成员函数" class="headerlink" title="4. const成员函数"></a>4. <strong>const成员函数</strong></h4><p><strong>基本概念和语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> access_count_;  <span class="hljs-comment">// mutable成员可以在const函数中修改</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y), <span class="hljs-built_in">access_count_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ const成员函数：不修改对象状态</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <br>        ++access_count_;  <span class="hljs-comment">// mutable成员可以修改</span><br>        <span class="hljs-keyword">return</span> x_; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(x_ * x_ + y_ * y_);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ non-const成员函数：可以修改对象状态</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; x_ = x; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> </span>&#123; y_ = y; &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误示例：const函数中修改成员</span><br>    <span class="hljs-comment">// void badConstFunction() const &#123;</span><br>    <span class="hljs-comment">//     x_ = 100;  // 编译错误</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateConstMemberFunctions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Point <span class="hljs-title">cp</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// const对象只能调用const成员函数</span><br>    <span class="hljs-type">int</span> x1 = p.<span class="hljs-built_in">getX</span>();    <span class="hljs-comment">// 调用const版本</span><br>    <span class="hljs-type">int</span> x2 = cp.<span class="hljs-built_in">getX</span>();   <span class="hljs-comment">// 调用const版本</span><br>    <br>    p.<span class="hljs-built_in">setX</span>(<span class="hljs-number">10</span>);           <span class="hljs-comment">// 可以修改</span><br>    <span class="hljs-comment">// cp.setX(20);       // 编译错误：const对象不能调用non-const函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-bitwise-const-vs-logical-const"><a href="#5-bitwise-const-vs-logical-const" class="headerlink" title="5. bitwise const vs logical const"></a>5. <strong>bitwise const vs logical const</strong></h4><p><strong>bitwise constness（编译器的观点）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* pText_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextBlock</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text) &#123;<br>        pText_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(pText_, text);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">TextBlock</span>() &#123; <span class="hljs-keyword">delete</span>[] pText_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ bitwise const：不修改任何成员变量</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> pText_[position];  <span class="hljs-comment">// 返回引用，允许修改所指内容！</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateBitwiseConst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-type">char</span>&amp; c = tb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 获得引用</span><br>    c = <span class="hljs-string">&#x27;h&#x27;</span>;          <span class="hljs-comment">// 修改了&quot;const&quot;对象的内容！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>logical constness（程序员的观点）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">char</span>* pText_;           <span class="hljs-comment">// mutable允许在const函数中修改</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid_;    <span class="hljs-comment">// 缓存状态</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> textLength_;     <span class="hljs-comment">// 缓存的长度</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CTextBlock</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text) : <span class="hljs-built_in">lengthIsValid_</span>(<span class="hljs-literal">false</span>) &#123;<br>        pText_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(pText_, text);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">CTextBlock</span>() &#123; <span class="hljs-keyword">delete</span>[] pText_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ logical const：概念上不修改对象，但可能修改缓存</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!lengthIsValid_) &#123;<br>            textLength_ = <span class="hljs-built_in">strlen</span>(pText_);  <span class="hljs-comment">// 修改mutable成员</span><br>            lengthIsValid_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> textLength_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ const版本：真正的只读访问</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> pText_[position];<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ non-const版本：允许修改</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) &#123;<br>        lengthIsValid_ = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 修改后缓存失效</span><br>        <span class="hljs-keyword">return</span> pText_[position];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-避免const和non-const成员函数的代码重复"><a href="#6-避免const和non-const成员函数的代码重复" class="headerlink" title="6. 避免const和non-const成员函数的代码重复"></a>6. <strong>避免const和non-const成员函数的代码重复</strong></h4><p><strong>❌ 错误做法：代码重复</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string text_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">// 复杂的边界检查和日志记录</span><br>        <span class="hljs-keyword">if</span> (position &gt;= text_.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">logAccess</span>(position);<br>        <span class="hljs-keyword">return</span> text_[position];<br>    &#125;<br>    <br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) &#123;<br>        <span class="hljs-comment">// 重复的复杂逻辑！</span><br>        <span class="hljs-keyword">if</span> (position &gt;= text_.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">logAccess</span>(position);<br>        <span class="hljs-keyword">return</span> text_[position];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>✅ 正确做法：non-const调用const</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string text_;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAccess</span><span class="hljs-params">(<span class="hljs-type">size_t</span> position)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 日志记录逻辑</span><br>    &#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// const版本：实现所有逻辑</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (position &gt;= text_.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">logAccess</span>(position);<br>        <span class="hljs-keyword">return</span> text_[position];<br>    &#125;<br>    <br>    <span class="hljs-comment">// non-const版本：调用const版本</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(           <span class="hljs-comment">// 移除返回值的const</span><br>            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;   <span class="hljs-comment">// 为*this加上const</span><br>                (*<span class="hljs-keyword">this</span>)[position]           <span class="hljs-comment">// 调用const版本</span><br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>const_cast的安全使用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 安全：从const版本中移除const</span><br><span class="hljs-type">char</span>&amp; TextBlock::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)[position]<br>    );<br>&#125;<br><br><span class="hljs-comment">// ❌ 危险：不要让const版本调用non-const版本</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; TextBlock::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// return (*this)[position];  // 可能修改对象状态！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-const在STL中的应用"><a href="#7-const在STL中的应用" class="headerlink" title="7. const在STL中的应用"></a>7. <strong>const在STL中的应用</strong></h4><p><strong>迭代器和const：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSTLConst</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; cvec = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <br>    <span class="hljs-comment">// const迭代器：迭代器本身是const</span><br>    <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();<br>    *iter = <span class="hljs-number">10</span>;     <span class="hljs-comment">// 可以修改所指元素</span><br>    <span class="hljs-comment">// ++iter;      // 编译错误：迭代器本身是const</span><br>    <br>    <span class="hljs-comment">// const_iterator：所指元素是const</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// *cIter = 20; // 编译错误：不能修改所指元素</span><br>    ++cIter;        <span class="hljs-comment">// 可以移动迭代器</span><br>    <br>    <span class="hljs-comment">// const容器只能使用const_iterator</span><br>    <span class="hljs-keyword">auto</span> it = cvec.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// 自动推导为const_iterator</span><br>    <span class="hljs-comment">// *it = 100;            // 编译错误</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 算法中的const使用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printRange</span><span class="hljs-params">(Iterator first, Iterator last)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = first; it != last; ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 只读访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-现代C-中的const增强"><a href="#8-现代C-中的const增强" class="headerlink" title="8. 现代C++中的const增强"></a>8. <strong>现代C++中的const增强</strong></h4><p><strong>constexpr：编译时常量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++11/14/17中的constexpr</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> arr_size = <span class="hljs-number">10</span>;<br>std::array&lt;<span class="hljs-type">int</span>, square(5)&gt; arr;  <span class="hljs-comment">// 编译时计算</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> : x_(x), y_(y) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">distanceSquared</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x_ * x_ + y_ * y_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">origin</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> dist = origin.<span class="hljs-built_in">distanceSquared</span>();<br></code></pre></td></tr></table></figure>

<p><strong>auto和const：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateAutoConst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> y = x;            <span class="hljs-comment">// y的类型是int（丢失const）</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> z = x;      <span class="hljs-comment">// z的类型是const int</span><br>    <span class="hljs-keyword">auto</span>&amp; w = x;           <span class="hljs-comment">// w的类型是const int&amp;</span><br>    <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem = vec[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 避免拷贝的安全访问</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>const的核心价值：</strong></p>
<ol>
<li><strong>编译时错误检测</strong>：在编译期发现潜在问题</li>
<li><strong>接口契约</strong>：明确表达函数的意图和限制</li>
<li><strong>优化机会</strong>：帮助编译器生成更高效的代码</li>
<li><strong>代码安全性</strong>：防止意外修改</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>尽可能使用const</strong>：参数、返回值、成员函数</li>
<li><strong>const引用传参</strong>：避免拷贝的同时保证安全</li>
<li><strong>mutable处理缓存</strong>：在logical const中使用</li>
<li><strong>const_cast谨慎使用</strong>：仅在必要时从const版本中移除const</li>
<li><strong>STL算法优先使用const_iterator</strong></li>
</ul>
<p><strong>记住三个要点：</strong></p>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法</li>
<li>编译器强制实施bitwise constness，但你编写程序时应该使用”概念上的常量”（conceptual constness）  </li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复</li>
</ul>
<h2 id="条款04：-确定对象使用前先被初始化"><a href="#条款04：-确定对象使用前先被初始化" class="headerlink" title="条款04： 确定对象使用前先被初始化"></a>条款04： 确定对象使用前先被初始化</h2><blockquote>
<p><em>Make sure that objects are initialized before they’re used</em></p>
</blockquote>
<h3 id="核心理念-3"><a href="#核心理念-3" class="headerlink" title="核心理念"></a>核心理念</h3><p>在C++中，对象的初始化是一个容易被忽视但极其重要的问题。<strong>未初始化的对象可能包含随机数据，导致程序行为不确定</strong>。掌握正确的初始化技术不仅能避免运行时错误，还能提升程序性能。理解初始化与赋值的区别、成员初始化列表的重要性，以及静态对象的初始化顺序问题，是写出可靠C++代码的基础。</p>
<h3 id="深度解析-3"><a href="#深度解析-3" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-内置类型的手工初始化"><a href="#1-内置类型的手工初始化" class="headerlink" title="1. 内置类型的手工初始化"></a>1. <strong>内置类型的手工初始化</strong></h4><p><strong>问题根源：C++不保证内置类型的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 危险：未初始化的内置类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateUninitializedBuiltins</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x;              <span class="hljs-comment">// 未初始化！包含垃圾值</span><br>    <span class="hljs-type">double</span> y;           <span class="hljs-comment">// 未初始化！包含垃圾值</span><br>    <span class="hljs-type">char</span>* ptr;          <span class="hljs-comment">// 未初始化！可能指向任何地方</span><br>    <br>    <span class="hljs-comment">// 使用未初始化的变量：未定义行为</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; x &lt;&lt; std::endl;  // 危险！</span><br>    <span class="hljs-comment">// if (ptr != nullptr) &#123; ... &#125;   // 危险！</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 正确：手工初始化内置类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProperInitialization</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;                          <span class="hljs-comment">// 直接初始化</span><br>    <span class="hljs-type">double</span> y&#123;<span class="hljs-number">0.0</span>&#125;;                      <span class="hljs-comment">// 列表初始化（C++11）</span><br>    <span class="hljs-type">char</span>* ptr = <span class="hljs-literal">nullptr</span>;                <span class="hljs-comment">// 空指针初始化</span><br>    <br>    <span class="hljs-comment">// 数组初始化</span><br>    <span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>] = &#123;&#125;;                  <span class="hljs-comment">// 全部初始化为0</span><br>    <span class="hljs-type">int</span> arr2[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;          <span class="hljs-comment">// 前3个指定值，其余为0</span><br>    <br>    <span class="hljs-comment">// C++11统一初始化</span><br>    <span class="hljs-type">int</span> z&#123;<span class="hljs-number">42</span>&#125;;                          <span class="hljs-comment">// 列表初始化，防止窄化转换</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;  <span class="hljs-comment">// 容器的列表初始化</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>初始化 vs 赋值的性能差异：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performanceComparison</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ❌ 低效：先默认初始化，再赋值</span><br>    std::string name;           <span class="hljs-comment">// 默认构造</span><br>    name = <span class="hljs-string">&quot;John Doe&quot;</span>;          <span class="hljs-comment">// 赋值操作</span><br><br>    <span class="hljs-comment">// ✅ 高效：直接初始化</span><br>    <span class="hljs-function">std::string <span class="hljs-title">name2</span><span class="hljs-params">(<span class="hljs-string">&quot;John Doe&quot;</span>)</span></span>;     <span class="hljs-comment">// 直接构造</span><br>    std::string name3&#123;<span class="hljs-string">&quot;Jane Doe&quot;</span>&#125;;     <span class="hljs-comment">// 列表初始化</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-成员初始化列表的优势"><a href="#2-成员初始化列表的优势" class="headerlink" title="2. 成员初始化列表的优势"></a>2. <strong>成员初始化列表的优势</strong></h4><p><strong>基本概念：初始化 vs 赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> age_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> id_;              <span class="hljs-comment">// const成员必须在初始化列表中初始化</span><br>    std::string&amp; nickname_;     <span class="hljs-comment">// 引用成员必须在初始化列表中初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 错误做法：在构造函数体内赋值</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id, std::string&amp; nick) <br>        : <span class="hljs-built_in">id_</span>(id), <span class="hljs-built_in">nickname_</span>(nick) &#123;  <span class="hljs-comment">// const和引用成员必须在这里初始化</span><br>        name_ = name;                 <span class="hljs-comment">// 这是赋值，不是初始化！</span><br>        age_ = age;                   <span class="hljs-comment">// 这是赋值，不是初始化！</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确做法：使用成员初始化列表</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id, std::string&amp; nick)<br>        : <span class="hljs-built_in">name_</span>(name),          <span class="hljs-comment">// 初始化，直接调用拷贝构造函数</span><br>          <span class="hljs-built_in">age_</span>(age),            <span class="hljs-comment">// 初始化，直接赋值</span><br>          <span class="hljs-built_in">id_</span>(id),              <span class="hljs-comment">// const成员的唯一初始化方式</span><br>          <span class="hljs-built_in">nickname_</span>(nick) &#123;     <span class="hljs-comment">// 引用成员的唯一初始化方式</span><br>        <span class="hljs-comment">// 构造函数体可以为空，或包含其他逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpensiveObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ExpensiveObject</span>() &#123; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor called\n&quot;</span>; <br>    &#125;<br>    <br>    <span class="hljs-built_in">ExpensiveObject</span>(<span class="hljs-type">const</span> std::string&amp; data) : <span class="hljs-built_in">data_</span>(data) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Parameterized constructor called\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">ExpensiveObject</span>(<span class="hljs-type">const</span> ExpensiveObject&amp; other) : <span class="hljs-built_in">data_</span>(other.data_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called\n&quot;</span>;<br>    &#125;<br>    <br>    ExpensiveObject&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ExpensiveObject&amp; other) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Assignment operator called\n&quot;</span>;<br>        data_ = other.data_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    ExpensiveObject obj_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 低效版本：先默认构造，再赋值</span><br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">const</span> ExpensiveObject&amp; obj) &#123;<br>        obj_ = obj;  <span class="hljs-comment">// 调用默认构造函数 + 赋值运算符</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 高效版本：直接初始化</span><br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">const</span> ExpensiveObject&amp; obj) : <span class="hljs-built_in">obj_</span>(obj) &#123;<br>        <span class="hljs-comment">// 只调用拷贝构造函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-成员初始化顺序的重要性"><a href="#3-成员初始化顺序的重要性" class="headerlink" title="3. 成员初始化顺序的重要性"></a>3. <strong>成员初始化顺序的重要性</strong></h4><p><strong>规则：成员初始化顺序由声明顺序决定</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderMatters</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> first_;<br>    <span class="hljs-type">int</span> second_;<br>    <span class="hljs-type">int</span> third_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 混乱的初始化顺序（虽然能编译，但容易误导）</span><br>    <span class="hljs-built_in">OrderMatters</span>(<span class="hljs-type">int</span> val) <br>        : <span class="hljs-built_in">third_</span>(val),          <span class="hljs-comment">// 实际第三个初始化</span><br>          <span class="hljs-built_in">first_</span>(val),          <span class="hljs-comment">// 实际第一个初始化</span><br>          <span class="hljs-built_in">second_</span>(first_ + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 实际第二个初始化，使用已初始化的first_</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确：按声明顺序初始化</span><br>    <span class="hljs-built_in">OrderMatters</span>(<span class="hljs-type">int</span> val)<br>        : <span class="hljs-built_in">first_</span>(val),          <span class="hljs-comment">// 第一个初始化</span><br>          <span class="hljs-built_in">second_</span>(first_ + <span class="hljs-number">1</span>),  <span class="hljs-comment">// 第二个初始化，安全使用first_</span><br>          <span class="hljs-built_in">third_</span>(second_ * <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 第三个初始化，安全使用second_</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DangerousOrder</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 危险：使用未初始化的成员</span><br>    <span class="hljs-built_in">DangerousOrder</span>(<span class="hljs-type">int</span> s) <br>        : <span class="hljs-built_in">data_</span>(size_, <span class="hljs-number">0</span>),      <span class="hljs-comment">// size_还未初始化！未定义行为</span><br>          <span class="hljs-built_in">size_</span>(s) &#123;            <span class="hljs-comment">// size_在data_之后才初始化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 安全：重新排列声明顺序，或使用参数</span><br>    <span class="hljs-built_in">DangerousOrder</span>(<span class="hljs-type">int</span> s)<br>        : <span class="hljs-built_in">size_</span>(s),             <span class="hljs-comment">// 先初始化size_</span><br>          <span class="hljs-built_in">data_</span>(size_, <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 再使用size_初始化data_</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 或者直接使用参数</span><br>    <span class="hljs-built_in">DangerousOrder</span>(<span class="hljs-type">int</span> s)<br>        : <span class="hljs-built_in">size_</span>(s),<br>          <span class="hljs-built_in">data_</span>(s, <span class="hljs-number">0</span>) &#123;         <span class="hljs-comment">// 直接使用参数s</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-不同类型对象的初始化策略"><a href="#4-不同类型对象的初始化策略" class="headerlink" title="4. 不同类型对象的初始化策略"></a>4. <strong>不同类型对象的初始化策略</strong></h4><p><strong>基本类型和简单对象：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicTypes</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count_;<br>    <span class="hljs-type">double</span> ratio_;<br>    <span class="hljs-type">bool</span> flag_;<br>    <span class="hljs-type">char</span> buffer_[<span class="hljs-number">100</span>];<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 直接在初始化列表中初始化</span><br>    <span class="hljs-built_in">BasicTypes</span>() <br>        : <span class="hljs-built_in">count_</span>(<span class="hljs-number">0</span>),<br>          <span class="hljs-built_in">ratio_</span>(<span class="hljs-number">1.0</span>),<br>          <span class="hljs-built_in">flag_</span>(<span class="hljs-literal">false</span>),<br>          buffer_&#123;&#125; &#123;           <span class="hljs-comment">// 数组初始化为0</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 参数化构造</span><br>    <span class="hljs-built_in">BasicTypes</span>(<span class="hljs-type">int</span> count, <span class="hljs-type">double</span> ratio, <span class="hljs-type">bool</span> flag)<br>        : <span class="hljs-built_in">count_</span>(count),<br>          <span class="hljs-built_in">ratio_</span>(ratio),<br>          <span class="hljs-built_in">flag_</span>(flag),<br>          buffer_&#123;&#125; &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>容器和复杂对象：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexTypes</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers_;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; scores_;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 容器的高效初始化</span><br>    <span class="hljs-built_in">ComplexTypes</span>() <br>        : numbers_&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,              <span class="hljs-comment">// 列表初始化</span><br>          scores_&#123;&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">95</span>&#125;, &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">87</span>&#125;&#125;,  <span class="hljs-comment">// 列表初始化</span><br>          <span class="hljs-built_in">ptr_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>)) &#123;     <span class="hljs-comment">// 智能指针初始化 (C++14)</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 从参数初始化</span><br>    <span class="hljs-built_in">ComplexTypes</span>(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)<br>        : <span class="hljs-built_in">numbers_</span>(nums),                       <span class="hljs-comment">// 拷贝构造</span><br>          <span class="hljs-built_in">scores_</span>(),                            <span class="hljs-comment">// 默认构造</span><br>          <span class="hljs-built_in">ptr_</span>(<span class="hljs-literal">nullptr</span>) &#123;                       <span class="hljs-comment">// 明确初始化为nullptr</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 移动构造版本</span><br>    <span class="hljs-built_in">ComplexTypes</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; nums)<br>        : <span class="hljs-built_in">numbers_</span>(std::<span class="hljs-built_in">move</span>(nums)),            <span class="hljs-comment">// 移动构造</span><br>          <span class="hljs-built_in">scores_</span>(),<br>          <span class="hljs-built_in">ptr_</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-解决跨编译单元的初始化顺序问题"><a href="#5-解决跨编译单元的初始化顺序问题" class="headerlink" title="5. 解决跨编译单元的初始化顺序问题"></a>5. <strong>解决跨编译单元的初始化顺序问题</strong></h4><p><strong>问题描述：静态对象初始化顺序不确定</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File1.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDirectory</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建目录的实现</span><br>    &#125;<br>&#125;;<br><br>FileSystem theFileSystem;  <span class="hljs-comment">// 全局对象</span><br><br><span class="hljs-comment">// File2.cpp  </span><br><span class="hljs-keyword">extern</span> FileSystem theFileSystem;  <span class="hljs-comment">// 声明外部对象</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Directory</span>(<span class="hljs-type">const</span> std::string&amp; name) &#123;<br>        theFileSystem.<span class="hljs-built_in">createDirectory</span>(name);  <span class="hljs-comment">// 可能在theFileSystem初始化前调用！</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Directory <span class="hljs-title">tempDir</span><span class="hljs-params">(<span class="hljs-string">&quot;/tmp&quot;</span>)</span></span>;  <span class="hljs-comment">// 全局对象，可能在theFileSystem之前初始化</span><br></code></pre></td></tr></table></figure>

<p><strong>✅ 解决方案：Local Static对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 使用函数内的static对象保证初始化顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDirectory</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>        <span class="hljs-comment">// 实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">theFileSystem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> FileSystem fs;   <span class="hljs-comment">// local static对象</span><br>    <span class="hljs-keyword">return</span> fs;              <span class="hljs-comment">// 第一次调用时初始化，之后直接返回</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Directory</span>(<span class="hljs-type">const</span> std::string&amp; name) &#123;<br>        <span class="hljs-built_in">theFileSystem</span>().<span class="hljs-built_in">createDirectory</span>(name);  <span class="hljs-comment">// 安全：确保fs已初始化</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Directory <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-string">&quot;/tmp&quot;</span>)</span></span>;  <span class="hljs-comment">// 也使用local static</span><br>    <span class="hljs-keyword">return</span> dir;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>单例模式的正确实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;                      <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;      <span class="hljs-comment">// 禁止拷贝</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 禁止赋值</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;              <span class="hljs-comment">// 线程安全的单例（C++11）</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">doSomething</span>();     <span class="hljs-comment">// 安全访问</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-现代C-的初始化技术"><a href="#6-现代C-的初始化技术" class="headerlink" title="6. 现代C++的初始化技术"></a>6. <strong>现代C++的初始化技术</strong></h4><p><strong>统一初始化语法（C++11）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernInitialization</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data_;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; table_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 使用&#123;&#125;统一初始化语法</span><br>    <span class="hljs-built_in">ModernInitialization</span>()<br>        : value_&#123;<span class="hljs-number">42</span>&#125;,                           <span class="hljs-comment">// 防止窄化转换</span><br>          data_&#123;<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>&#125;,               <span class="hljs-comment">// 列表初始化</span><br>          table_&#123;&#123;<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>&#125;&#125; &#123;   <span class="hljs-comment">// 嵌套列表初始化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 防止窄化转换</span><br>    <span class="hljs-built_in">ModernInitialization</span>(<span class="hljs-type">double</span> d)<br>        : value_&#123;<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(d)&#125;,          <span class="hljs-comment">// 显式转换</span><br>          data_&#123;d&#125;,<br>          table_&#123;&#125; &#123;<br>        <span class="hljs-comment">// int value_&#123;d&#125;;  // 编译错误：窄化转换</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>委托构造函数（C++11）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingConstructor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_, z_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 主构造函数</span><br>    <span class="hljs-built_in">DelegatingConstructor</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y), <span class="hljs-built_in">z_</span>(z) &#123;<br>        <span class="hljs-comment">// 复杂的初始化逻辑</span><br>        <span class="hljs-built_in">validate</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">DelegatingConstructor</span>() : <span class="hljs-built_in">DelegatingConstructor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 委托给主构造函数</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">DelegatingConstructor</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">DelegatingConstructor</span>(x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 委托给主构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x_ &lt; <span class="hljs-number">0</span> || y_ &lt; <span class="hljs-number">0</span> || z_ &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Values must be non-negative&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>默认成员初始化（C++11）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMemberInitialization</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count_ = <span class="hljs-number">0</span>;                             <span class="hljs-comment">// 默认初始化</span><br>    std::string name_ = <span class="hljs-string">&quot;Unknown&quot;</span>;              <span class="hljs-comment">// 默认初始化</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;           <span class="hljs-comment">// 默认列表初始化</span><br>    <span class="hljs-type">bool</span> flag_&#123;<span class="hljs-literal">false</span>&#125;;                          <span class="hljs-comment">// 默认初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 使用默认值</span><br>    <span class="hljs-built_in">DefaultMemberInitialization</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 覆盖部分默认值</span><br>    <span class="hljs-built_in">DefaultMemberInitialization</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;<br>        <span class="hljs-comment">// count_, data_, flag_使用默认值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 覆盖所有值</span><br>    <span class="hljs-built_in">DefaultMemberInitialization</span>(<span class="hljs-type">int</span> count, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> flag)<br>        : <span class="hljs-built_in">count_</span>(count), <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">flag_</span>(flag) &#123;<br>        <span class="hljs-comment">// data_仍使用默认值&#123;1, 2, 3&#125;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-特殊情况的处理"><a href="#7-特殊情况的处理" class="headerlink" title="7. 特殊情况的处理"></a>7. <strong>特殊情况的处理</strong></h4><p><strong>const和引用成员：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstAndRefMembers</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> id_;                  <span class="hljs-comment">// const成员</span><br>    <span class="hljs-type">int</span>&amp; external_value_;           <span class="hljs-comment">// 引用成员</span><br>    <span class="hljs-type">const</span> std::string&amp; name_;       <span class="hljs-comment">// const引用成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 必须在初始化列表中初始化const和引用成员</span><br>    <span class="hljs-built_in">ConstAndRefMembers</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span>&amp; ext_val, <span class="hljs-type">const</span> std::string&amp; name)<br>        : <span class="hljs-built_in">id_</span>(id),                  <span class="hljs-comment">// const成员的唯一初始化机会</span><br>          <span class="hljs-built_in">external_value_</span>(ext_val), <span class="hljs-comment">// 引用成员的唯一初始化机会</span><br>          <span class="hljs-built_in">name_</span>(name) &#123;             <span class="hljs-comment">// const引用成员的唯一初始化机会</span><br>        <span class="hljs-comment">// 在构造函数体内无法初始化const和引用成员</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>基类初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> base_value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">base_value_</span>(value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base constructor called with &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBaseValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> base_value_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> derived_value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 基类必须在初始化列表中初始化</span><br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> base_val, <span class="hljs-type">double</span> derived_val)<br>        : <span class="hljs-built_in">Base</span>(base_val),           <span class="hljs-comment">// 基类初始化必须放在最前面</span><br>          <span class="hljs-built_in">derived_value_</span>(derived_val) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误：不能在构造函数体内初始化基类</span><br>    <span class="hljs-comment">// Derived(int base_val, double derived_val) &#123;</span><br>    <span class="hljs-comment">//     Base(base_val);  // 错误！</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>初始化的三个核心原则：</strong></p>
<ol>
<li><strong>手工初始化内置类型</strong>：C++不保证内置类型的初始化</li>
<li><strong>优先使用初始化列表</strong>：效率更高，某些情况下是唯一选择</li>
<li><strong>解决静态对象初始化顺序</strong>：使用local static对象</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>总是初始化内置类型变量</strong></li>
<li><strong>在构造函数中使用成员初始化列表</strong></li>
<li><strong>按成员声明顺序编写初始化列表</strong></li>
<li><strong>用local static对象替换non-local static对象</strong></li>
<li><strong>利用现代C++的初始化语法提高代码安全性</strong></li>
</ul>
<p><strong>记住三个要点：</strong></p>
<ul>
<li>为内置型对象进行手工初始化，因为C++不保证它们</li>
<li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同  </li>
<li>为免除”跨编译单元之初始化次序问题”，请以local static对象替换non-local static对象</li>
</ul>
<h2 id="条款05：-了解C-默认编写并调用了哪些函数"><a href="#条款05：-了解C-默认编写并调用了哪些函数" class="headerlink" title="条款05： 了解C++默认编写并调用了哪些函数"></a>条款05： 了解C++默认编写并调用了哪些函数</h2><blockquote>
<p><em>Know what functions C++ silently writes and calls</em></p>
</blockquote>
<h3 id="核心理念-4"><a href="#核心理念-4" class="headerlink" title="核心理念"></a>核心理念</h3><p>当你声明一个空的class时，编译器会为你暗自生成多个特殊成员函数：<strong>默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数</strong>。在C++11及以后，还可能生成<strong>移动构造函数和移动赋值运算符</strong>。理解这些函数的自动生成规则、行为特点以及潜在问题，是控制类行为和避免意外错误的关键。</p>
<h3 id="深度解析-4"><a href="#深度解析-4" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-编译器默认生成的函数"><a href="#1-编译器默认生成的函数" class="headerlink" title="1. 编译器默认生成的函数"></a>1. <strong>编译器默认生成的函数</strong></h4><p><strong>基本的空类示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 看似空的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;<br><br><span class="hljs-comment">// 编译器实际生成的等价代码（C++98/03）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>() &#123;&#125;                              <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp; rhs) &#123;&#125;              <span class="hljs-comment">// 拷贝构造函数  </span><br>    ~<span class="hljs-built_in">Empty</span>() &#123;&#125;                             <span class="hljs-comment">// 析构函数</span><br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp; rhs) &#123;&#125;   <span class="hljs-comment">// 拷贝赋值运算符</span><br>&#125;;<br><br><span class="hljs-comment">// C++11及以后，可能还会生成</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>() &#123;&#125;                              <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp; rhs) &#123;&#125;              <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">Empty</span>(Empty&amp;&amp; rhs) &#123;&#125;                   <span class="hljs-comment">// 移动构造函数</span><br>    ~<span class="hljs-built_in">Empty</span>() &#123;&#125;                             <span class="hljs-comment">// 析构函数</span><br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp; rhs) &#123;&#125;   <span class="hljs-comment">// 拷贝赋值运算符</span><br>    Empty&amp; <span class="hljs-keyword">operator</span>=(Empty&amp;&amp; rhs) &#123;&#125;        <span class="hljs-comment">// 移动赋值运算符</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>生成条件：只有在被调用时才生成</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    Empty e1;           <span class="hljs-comment">// 调用默认构造函数 → 生成</span><br>    <span class="hljs-function">Empty <span class="hljs-title">e2</span><span class="hljs-params">(e1)</span></span>;       <span class="hljs-comment">// 调用拷贝构造函数 → 生成</span><br>    e2 = e1;            <span class="hljs-comment">// 调用拷贝赋值运算符 → 生成</span><br>    <span class="hljs-comment">// 作用域结束时调用析构函数 → 生成</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-默认构造函数的生成规则"><a href="#2-默认构造函数的生成规则" class="headerlink" title="2. 默认构造函数的生成规则"></a>2. <strong>默认构造函数的生成规则</strong></h4><p><strong>何时生成默认构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 会生成默认构造函数：没有任何构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasDefaultCtor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;     <span class="hljs-comment">// 注意：成员变量未初始化！</span><br>&#125;;<br><br><span class="hljs-comment">// ❌ 不会生成默认构造函数：已声明其他构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDefaultCtor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NoDefaultCtor</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value_</span>(val) &#123;&#125;  <span class="hljs-comment">// 自定义构造函数</span><br>    <span class="hljs-comment">// 编译器不再生成默认构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testConstructors</span><span class="hljs-params">()</span> </span>&#123;<br>    HasDefaultCtor h1;          <span class="hljs-comment">// ✅ 编译成功，调用生成的默认构造函数</span><br>    <span class="hljs-comment">// NoDefaultCtor n1;        // ❌ 编译错误：没有默认构造函数</span><br>    <span class="hljs-function">NoDefaultCtor <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;       <span class="hljs-comment">// ✅ 编译成功，调用自定义构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>默认构造函数的行为：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultBehavior</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> primitive_;             <span class="hljs-comment">// 内置类型：未初始化！</span><br>    std::string object_;        <span class="hljs-comment">// 对象类型：调用默认构造函数</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; container_; <span class="hljs-comment">// 容器：调用默认构造函数（空容器）</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 编译器生成的默认构造函数等价于：</span><br>    <span class="hljs-comment">// DefaultBehavior() : object_(), container_() &#123;</span><br>    <span class="hljs-comment">//     // primitive_ 未初始化！</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDefaultBehavior</span><span class="hljs-params">()</span> </span>&#123;<br>    DefaultBehavior obj;<br>    <span class="hljs-comment">// obj.primitive_ 包含垃圾值！</span><br>    <span class="hljs-comment">// obj.object_ 是空字符串</span><br>    <span class="hljs-comment">// obj.container_ 是空vector</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-拷贝构造函数的默认行为"><a href="#3-拷贝构造函数的默认行为" class="headerlink" title="3. 拷贝构造函数的默认行为"></a>3. <strong>拷贝构造函数的默认行为</strong></h4><p><strong>成员逐一拷贝（memberwise copy）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x_, y_;<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">const</span> std::string&amp; name) <br>        : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y), <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 编译器生成的拷贝构造函数等价于：</span><br>    <span class="hljs-comment">// Point(const Point&amp; other) </span><br>    <span class="hljs-comment">//     : x_(other.x_),           // 内置类型：按位拷贝</span><br>    <span class="hljs-comment">//       y_(other.y_),           // 内置类型：按位拷贝  </span><br>    <span class="hljs-comment">//       name_(other.name_) &#123;&#125;   // 对象：调用string的拷贝构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testCopyCtor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-string">&quot;Origin&quot;</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;                   <span class="hljs-comment">// 调用编译器生成的拷贝构造函数</span><br>    <span class="hljs-comment">// p2.x_ == 3.0, p2.y_ == 4.0, p2.name_ == &quot;Origin&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>包含指针成员的问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DangerousClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DangerousClass</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) &#123;<br>        size_ = <span class="hljs-built_in">strlen</span>(str);<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data_, str);<br>    &#125;<br><br>    ~<span class="hljs-built_in">DangerousClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br><br>    <span class="hljs-comment">// 编译器生成的拷贝构造函数会导致问题：</span><br>    <span class="hljs-comment">// DangerousClass(const DangerousClass&amp; other)</span><br>    <span class="hljs-comment">//     : data_(other.data_),     // 浅拷贝！两个对象指向同一内存</span><br>    <span class="hljs-comment">//       size_(other.size_) &#123;&#125;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateShallowCopy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">DangerousClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">DangerousClass <span class="hljs-title">obj2</span><span class="hljs-params">(obj1)</span></span>;      <span class="hljs-comment">// 浅拷贝：两个对象共享同一data_</span><br>    <br>    <span class="hljs-comment">// 作用域结束时：</span><br>    <span class="hljs-comment">// 1. obj2析构，delete[] data_</span><br>    <span class="hljs-comment">// 2. obj1析构，再次delete[] data_ → 未定义行为！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-拷贝赋值运算符的默认行为"><a href="#4-拷贝赋值运算符的默认行为" class="headerlink" title="4. 拷贝赋值运算符的默认行为"></a>4. <strong>拷贝赋值运算符的默认行为</strong></h4><p><strong>基本的成员逐一赋值：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>    std::string text_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SimpleClass</span>(<span class="hljs-type">int</span> val, <span class="hljs-type">const</span> std::string&amp; text) : <span class="hljs-built_in">value_</span>(val), <span class="hljs-built_in">text_</span>(text) &#123;&#125;<br><br>    <span class="hljs-comment">// 编译器生成的拷贝赋值运算符等价于：</span><br>    <span class="hljs-comment">// SimpleClass&amp; operator=(const SimpleClass&amp; rhs) &#123;</span><br>    <span class="hljs-comment">//     value_ = rhs.value_;    // 内置类型：直接赋值</span><br>    <span class="hljs-comment">//     text_ = rhs.text_;      // 对象：调用string的赋值运算符</span><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>编译器拒绝生成拷贝赋值运算符的情况：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CannotAssign</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> id_;              <span class="hljs-comment">// const成员</span><br>    std::string&amp; name_ref_;     <span class="hljs-comment">// 引用成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CannotAssign</span>(<span class="hljs-type">int</span> id, std::string&amp; name) : <span class="hljs-built_in">id_</span>(id), <span class="hljs-built_in">name_ref_</span>(name) &#123;&#125;<br><br>    <span class="hljs-comment">// 编译器无法生成拷贝赋值运算符，因为：</span><br>    <span class="hljs-comment">// 1. const成员不能被赋值</span><br>    <span class="hljs-comment">// 2. 引用不能被重新赋值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testCannotAssign</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string name1 = <span class="hljs-string">&quot;Alice&quot;</span>;<br>    std::string name2 = <span class="hljs-string">&quot;Bob&quot;</span>;<br>    <br>    <span class="hljs-function">CannotAssign <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">1</span>, name1)</span></span>;<br>    <span class="hljs-function">CannotAssign <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">2</span>, name2)</span></span>;<br>    <br>    <span class="hljs-comment">// obj1 = obj2;  // 编译错误：没有拷贝赋值运算符</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>包含不可赋值成员的类：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonAssignable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    NonAssignable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NonAssignable&amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 显式禁止赋值</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainsNonAssignable</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    NonAssignable member_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 编译器无法生成拷贝赋值运算符，因为member_不可赋值</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-析构函数的默认行为"><a href="#5-析构函数的默认行为" class="headerlink" title="5. 析构函数的默认行为"></a>5. <strong>析构函数的默认行为</strong></h4><p><strong>基本的非虚析构函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string text_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 编译器生成的析构函数等价于：</span><br>    <span class="hljs-comment">// ~SimpleClass() &#123;</span><br>    <span class="hljs-comment">//     // 1. 执行构造函数体（如果有的话）</span><br>    <span class="hljs-comment">//     // 2. 按声明顺序的逆序销毁成员：</span><br>    <span class="hljs-comment">//     //    numbers_.~vector();</span><br>    <span class="hljs-comment">//     //    text_.~string();</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>析构函数的非虚性质问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 编译器生成的析构函数是非虚的！</span><br>    <span class="hljs-comment">// ~Base() &#123;&#125;  // 非虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;  <span class="hljs-comment">// 需要正确析构的成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ~Derived() &#123;</span><br>    <span class="hljs-comment">//     // 销毁data_</span><br>    <span class="hljs-comment">//     // 调用Base::~Base()</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDestructorProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 危险！只调用Base::~Base()，不调用Derived::~Derived()</span><br>                 <span class="hljs-comment">// 导致data_未被正确销毁，可能内存泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-C-11的移动语义支持"><a href="#6-C-11的移动语义支持" class="headerlink" title="6. C++11的移动语义支持"></a>6. <strong>C++11的移动语义支持</strong></h4><p><strong>移动构造函数和移动赋值运算符的生成条件：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveCapable</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MoveCapable</span>(std::string data) : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(data)) &#123;&#125;<br><br>    <span class="hljs-comment">// C++11编译器可能生成：</span><br>    <span class="hljs-comment">// MoveCapable(MoveCapable&amp;&amp; other) noexcept</span><br>    <span class="hljs-comment">//     : data_(std::move(other.data_)),</span><br>    <span class="hljs-comment">//       numbers_(std::move(other.numbers_)) &#123;&#125;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// MoveCapable&amp; operator=(MoveCapable&amp;&amp; other) noexcept &#123;</span><br>    <span class="hljs-comment">//     data_ = std::move(other.data_);</span><br>    <span class="hljs-comment">//     numbers_ = std::move(other.numbers_);</span><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>移动语义的生成规则（Rule of Zero&#x2F;Three&#x2F;Five）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Rule of Zero：尽量不定义任何特殊成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfZero</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr_;<br>    <span class="hljs-comment">// 编译器生成的所有函数都是正确的</span><br>&#125;;<br><br><span class="hljs-comment">// Rule of Three：如果需要自定义析构函数、拷贝构造函数或拷贝赋值运算符中的一个，</span><br><span class="hljs-comment">// 通常需要自定义所有三个</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfThree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 自定义构造函数</span><br>    <span class="hljs-built_in">RuleOfThree</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) &#123;<br>        size_ = <span class="hljs-built_in">strlen</span>(str);<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data_, str);<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 自定义析构函数</span><br>    ~<span class="hljs-built_in">RuleOfThree</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 自定义拷贝构造函数</span><br>    <span class="hljs-built_in">RuleOfThree</span>(<span class="hljs-type">const</span> RuleOfThree&amp; other) : <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data_, other.data_);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 自定义拷贝赋值运算符</span><br>    RuleOfThree&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RuleOfThree&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span>[] data_;<br>            size_ = other.size_;<br>            data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_ + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(data_, other.data_);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Rule of Five：C++11中，如果需要自定义上述三个，通常也需要自定义移动函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfFive</span> : <span class="hljs-keyword">public</span> RuleOfThree &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> RuleOfThree::RuleOfThree;  <span class="hljs-comment">// 继承构造函数</span><br><br>    <span class="hljs-comment">// 4. 移动构造函数</span><br>    <span class="hljs-built_in">RuleOfFive</span>(RuleOfFive&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">data_</span>(other.data_), <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        other.data_ = <span class="hljs-literal">nullptr</span>;<br>        other.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 移动赋值运算符</span><br>    RuleOfFive&amp; <span class="hljs-keyword">operator</span>=(RuleOfFive&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span>[] data_;<br>            data_ = other.data_;<br>            size_ = other.size_;<br>            other.data_ = <span class="hljs-literal">nullptr</span>;<br>            other.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-控制默认函数的生成"><a href="#7-控制默认函数的生成" class="headerlink" title="7. 控制默认函数的生成"></a>7. <strong>控制默认函数的生成</strong></h4><p><strong>使用<code>= default</code>显式要求生成：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExplicitDefault</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ExplicitDefault</span>() = <span class="hljs-keyword">default</span>;                    <span class="hljs-comment">// 显式要求默认构造函数</span><br>    <span class="hljs-built_in">ExplicitDefault</span>(<span class="hljs-type">const</span> ExplicitDefault&amp;) = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 显式要求拷贝构造函数</span><br>    ExplicitDefault&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ExplicitDefault&amp;) = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 显式要求拷贝赋值</span><br>    ~<span class="hljs-built_in">ExplicitDefault</span>() = <span class="hljs-keyword">default</span>;                   <span class="hljs-comment">// 显式要求析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>使用<code>= delete</code>禁止生成：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonCopyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NonCopyable</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">NonCopyable</span>(<span class="hljs-type">const</span> NonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    NonCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 允许移动（可选）</span><br>    <span class="hljs-built_in">NonCopyable</span>(NonCopyable&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    NonCopyable&amp; <span class="hljs-keyword">operator</span>=(NonCopyable&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    <br>    ~<span class="hljs-built_in">NonCopyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNonCopyable</span><span class="hljs-params">()</span> </span>&#123;<br>    NonCopyable obj1;<br>    <span class="hljs-comment">// NonCopyable obj2(obj1);     // 编译错误：拷贝构造函数被删除</span><br>    <span class="hljs-comment">// obj1 = NonCopyable&#123;&#125;;       // 编译错误：拷贝赋值运算符被删除</span><br>    <br>    NonCopyable obj3 = std::<span class="hljs-built_in">move</span>(obj1);  <span class="hljs-comment">// ✅ 移动构造可以</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-实际应用建议"><a href="#8-实际应用建议" class="headerlink" title="8. 实际应用建议"></a>8. <strong>实际应用建议</strong></h4><p><strong>优先使用Rule of Zero：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 推荐：使用RAII和标准库组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    std::unique_ptr&lt;SomeResource&gt; resource_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernClass</span>(std::string name, std::vector&lt;<span class="hljs-type">int</span>&gt; data)<br>        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <br>          <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(data)),<br>          <span class="hljs-built_in">resource_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;SomeResource&gt;()) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 编译器生成的所有特殊成员函数都是正确的！</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>谨慎处理继承层次：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 虚析构函数，确保正确析构派生类</span><br>    <br>    <span class="hljs-comment">// 其他虚函数...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 编译器生成的析构函数会正确调用基类的虚析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>编译器默认生成的函数：</strong></p>
<ol>
<li><strong>默认构造函数</strong>（如果没有其他构造函数）</li>
<li><strong>拷贝构造函数</strong>（除非类不可拷贝）</li>
<li><strong>拷贝赋值运算符</strong>（除非类不可赋值）</li>
<li><strong>析构函数</strong>（总是非虚的，除非基类有虚析构函数）</li>
<li><strong>移动构造函数和移动赋值运算符</strong>（C++11，在特定条件下）</li>
</ol>
<p><strong>关键原则：</strong></p>
<ul>
<li><strong>理解默认行为</strong>：知道编译器会生成什么</li>
<li><strong>控制生成过程</strong>：使用<code>= default</code>和<code>= delete</code></li>
<li><strong>遵循Rule of Zero&#x2F;Three&#x2F;Five</strong>：根据资源管理需求选择合适的规则</li>
<li><strong>注意浅拷贝问题</strong>：包含指针成员时要小心</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>优先使用Rule of Zero</strong>：依赖标准库和RAII</li>
<li><strong>明确禁止不需要的操作</strong>：使用<code>= delete</code></li>
<li><strong>为多态基类提供虚析构函数</strong></li>
<li><strong>使用现代C++特性</strong>：智能指针、容器等</li>
</ul>
<p><strong>记住：编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。</strong></p>
<h2 id="条款06：-若不想使用编译器自动生成的函数，-就该明确拒绝！"><a href="#条款06：-若不想使用编译器自动生成的函数，-就该明确拒绝！" class="headerlink" title="条款06： 若不想使用编译器自动生成的函数， 就该明确拒绝！"></a>条款06： 若不想使用编译器自动生成的函数， 就该明确拒绝！</h2><blockquote>
<p><em>Explicitly disallow the use of compiler-generated functions you do not want</em></p>
</blockquote>
<h3 id="核心理念-5"><a href="#核心理念-5" class="headerlink" title="核心理念"></a>核心理念</h3><p>有些时候，编译器自动生成的特殊成员函数（如拷贝构造函数、拷贝赋值运算符）并不是我们想要的。<strong>明确禁止这些函数比让编译器意外生成它们要安全得多</strong>。理解如何正确地拒绝编译器自动生成的函数，以及不同方法的优缺点，是控制类行为的重要技能。</p>
<h3 id="深度解析-5"><a href="#深度解析-5" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-为什么需要禁止编译器生成的函数"><a href="#1-为什么需要禁止编译器生成的函数" class="headerlink" title="1. 为什么需要禁止编译器生成的函数"></a>1. <strong>为什么需要禁止编译器生成的函数</strong></h4><p><strong>典型场景：唯一性对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 房屋对象应该是唯一的，不应该被拷贝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string address_;<br>    <span class="hljs-type">double</span> area_;<br>    <span class="hljs-type">int</span> rooms_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">House</span>(<span class="hljs-type">const</span> std::string&amp; address, <span class="hljs-type">double</span> area, <span class="hljs-type">int</span> rooms)<br>        : <span class="hljs-built_in">address_</span>(address), <span class="hljs-built_in">area_</span>(area), <span class="hljs-built_in">rooms_</span>(rooms) &#123;&#125;<br><br>    <span class="hljs-comment">// 问题：如果不做处理，编译器会生成拷贝构造函数和拷贝赋值运算符</span><br>    <span class="hljs-comment">// House copy_house = original_house;  // 这样的代码在逻辑上是错误的</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">problematicUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">House <span class="hljs-title">myHouse</span><span class="hljs-params">(<span class="hljs-string">&quot;123 Main St&quot;</span>, <span class="hljs-number">150.0</span>, <span class="hljs-number">3</span>)</span></span>;<br>    House anotherHouse = myHouse;  <span class="hljs-comment">// 编译器生成的拷贝构造函数</span><br>    <br>    <span class="hljs-comment">// 现在有两个&quot;相同&quot;的房子？这在现实中是不可能的！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>资源管理类的问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandle</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FileHandle</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename) &#123;<br>        file_ = std::<span class="hljs-built_in">fopen</span>(filename, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!file_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Cannot open file&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FileHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) std::<span class="hljs-built_in">fclose</span>(file_);<br>    &#125;<br><br>    <span class="hljs-comment">// 问题：默认的拷贝操作会导致多个对象管理同一文件句柄</span><br>    <span class="hljs-comment">// 当多个对象析构时，会多次关闭同一文件，导致未定义行为</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">FileHandle <span class="hljs-title">fh1</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    FileHandle fh2 = fh1;  <span class="hljs-comment">// 危险！两个对象指向同一文件句柄</span><br>    <br>    <span class="hljs-comment">// 作用域结束时：</span><br>    <span class="hljs-comment">// 1. fh2析构，关闭文件</span><br>    <span class="hljs-comment">// 2. fh1析构，再次关闭已关闭的文件 → 未定义行为</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-传统方法：声明为private并不实现"><a href="#2-传统方法：声明为private并不实现" class="headerlink" title="2. 传统方法：声明为private并不实现"></a>2. <strong>传统方法：声明为private并不实现</strong></h4><p><strong>基本技术：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonCopyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NonCopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 声明为private，阻止外部调用</span><br>    <span class="hljs-built_in">NonCopyable</span>(<span class="hljs-type">const</span> NonCopyable&amp;);              <span class="hljs-comment">// 不实现</span><br>    NonCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NonCopyable&amp;);   <span class="hljs-comment">// 不实现</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testTraditionalMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    NonCopyable obj1;<br>    <span class="hljs-comment">// NonCopyable obj2 = obj1;     // 编译错误：拷贝构造函数是private</span><br>    <span class="hljs-comment">// NonCopyable obj3;</span><br>    <span class="hljs-comment">// obj3 = obj1;                 // 编译错误：赋值运算符是private</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优点和缺点：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TraditionalNonCopyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TraditionalNonCopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TraditionalNonCopyable</span>(<span class="hljs-type">const</span> TraditionalNonCopyable&amp;);<br>    TraditionalNonCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TraditionalNonCopyable&amp;);<br><br>    <span class="hljs-comment">// 优点：</span><br>    <span class="hljs-comment">// 1. 编译期就能发现错误</span><br>    <span class="hljs-comment">// 2. 适用于所有C++版本</span><br>    <span class="hljs-comment">// 3. 阻止外部和成员函数/友元函数的误用</span><br><br>    <span class="hljs-comment">// 缺点：</span><br>    <span class="hljs-comment">// 1. 如果成员函数或友元函数意外调用，链接期才能发现错误</span><br>    <span class="hljs-comment">// 2. 错误信息不够明确</span><br>    <span class="hljs-comment">// 3. 需要记住不实现这些函数</span><br>&#125;;<br><br><span class="hljs-comment">// 如果在成员函数中意外调用了私有的拷贝操作：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TraditionalNonCopyable::someMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    TraditionalNonCopyable temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 链接错误，不是编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-基类继承方法"><a href="#3-基类继承方法" class="headerlink" title="3. 基类继承方法"></a>3. <strong>基类继承方法</strong></h4><p><strong>创建专用的基类：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                          <span class="hljs-comment">// 允许派生类构造</span><br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                         <span class="hljs-comment">// 允许派生类析构</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);           <span class="hljs-comment">// 阻止拷贝</span><br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;); <span class="hljs-comment">// 阻止赋值</span><br>&#125;;<br><br><span class="hljs-comment">// 继承自Uncopyable的类自动变为不可拷贝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> : <span class="hljs-keyword">private</span> Uncopyable &#123;  <span class="hljs-comment">// private继承，表示&quot;根据某物实现&quot;</span><br><span class="hljs-keyword">private</span>:<br>    std::string address_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">House</span>(<span class="hljs-type">const</span> std::string&amp; address) : <span class="hljs-built_in">address_</span>(address) &#123;&#125;<br>    <span class="hljs-comment">// 编译器不会生成拷贝操作，因为基类不可拷贝</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testInheritanceMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">House <span class="hljs-title">h1</span><span class="hljs-params">(<span class="hljs-string">&quot;123 Main St&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// House h2 = h1;  // 编译错误：基类Uncopyable不可拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Boost的实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Boost库中的noncopyable实现（简化版）</span><br><span class="hljs-keyword">namespace</span> boost &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">noncopyable</span> &#123;<br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>        ~<span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>        <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-built_in">noncopyable</span>(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>        noncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">private</span> boost::noncopyable &#123;<br>    <span class="hljs-comment">// MyClass自动变为不可拷贝</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-现代方法：使用delete"><a href="#4-现代方法：使用delete" class="headerlink" title="4. 现代方法：使用delete"></a>4. <strong>现代方法：使用delete</strong></h4><p><strong>C++11的&#x3D; delete语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernNonCopyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernNonCopyable</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 明确删除拷贝操作</span><br>    <span class="hljs-built_in">ModernNonCopyable</span>(<span class="hljs-type">const</span> ModernNonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    ModernNonCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ModernNonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 可以选择性地允许移动操作</span><br>    <span class="hljs-built_in">ModernNonCopyable</span>(ModernNonCopyable&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    ModernNonCopyable&amp; <span class="hljs-keyword">operator</span>=(ModernNonCopyable&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    ~<span class="hljs-built_in">ModernNonCopyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testModernMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    ModernNonCopyable obj1;<br>    <span class="hljs-comment">// ModernNonCopyable obj2 = obj1;           // 编译错误：已删除</span><br>    <span class="hljs-comment">// obj1 = ModernNonCopyable&#123;&#125;;              // 编译错误：已删除</span><br>    <br>    ModernNonCopyable obj3 = std::<span class="hljs-built_in">move</span>(obj1);   <span class="hljs-comment">// ✅ 移动操作被允许</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>&#x3D; delete的优势：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteAdvantages</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DeleteAdvantages</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 优势1：更明确的意图表达</span><br>    <span class="hljs-built_in">DeleteAdvantages</span>(<span class="hljs-type">const</span> DeleteAdvantages&amp;) = <span class="hljs-keyword">delete</span>;<br>    DeleteAdvantages&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeleteAdvantages&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 优势2：编译期错误，错误信息更清晰</span><br>    <span class="hljs-comment">// 错误信息：&quot;function has been explicitly deleted&quot;</span><br><br>    <span class="hljs-comment">// 优势3：可以删除任何函数，不仅限于特殊成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dangerousFunction</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span> </span>= <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 禁止double版本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dangerousFunction</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-comment">/* 允许int版本 */</span> &#125;<br><br>    <span class="hljs-comment">// 优势4：不能被成员函数或友元函数意外调用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testDeleteAdvantages</span><span class="hljs-params">()</span> </span>&#123;<br>    DeleteAdvantages obj;<br>    obj.<span class="hljs-built_in">dangerousFunction</span>(<span class="hljs-number">42</span>);      <span class="hljs-comment">// ✅ 调用int版本</span><br>    <span class="hljs-comment">// obj.dangerousFunction(3.14); // ❌ 编译错误：double版本已删除</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-不同禁止策略的对比"><a href="#5-不同禁止策略的对比" class="headerlink" title="5. 不同禁止策略的对比"></a>5. <strong>不同禁止策略的对比</strong></h4><p><strong>仅禁止拷贝，允许移动：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnlyType</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MoveOnlyType</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 禁止拷贝</span><br>    <span class="hljs-built_in">MoveOnlyType</span>(<span class="hljs-type">const</span> MoveOnlyType&amp;) = <span class="hljs-keyword">delete</span>;<br>    MoveOnlyType&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnlyType&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 允许移动</span><br>    <span class="hljs-built_in">MoveOnlyType</span>(MoveOnlyType&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    MoveOnlyType&amp; <span class="hljs-keyword">operator</span>=(MoveOnlyType&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    ~<span class="hljs-built_in">MoveOnlyType</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testMoveOnly</span><span class="hljs-params">()</span> </span>&#123;<br>    MoveOnlyType obj1;<br>    <span class="hljs-comment">// MoveOnlyType obj2 = obj1;                    // ❌ 编译错误：拷贝被禁止</span><br>    MoveOnlyType obj3 = std::<span class="hljs-built_in">move</span>(obj1);            <span class="hljs-comment">// ✅ 移动被允许</span><br>    <br>    std::vector&lt;MoveOnlyType&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(MoveOnlyType&#123;&#125;);                  <span class="hljs-comment">// ✅ 移动到容器中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>禁止所有复制操作：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImmovableType</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ImmovableType</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 禁止拷贝和移动</span><br>    <span class="hljs-built_in">ImmovableType</span>(<span class="hljs-type">const</span> ImmovableType&amp;) = <span class="hljs-keyword">delete</span>;<br>    ImmovableType&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ImmovableType&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">ImmovableType</span>(ImmovableType&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    ImmovableType&amp; <span class="hljs-keyword">operator</span>=(ImmovableType&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    ~<span class="hljs-built_in">ImmovableType</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testImmovable</span><span class="hljs-params">()</span> </span>&#123;<br>    ImmovableType obj;<br>    <span class="hljs-comment">// ImmovableType obj2 = obj;                // ❌ 编译错误</span><br>    <span class="hljs-comment">// ImmovableType obj3 = std::move(obj);     // ❌ 编译错误</span><br>    <br>    <span class="hljs-comment">// 只能通过引用或指针使用</span><br>    ImmovableType* ptr = &amp;obj;<br>    ImmovableType&amp; ref = obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-特殊函数的选择性删除"><a href="#6-特殊函数的选择性删除" class="headerlink" title="6. 特殊函数的选择性删除"></a>6. <strong>特殊函数的选择性删除</strong></h4><p><strong>删除特定的构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeInteger</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> : value_(val) &#123;</span>&#125;<br>    <br>    <span class="hljs-comment">// 禁止从double构造，避免精度丢失</span><br>    <span class="hljs-built_in">SafeInteger</span>(<span class="hljs-type">double</span>) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 禁止从指针构造，避免意外转换</span><br>    <span class="hljs-built_in">SafeInteger</span>(<span class="hljs-type">void</span>*) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSelectiveDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeInteger <span class="hljs-title">si1</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;        <span class="hljs-comment">// ✅ 从int构造</span><br>    <span class="hljs-comment">// SafeInteger si2(3.14);   // ❌ 编译错误：double构造函数被删除</span><br>    <span class="hljs-comment">// SafeInteger si3(nullptr);// ❌ 编译错误：指针构造函数被删除</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>删除特定的运算符：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedOperations</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RestrictedOperations</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value_</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 允许与int的比较</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">int</span> other) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> value_ == other; &#125;<br>    <br>    <span class="hljs-comment">// 禁止与double的比较，避免精度问题</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">double</span>) <span class="hljs-type">const</span> = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 禁止某些危险的运算符</span><br>    RestrictedOperations <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> RestrictedOperations&amp;) <span class="hljs-type">const</span> = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. <strong>实际应用场景</strong></h4><p><strong>单例模式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 禁止拷贝和移动</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 业务逻辑 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>RAII资源管理类：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MutexLock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex&amp; mutex_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">(std::mutex&amp; m)</span> : mutex_(m) &#123;</span><br>        mutex_.<span class="hljs-built_in">lock</span>();<br>    &#125;<br><br>    ~<span class="hljs-built_in">MutexLock</span>() &#123;<br>        mutex_.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝：避免重复锁定/解锁</span><br>    <span class="hljs-built_in">MutexLock</span>(<span class="hljs-type">const</span> MutexLock&amp;) = <span class="hljs-keyword">delete</span>;<br>    MutexLock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MutexLock&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 可以考虑允许移动</span><br>    <span class="hljs-built_in">MutexLock</span>(MutexLock&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">mutex_</span>(other.mutex_) &#123;<br>        other.moved_from_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> moved_from_ = <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>接口基类：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractInterface</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractInterface</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 纯虚函数定义接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 禁止拷贝：接口对象通常应该是多态的，拷贝会切片</span><br>    <span class="hljs-built_in">AbstractInterface</span>(<span class="hljs-type">const</span> AbstractInterface&amp;) = <span class="hljs-keyword">delete</span>;<br>    AbstractInterface&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AbstractInterface&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">AbstractInterface</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 只允许派生类构造</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="8-方法选择指南"><a href="#8-方法选择指南" class="headerlink" title="8. 方法选择指南"></a>8. <strong>方法选择指南</strong></h4><p><strong>现代C++（C++11及以后）推荐做法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecommendedApproach</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RecommendedApproach</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 优先使用 = delete，意图明确</span><br>    <span class="hljs-built_in">RecommendedApproach</span>(<span class="hljs-type">const</span> RecommendedApproach&amp;) = <span class="hljs-keyword">delete</span>;<br>    RecommendedApproach&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RecommendedApproach&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 根据需要决定是否允许移动</span><br>    <span class="hljs-built_in">RecommendedApproach</span>(RecommendedApproach&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    RecommendedApproach&amp; <span class="hljs-keyword">operator</span>=(RecommendedApproach&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    ~<span class="hljs-built_in">RecommendedApproach</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>兼容旧编译器时：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BackwardCompatible</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BackwardCompatible</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 声明为private但不实现</span><br>    <span class="hljs-built_in">BackwardCompatible</span>(<span class="hljs-type">const</span> BackwardCompatible&amp;);<br>    BackwardCompatible&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BackwardCompatible&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>禁止编译器生成函数的方法演进：</strong></p>
<ol>
<li><strong>传统方法</strong>：声明为private并不实现</li>
<li><strong>继承方法</strong>：继承自不可拷贝的基类</li>
<li><strong>现代方法</strong>：使用<code>= delete</code>显式删除</li>
</ol>
<p><strong>选择指南：</strong></p>
<ul>
<li><strong>C++11及以后</strong>：优先使用<code>= delete</code></li>
<li><strong>需要兼容旧编译器</strong>：使用private声明</li>
<li><strong>库设计</strong>：考虑提供基类供用户继承</li>
</ul>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>编译期错误检测</strong>：尽早发现问题</li>
<li><strong>意图明确</strong>：代码自文档化</li>
<li><strong>类型安全</strong>：防止意外的对象复制</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li>明确控制类的拷贝语义</li>
<li>优先考虑移动语义（C++11）</li>
<li>为资源管理类谨慎设计复制操作</li>
<li>使用现代C++特性提高代码清晰度</li>
</ul>
<p><strong>记住：为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</strong></p>
<h2 id="条款07：-为多态基类声明virtual析构函数"><a href="#条款07：-为多态基类声明virtual析构函数" class="headerlink" title="条款07： 为多态基类声明virtual析构函数"></a>条款07： 为多态基类声明virtual析构函数</h2><blockquote>
<p><em>Declare destructors virtual in polymorphic base classes</em></p>
</blockquote>
<h3 id="核心理念-6"><a href="#核心理念-6" class="headerlink" title="核心理念"></a>核心理念</h3><p>在多态继承体系中，<strong>通过基类指针删除派生类对象时，如果基类析构函数不是虚函数，将导致未定义行为</strong>。虚析构函数确保正确的析构顺序：先调用派生类析构函数，再调用基类析构函数。这是C++多态机制中最容易被忽视但极其重要的安全准则。</p>
<h3 id="深度解析-6"><a href="#深度解析-6" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-问题根源：非虚析构函数的危险"><a href="#1-问题根源：非虚析构函数的危险" class="headerlink" title="1. 问题根源：非虚析构函数的危险"></a>1. <strong>问题根源：非虚析构函数的危险</strong></h4><p><strong>典型的错误示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;  <span class="hljs-comment">// 非虚析构函数！</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getCurrentTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicClock</span> : <span class="hljs-keyword">public</span> TimeKeeper &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; calibrationData_;  <span class="hljs-comment">// 需要正确析构的成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AtomicClock</span>() : <span class="hljs-built_in">calibrationData_</span>(<span class="hljs-number">1000000</span>) &#123;&#125;  <span class="hljs-comment">// 分配大量内存</span><br>    <br>    ~<span class="hljs-built_in">AtomicClock</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;AtomicClock destructor called\n&quot;</span>;<br>        <span class="hljs-comment">// calibrationData_会被正确析构</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCurrentTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现原子钟时间获取</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    TimeKeeper* timeKeeper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicClock</span>();<br>    <br>    <span class="hljs-comment">// ... 使用timeKeeper ...</span><br>    <br>    <span class="hljs-keyword">delete</span> timeKeeper;  <span class="hljs-comment">// 危险！只调用TimeKeeper::~TimeKeeper()</span><br>                        <span class="hljs-comment">// AtomicClock::~AtomicClock()不会被调用</span><br>                        <span class="hljs-comment">// calibrationData_可能不会被正确释放</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>问题分析：</strong></p>
<ul>
<li><code>delete timeKeeper</code>只会调用静态绑定的<code>TimeKeeper::~TimeKeeper()</code></li>
<li><code>AtomicClock::~AtomicClock()</code>不会被调用</li>
<li><code>calibrationData_</code>成员可能不会被正确析构，导致内存泄漏</li>
<li>这是<strong>未定义行为</strong>，在不同编译器和平台上可能有不同表现</li>
</ul>
<h4 id="2-解决方案：虚析构函数"><a href="#2-解决方案：虚析构函数" class="headerlink" title="2. 解决方案：虚析构函数"></a>2. <strong>解决方案：虚析构函数</strong></h4><p><strong>正确的实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getCurrentTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicClock</span> : <span class="hljs-keyword">public</span> TimeKeeper &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; calibrationData_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AtomicClock</span>() : <span class="hljs-built_in">calibrationData_</span>(<span class="hljs-number">1000000</span>) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">AtomicClock</span>() <span class="hljs-keyword">override</span> &#123;  <span class="hljs-comment">// 可以显式标记override</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;AtomicClock destructor called\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCurrentTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSolution</span><span class="hljs-params">()</span> </span>&#123;<br>    TimeKeeper* timeKeeper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicClock</span>();<br>    <br>    <span class="hljs-keyword">delete</span> timeKeeper;  <span class="hljs-comment">// 正确！调用顺序：</span><br>                        <span class="hljs-comment">// 1. AtomicClock::~AtomicClock()</span><br>                        <span class="hljs-comment">// 2. TimeKeeper::~TimeKeeper()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>虚析构函数的工作机制：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base constructor\n&quot;</span>; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-string">&quot;Derived data&quot;</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived constructor\n&quot;</span>;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor\n&quot;</span>;<br>        <span class="hljs-comment">// data_会被自动析构</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived func\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testVirtualDestructor</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== Creating object ===\n&quot;</span>;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== Calling virtual function ===\n&quot;</span>;<br>    ptr-&gt;<span class="hljs-built_in">func</span>();<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== Deleting object ===\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 输出：</span><br>                 <span class="hljs-comment">// Derived destructor</span><br>                 <span class="hljs-comment">// Base destructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-何时使用虚析构函数"><a href="#3-何时使用虚析构函数" class="headerlink" title="3. 何时使用虚析构函数"></a>3. <strong>何时使用虚析构函数</strong></h4><p><strong>规则1：多态基类需要虚析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确：多态基类有虚析构函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;           <span class="hljs-comment">// 虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;      <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius_;<br>    std::vector&lt;Point&gt; cachedPoints_;     <span class="hljs-comment">// 复杂成员需要正确析构</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> : radius_(r) &#123;</span>&#125;<br>    <br>    ~<span class="hljs-built_in">Circle</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;         <span class="hljs-comment">// 编译器生成的析构函数就足够了</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius_ * radius_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">usePolymorphically</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;<br>    shapes.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Circle&gt;(<span class="hljs-number">5.0</span>));<br>    <span class="hljs-comment">// shapes析构时会正确调用Circle::~Circle()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>规则2：如果类有任何虚函数，它就应该有虚析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;           <span class="hljs-comment">// 有虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 有虚函数</span><br>    <br>    <span class="hljs-comment">// 因为有虚函数，所以应该有虚析构函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractProcessor</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-何时不应使用虚析构函数"><a href="#4-何时不应使用虚析构函数" class="headerlink" title="4. 何时不应使用虚析构函数"></a>4. <strong>何时不应使用虚析构函数</strong></h4><p><strong>非多态类不需要虚析构函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 错误：为非多态类添加虚析构函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 不要这样做！Point不是为多态设计的</span><br>    <span class="hljs-comment">// virtual ~Point() &#123;&#125;</span><br>    <br>    <span class="hljs-comment">// ✅ 正确：非虚析构函数</span><br>    ~<span class="hljs-built_in">Point</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// Point类的设计意图：</span><br><span class="hljs-comment">// 1. 不是为继承设计的</span><br><span class="hljs-comment">// 2. 没有虚函数</span><br><span class="hljs-comment">// 3. 按值语义使用，不是指针语义</span><br></code></pre></td></tr></table></figure>

<p><strong>虚析构函数的开销：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpensiveVirtualDestructor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ExpensiveVirtualDestructor</span>() &#123;&#125;  <span class="hljs-comment">// 引入虚函数表开销</span><br><br>    <span class="hljs-comment">// 添加虚析构函数的代价：</span><br>    <span class="hljs-comment">// 1. 每个对象增加一个虚函数表指针（通常8字节）</span><br>    <span class="hljs-comment">// 2. 析构时的虚函数调用开销</span><br>    <span class="hljs-comment">// 3. 编译器优化机会减少</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_;  <span class="hljs-comment">// 原本只有8字节，现在变成16字节</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EfficientNonVirtual</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">EfficientNonVirtual</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 非虚析构函数，无额外开销</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_, y_;  <span class="hljs-comment">// 只有8字节</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-标准库类的析构函数问题"><a href="#5-标准库类的析构函数问题" class="headerlink" title="5. 标准库类的析构函数问题"></a>5. <strong>标准库类的析构函数问题</strong></h4><p><strong>标准库容器的非虚析构函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// ❌ 危险：继承标准库容器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVector</span> : <span class="hljs-keyword">public</span> std::vector&lt;<span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyVector</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyVector constructor\n&quot;</span>;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">MyVector</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyVector destructor\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStdContainerProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyVector</span>();<br>    <br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 未定义行为！</span><br>                 <span class="hljs-comment">// std::vector的析构函数不是虚的</span><br>                 <span class="hljs-comment">// MyVector::~MyVector()不会被调用</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 正确：使用组合而非继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeVector</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SafeVector</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SafeVector constructor\n&quot;</span>;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">SafeVector</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SafeVector destructor\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供需要的接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; data_.<span class="hljs-built_in">push_back</span>(value); &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">size</span>(); &#125;<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123; <span class="hljs-keyword">return</span> data_[index]; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-抽象基类的最佳实践"><a href="#6-抽象基类的最佳实践" class="headerlink" title="6. 抽象基类的最佳实践"></a>6. <strong>抽象基类的最佳实践</strong></h4><p><strong>纯虚析构函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractWorker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractWorker</span>() = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 纯虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 即使是纯虚析构函数，也必须提供定义！</span><br>AbstractWorker::~<span class="hljs-built_in">AbstractWorker</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;AbstractWorker destructor\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteWorker</span> : <span class="hljs-keyword">public</span> AbstractWorker &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">ConcreteWorker</span>() <span class="hljs-keyword">override</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteWorker destructor\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Doing concrete work\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPureVirtualDestructor</span><span class="hljs-params">()</span> </span>&#123;<br>    AbstractWorker* worker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteWorker</span>();<br>    worker-&gt;<span class="hljs-built_in">doWork</span>();<br>    <span class="hljs-keyword">delete</span> worker;  <span class="hljs-comment">// 调用顺序：</span><br>                    <span class="hljs-comment">// ConcreteWorker destructor</span><br>                    <span class="hljs-comment">// AbstractWorker destructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>现代C++的推荐写法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernAbstractBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认虚析构函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ModernAbstractBase</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 保护构造函数，防止直接实例化</span><br>    <span class="hljs-built_in">ModernAbstractBase</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 禁止拷贝和赋值（通常抽象基类不应该被拷贝）</span><br>    <span class="hljs-built_in">ModernAbstractBase</span>(<span class="hljs-type">const</span> ModernAbstractBase&amp;) = <span class="hljs-keyword">delete</span>;<br>    ModernAbstractBase&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ModernAbstractBase&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 可以选择性允许移动</span><br>    <span class="hljs-built_in">ModernAbstractBase</span>(ModernAbstractBase&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    ModernAbstractBase&amp; <span class="hljs-keyword">operator</span>=(ModernAbstractBase&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-智能指针时代的考虑"><a href="#7-智能指针时代的考虑" class="headerlink" title="7. 智能指针时代的考虑"></a>7. <strong>智能指针时代的考虑</strong></h4><p><strong>使用智能指针的好处：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernShape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ModernShape</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernCircle</span> : <span class="hljs-keyword">public</span> ModernShape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modernPolymorphicUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ✅ 使用智能指针，自动管理生命周期</span><br>    std::vector&lt;std::unique_ptr&lt;ModernShape&gt;&gt; shapes;<br>    shapes.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;ModernCircle&gt;());<br>    <br>    <span class="hljs-comment">// 作用域结束时自动正确析构，即使有异常也安全</span><br>&#125;<br><br><span class="hljs-comment">// 工厂函数返回智能指针</span><br><span class="hljs-function">std::unique_ptr&lt;ModernShape&gt; <span class="hljs-title">createShape</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ModernCircle&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>RAII和异常安全：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionSafeBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ExceptionSafeBase</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">riskyOperation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionSafeDerived</span> : <span class="hljs-keyword">public</span> ExceptionSafeBase &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ExceptionSafeDerived</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-number">1000</span>) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">ExceptionSafeDerived</span>() <span class="hljs-keyword">override</span> &#123;<br>        <span class="hljs-comment">// 即使在异常情况下也会被正确调用</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Cleaning up derived resources\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">riskyOperation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 可能抛出异常的操作</span><br>        <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Data is empty&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateExceptionSafety</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::unique_ptr&lt;ExceptionSafeBase&gt; obj = <br>            std::<span class="hljs-built_in">make_unique</span>&lt;ExceptionSafeDerived&gt;();<br>        <br>        obj-&gt;<span class="hljs-built_in">riskyOperation</span>();  <span class="hljs-comment">// 可能抛出异常</span><br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 即使发生异常，对象也会被正确析构</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-性能考虑与权衡"><a href="#8-性能考虑与权衡" class="headerlink" title="8. 性能考虑与权衡"></a>8. <strong>性能考虑与权衡</strong></h4><p><strong>虚函数表的内存布局：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WithVirtualDestructor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">WithVirtualDestructor</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data1_;<br>    <span class="hljs-type">int</span> data2_;<br>    <br>    <span class="hljs-comment">// 内存布局（64位系统）：</span><br>    <span class="hljs-comment">// [vptr: 8字节] [data1_: 4字节] [data2_: 4字节] [填充: 0字节]</span><br>    <span class="hljs-comment">// 总大小：16字节</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WithoutVirtualDestructor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">WithoutVirtualDestructor</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data1_;<br>    <span class="hljs-type">int</span> data2_;<br>    <br>    <span class="hljs-comment">// 内存布局：</span><br>    <span class="hljs-comment">// [data1_: 4字节] [data2_: 4字节]</span><br>    <span class="hljs-comment">// 总大小：8字节</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compareSize</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;With virtual destructor: &quot;</span> <br>              &lt;&lt; <span class="hljs-built_in">sizeof</span>(WithVirtualDestructor) &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;    <span class="hljs-comment">// 16</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Without virtual destructor: &quot;</span> <br>              &lt;&lt; <span class="hljs-built_in">sizeof</span>(WithoutVirtualDestructor) &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>; <span class="hljs-comment">// 8</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><strong>虚析构函数的核心原则：</strong></p>
<ol>
<li><strong>多态基类必须有虚析构函数</strong></li>
<li><strong>有虚函数的类应该有虚析构函数</strong></li>
<li><strong>非多态类不应该有虚析构函数</strong></li>
</ol>
<p><strong>实践指南：</strong></p>
<ul>
<li><strong>为多态基类声明虚析构函数</strong>：确保正确的析构顺序</li>
<li><strong>使用<code>= default</code></strong>：让编译器生成默认实现</li>
<li><strong>考虑使用智能指针</strong>：自动管理对象生命周期</li>
<li><strong>不要继承标准库容器</strong>：它们的析构函数不是虚的</li>
</ul>
<p><strong>现代C++最佳实践：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 推荐的多态基类设计</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecommendedBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RecommendedBase</span>() = <span class="hljs-keyword">default</span>;     <span class="hljs-comment">// 虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">interface</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 纯虚接口</span><br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">RecommendedBase</span>() = <span class="hljs-keyword">default</span>;              <span class="hljs-comment">// 保护构造函数</span><br>    <br>    <span class="hljs-comment">// 通常禁止拷贝</span><br>    <span class="hljs-built_in">RecommendedBase</span>(<span class="hljs-type">const</span> RecommendedBase&amp;) = <span class="hljs-keyword">delete</span>;<br>    RecommendedBase&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RecommendedBase&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 可选择性允许移动</span><br>    <span class="hljs-built_in">RecommendedBase</span>(RecommendedBase&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    RecommendedBase&amp; <span class="hljs-keyword">operator</span>=(RecommendedBase&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>记住两个要点：</strong></p>
<ul>
<li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li>Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphic），就不该声明virtual析构函数</li>
</ul>
<h2 id="条款08：-别让异常逃离析构函数"><a href="#条款08：-别让异常逃离析构函数" class="headerlink" title="条款08： 别让异常逃离析构函数"></a>条款08： 别让异常逃离析构函数</h2><blockquote>
<p><em>Prevent exceptions from leaving destructors</em></p>
</blockquote>
<h3 id="核心理念-7"><a href="#核心理念-7" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>析构函数抛出异常会导致程序的未定义行为</strong>，特别是在栈展开（stack unwinding）过程中。当多个对象同时析构时，如果析构函数抛出异常，程序将面临”同时处理两个异常”的困境，通常导致程序terminate。正确的做法是在析构函数中捕获所有异常，要么吞掉它们，要么记录日志后结束程序。</p>
<h3 id="深度解析-7"><a href="#深度解析-7" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-析构函数抛异常的危险性"><a href="#1-析构函数抛异常的危险性" class="headerlink" title="1. 析构函数抛异常的危险性"></a>1. <strong>析构函数抛异常的危险性</strong></h4><p><strong>双重异常问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProblematicDestructor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">ProblematicDestructor</span>() &#123;<br>        <span class="hljs-comment">// 危险！析构函数抛出异常</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Destructor failed!&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDoubleException</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ProblematicDestructor obj1;<br>        ProblematicDestructor obj2;<br>        <br>        <span class="hljs-comment">// 手动抛出第一个异常，开始栈展开</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Primary exception&quot;</span>);<br>        <br>        <span class="hljs-comment">// 当栈展开时：</span><br>        <span class="hljs-comment">// 1. obj2析构 -&gt; 抛出异常</span><br>        <span class="hljs-comment">// 2. obj1析构 -&gt; 又抛出异常</span><br>        <span class="hljs-comment">// 结果：程序terminate！</span><br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 这里永远不会到达，因为程序已经terminate</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>容器析构的连锁反应：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadResource</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BadResource</span>(<span class="hljs-type">int</span> id) : <span class="hljs-built_in">id_</span>(id) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">BadResource</span>() &#123;<br>        <span class="hljs-comment">// 模拟析构失败</span><br>        <span class="hljs-keyword">if</span> (id_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Even numbered resource failed to destruct&quot;</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateContainerDestruction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::vector&lt;BadResource&gt; resources;<br>        <br>        <span class="hljs-comment">// 添加多个资源</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>            resources.<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当vector析构时，会依次调用每个元素的析构函数</span><br>        <span class="hljs-comment">// 如果任何一个抛出异常，整个程序可能崩溃</span><br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This may never be reached\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-栈展开过程中的异常"><a href="#2-栈展开过程中的异常" class="headerlink" title="2. 栈展开过程中的异常"></a>2. <strong>栈展开过程中的异常</strong></h4><p><strong>理解栈展开：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackUnwindingDemo</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StackUnwindingDemo</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; constructed\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 危险的析构函数</span><br>    ~<span class="hljs-built_in">StackUnwindingDemo</span>() <span class="hljs-built_in">noexcept</span>(<span class="hljs-literal">false</span>) &#123;  <span class="hljs-comment">// 明确标记可能抛异常</span><br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; destructor called\n&quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span> (name_ == <span class="hljs-string">&quot;problematic&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(name_ + <span class="hljs-string">&quot; destructor failed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStackUnwinding</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">StackUnwindingDemo <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;first&quot;</span>)</span></span>;<br>        <span class="hljs-function">StackUnwindingDemo <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-string">&quot;problematic&quot;</span>)</span></span>;  <span class="hljs-comment">// 这个会在析构时抛异常</span><br>        <span class="hljs-function">StackUnwindingDemo <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-string">&quot;third&quot;</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Main exception&quot;</span>);  <span class="hljs-comment">// 开始栈展开</span><br>        <br>        <span class="hljs-comment">// 栈展开顺序：obj3 -&gt; obj2 -&gt; obj1</span><br>        <span class="hljs-comment">// 当obj2析构时抛出异常，程序terminate</span><br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-正确处理析构函数中的异常"><a href="#3-正确处理析构函数中的异常" class="headerlink" title="3. 正确处理析构函数中的异常"></a>3. <strong>正确处理析构函数中的异常</strong></h4><p><strong>方法1：吞掉异常</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeDestructor1</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SafeDestructor1</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">SafeDestructor1</span>() <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">// 保证不抛异常</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 可能抛出异常的清理操作</span><br>            <span class="hljs-built_in">performCleanup</span>();<br>            <br>        &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>            <span class="hljs-comment">// 记录错误但不重新抛出</span><br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in destructor of &quot;</span> &lt;&lt; name_ <br>                      &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>            <br>            <span class="hljs-comment">// 异常被&quot;吞掉&quot;，不会传播</span><br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// 捕获所有其他异常</span><br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Unknown error in destructor of &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performCleanup</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟可能失败的清理操作</span><br>        <span class="hljs-keyword">if</span> (name_ == <span class="hljs-string">&quot;fail&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Cleanup failed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>方法2：终止程序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeDestructor2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SafeDestructor2</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">SafeDestructor2</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">performCriticalCleanup</span>();<br>            <br>        &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>            <span class="hljs-comment">// 对于关键资源，清理失败可能意味着程序状态不一致</span><br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Critical cleanup failed for &quot;</span> &lt;&lt; name_ <br>                      &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>            <br>            <span class="hljs-comment">// 选择终止程序而不是继续运行在不一致状态</span><br>            std::<span class="hljs-built_in">abort</span>();  <span class="hljs-comment">// 或者 std::terminate()</span><br>            <br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Critical cleanup failed with unknown error for &quot;</span> <br>                      &lt;&lt; name_ &lt;&lt; std::endl;<br>            std::<span class="hljs-built_in">abort</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performCriticalCleanup</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 关键清理操作</span><br>        <span class="hljs-keyword">if</span> (name_ == <span class="hljs-string">&quot;critical_fail&quot;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Critical cleanup failed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-提供普通函数处理可能失败的操作"><a href="#4-提供普通函数处理可能失败的操作" class="headerlink" title="4. 提供普通函数处理可能失败的操作"></a>4. <strong>提供普通函数处理可能失败的操作</strong></h4><p><strong>设计原则：分离可能失败的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> connected_;<br>    std::string connection_string_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DatabaseConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; conn_str)</span> </span><br><span class="hljs-function">        : connected_(true), connection_string_(conn_str) &#123;</span><br>        <span class="hljs-comment">// 建立连接</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 提供显式的清理函数，允许异常传播</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connected_) &#123;<br>            <span class="hljs-comment">// 这里可能抛出异常，调用者可以处理</span><br>            <span class="hljs-keyword">if</span> (connection_string_ == <span class="hljs-string">&quot;bad_connection&quot;</span>) &#123;<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to close database connection&quot;</span>);<br>            &#125;<br>            <br>            connected_ = <span class="hljs-literal">false</span>;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Database connection closed successfully\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 析构函数提供&quot;最后的防线&quot;，但不抛异常</span><br>    ~<span class="hljs-built_in">DatabaseConnection</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (connected_) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 尝试清理，但不抛异常</span><br>                <span class="hljs-built_in">close</span>();<br>                <br>            &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>                <span class="hljs-comment">// 记录错误，但不传播异常</span><br>                std::cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Failed to close connection in destructor: &quot;</span> <br>                          &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>                <span class="hljs-comment">// 可能还需要做一些紧急清理</span><br>                connected_ = <span class="hljs-literal">false</span>;<br>                <br>            &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>                std::cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Unknown error closing connection in destructor\n&quot;</span>;<br>                connected_ = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> connected_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProperDesign</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">DatabaseConnection <span class="hljs-title">conn</span><span class="hljs-params">(<span class="hljs-string">&quot;good_connection&quot;</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 进行数据库操作...</span><br>        <br>        <span class="hljs-comment">// 显式关闭，可以处理异常</span><br>        conn.<span class="hljs-built_in">close</span>();<br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Handled connection error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果没有显式关闭，析构函数会静默处理</span><br>    <span class="hljs-function">DatabaseConnection <span class="hljs-title">conn2</span><span class="hljs-params">(<span class="hljs-string">&quot;bad_connection&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// conn2析构时不会抛出异常，只会记录警告</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-RAII类的异常安全设计"><a href="#5-RAII类的异常安全设计" class="headerlink" title="5. RAII类的异常安全设计"></a>5. <strong>RAII类的异常安全设计</strong></h4><p><strong>文件管理的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeFileHandler</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br>    std::string filename_;<br>    <span class="hljs-type">bool</span> explicitly_closed_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeFileHandler</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span><br><span class="hljs-function">        : filename_(filename), explicitly_closed_(false) &#123;</span><br>        <br>        file_ = std::<span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file: &quot;</span> + filename);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供显式关闭函数，允许错误处理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (file_ &amp;&amp; !explicitly_closed_) &#123;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">fclose</span>(file_) != <span class="hljs-number">0</span>) &#123;<br>                file_ = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 标记为已关闭，即使失败</span><br>                explicitly_closed_ = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to close file: &quot;</span> + filename_);<br>            &#125;<br>            <br>            file_ = <span class="hljs-literal">nullptr</span>;<br>            explicitly_closed_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 写入数据（可能失败）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;File is not open&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">fputs</span>(data.<span class="hljs-built_in">c_str</span>(), file_) == EOF) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to write to file&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 析构函数：最后的安全网</span><br>    ~<span class="hljs-built_in">SafeFileHandler</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (file_ &amp;&amp; !explicitly_closed_) &#123;<br>            <span class="hljs-comment">// 尝试关闭，但不抛异常</span><br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">fclose</span>(file_) != <span class="hljs-number">0</span>) &#123;<br>                std::cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Failed to close file &quot;</span> &lt;&lt; filename_ <br>                          &lt;&lt; <span class="hljs-string">&quot; in destructor\n&quot;</span>;<br>                <span class="hljs-comment">// 可能需要记录到日志文件或系统日志</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝，避免重复关闭</span><br>    <span class="hljs-built_in">SafeFileHandler</span>(<span class="hljs-type">const</span> SafeFileHandler&amp;) = <span class="hljs-keyword">delete</span>;<br>    SafeFileHandler&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SafeFileHandler&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 允许移动</span><br>    <span class="hljs-built_in">SafeFileHandler</span>(SafeFileHandler&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">file_</span>(other.file_), <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(other.filename_)),<br>          <span class="hljs-built_in">explicitly_closed_</span>(other.explicitly_closed_) &#123;<br>        other.file_ = <span class="hljs-literal">nullptr</span>;<br>        other.explicitly_closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateFileHandling</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">SafeFileHandler <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;test.txt&quot;</span>)</span></span>;<br>        <br>        file.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>        file.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;This is a test.\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 显式关闭，可以处理错误</span><br>        file.<span class="hljs-built_in">close</span>();<br>        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File operations completed successfully\n&quot;</span>;<br>        <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File operation failed: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-现代C-的异常安全析构函数"><a href="#6-现代C-的异常安全析构函数" class="headerlink" title="6. 现代C++的异常安全析构函数"></a>6. <strong>现代C++的异常安全析构函数</strong></h4><p><strong>使用noexcept规范：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernSafeClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernSafeClass</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size)), <span class="hljs-built_in">size_</span>(size) &#123;&#125;  <span class="hljs-comment">// C++14</span><br>    <br>    <span class="hljs-comment">// 现代C++析构函数默认是noexcept的</span><br>    ~<span class="hljs-built_in">ModernSafeClass</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 智能指针会自动清理，不会抛异常</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Safely destroyed ModernSafeClass with &quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot; elements\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数也应该是noexcept的</span><br>    <span class="hljs-built_in">ModernSafeClass</span>(ModernSafeClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(other.data_)), <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        other.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    ModernSafeClass&amp; <span class="hljs-keyword">operator</span>=(ModernSafeClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            data_ = std::<span class="hljs-built_in">move</span>(other.data_);<br>            size_ = other.size_;<br>            other.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>智能指针和容器的异常安全：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerSafeClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::string&gt; data_;<br>    std::unique_ptr&lt;std::ofstream&gt; log_file_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ContainerSafeClass</span>() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log_file_ = std::<span class="hljs-built_in">make_unique</span>&lt;std::ofstream&gt;(<span class="hljs-string">&quot;log.txt&quot;</span>);<br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// 构造函数中可以抛异常</span><br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">ContainerSafeClass</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// std::vector和std::unique_ptr的析构函数都是noexcept的</span><br>        <span class="hljs-comment">// 所以这个析构函数天然就是安全的</span><br>        <br>        <span class="hljs-keyword">if</span> (log_file_ &amp;&amp; log_file_-&gt;<span class="hljs-built_in">is_open</span>()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                *log_file_ &lt;&lt; <span class="hljs-string">&quot;Object destroyed safely\n&quot;</span>;<br>                log_file_-&gt;<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能失败，但我们捕获异常</span><br>            &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>                <span class="hljs-comment">// 静默处理文件关闭错误</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; item)</span> </span>&#123;<br>        data_.<span class="hljs-built_in">push_back</span>(item);  <span class="hljs-comment">// 这里可以抛异常，因为不在析构函数中</span><br>        <br>        <span class="hljs-keyword">if</span> (log_file_) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                *log_file_ &lt;&lt; <span class="hljs-string">&quot;Added: &quot;</span> &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>                <span class="hljs-comment">// 日志失败不应该影响主要功能</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-异常安全级别与析构函数"><a href="#7-异常安全级别与析构函数" class="headerlink" title="7. 异常安全级别与析构函数"></a>7. <strong>异常安全级别与析构函数</strong></h4><p><strong>三种异常安全保证：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionSafetyDemo</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::string&gt; data_;<br>    std::unique_ptr&lt;std::ofstream&gt; backup_file_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：可以抛异常</span><br>    <span class="hljs-built_in">ExceptionSafetyDemo</span>(<span class="hljs-type">const</span> std::string&amp; backup_path) &#123;<br>        backup_file_ = std::<span class="hljs-built_in">make_unique</span>&lt;std::ofstream&gt;(backup_path);<br>        <span class="hljs-keyword">if</span> (!backup_file_-&gt;<span class="hljs-built_in">is_open</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Cannot open backup file&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 基本保证：操作可能失败，但对象状态一致</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; item)</span> </span>&#123;<br>        data_.<span class="hljs-built_in">push_back</span>(item);  <span class="hljs-comment">// 可能抛异常</span><br>        <br>        <span class="hljs-comment">// 如果备份失败，我们不回滚主数据</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            *backup_file_ &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            backup_file_-&gt;<span class="hljs-built_in">flush</span>();<br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// 基本保证：主数据已添加，但备份可能失败</span><br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Failed to backup item\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 强保证：要么完全成功，要么完全失败</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addItemWithStrongGuarantee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; item)</span> </span>&#123;<br>        <span class="hljs-comment">// 先备份</span><br>        std::streampos pos = backup_file_-&gt;<span class="hljs-built_in">tellp</span>();<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            *backup_file_ &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            backup_file_-&gt;<span class="hljs-built_in">flush</span>();<br>            <br>            <span class="hljs-comment">// 备份成功后再添加到主数据</span><br>            data_.<span class="hljs-built_in">push_back</span>(item);<br>            <br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// 恢复备份文件状态</span><br>            backup_file_-&gt;<span class="hljs-built_in">seekp</span>(pos);<br>            <span class="hljs-keyword">throw</span>;  <span class="hljs-comment">// 重新抛出异常</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不抛异常保证：析构函数必须提供</span><br>    ~<span class="hljs-built_in">ExceptionSafetyDemo</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 这里必须提供不抛异常保证</span><br>        <span class="hljs-keyword">if</span> (backup_file_) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                backup_file_-&gt;<span class="hljs-built_in">close</span>();<br>            &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>                <span class="hljs-comment">// 吞掉所有异常</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><strong>析构函数异常安全的核心原则：</strong></p>
<ol>
<li><strong>析构函数绝对不要抛出异常</strong></li>
<li><strong>在析构函数中捕获所有异常</strong></li>
<li><strong>提供普通函数处理可能失败的操作</strong></li>
</ol>
<p><strong>处理析构函数异常的策略：</strong></p>
<ul>
<li><strong>吞掉异常</strong>：记录错误但不传播</li>
<li><strong>终止程序</strong>：对于关键错误，选择abort()</li>
<li><strong>使用noexcept规范</strong>：明确标记函数不抛异常</li>
</ul>
<p><strong>设计模式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecommendedPattern</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供显式操作函数，允许异常处理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">explicitCleanup</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 可能抛出异常，调用者负责处理</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 析构函数作为最后的安全网</span><br>    ~<span class="hljs-built_in">RecommendedPattern</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">explicitCleanup</span>();<br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// 记录错误但不抛异常</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>优先使用RAII和智能指针</strong>：它们的析构函数是异常安全的</li>
<li><strong>分离关注点</strong>：将可能失败的操作提取到普通函数中</li>
<li><strong>使用noexcept</strong>：明确表达异常安全保证</li>
<li><strong>记录错误</strong>：即使不能抛异常，也要记录问题</li>
</ul>
<p><strong>记住两个要点：</strong></p>
<ul>
<li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</li>
</ul>
<h2 id="条款09-：-绝不在构造和析构过程中调用virtual函数"><a href="#条款09-：-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09 ： 绝不在构造和析构过程中调用virtual函数"></a>条款09 ： 绝不在构造和析构过程中调用virtual函数</h2><blockquote>
<p><em>Never call virtual functions during construction or destruction</em></p>
</blockquote>
<h3 id="核心理念-8"><a href="#核心理念-8" class="headerlink" title="核心理念"></a>核心理念</h3><p>在构造和析构过程中，<strong>虚函数调用不会表现出多态行为</strong>。当基类构造函数或析构函数执行时，派生类的部分还未构造完成或已被销毁，此时调用虚函数只会调用当前正在构造&#x2F;析构的类的版本，而不是最终派生类的版本。这种行为往往与程序员的期望不符，可能导致难以发现的逻辑错误。</p>
<h3 id="深度解析-8"><a href="#深度解析-8" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-问题根源：对象构造和析构的阶段性"><a href="#1-问题根源：对象构造和析构的阶段性" class="headerlink" title="1. 问题根源：对象构造和析构的阶段性"></a>1. <strong>问题根源：对象构造和析构的阶段性</strong></h4><p><strong>构造过程中的虚函数调用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Transaction</span>() &#123;<br>        <span class="hljs-comment">// ❌ 危险：在构造函数中调用虚函数</span><br>        <span class="hljs-built_in">logTransaction</span>();  <span class="hljs-comment">// 总是调用Transaction::logTransaction()</span><br>                          <span class="hljs-comment">// 即使这是派生类的构造过程</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Transaction base logging\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Transaction</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span> : <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BuyTransaction</span>() &#123;<br>        <span class="hljs-comment">// 在这个构造函数执行前，Transaction的构造函数已经调用了logTransaction()</span><br>        <span class="hljs-comment">// 但调用的是Transaction::logTransaction()，而不是BuyTransaction::logTransaction()</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;BuyTransaction constructed\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Buy transaction logging\n&quot;</span>;  <span class="hljs-comment">// 在构造期间不会被调用！</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateConstructionProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    BuyTransaction buy;  <span class="hljs-comment">// 输出：</span><br>                         <span class="hljs-comment">// &quot;Transaction base logging&quot;     ← 基类版本被调用</span><br>                         <span class="hljs-comment">// &quot;BuyTransaction constructed&quot;   ← 派生类构造完成</span><br>    <br>    <span class="hljs-comment">// 期望：调用BuyTransaction::logTransaction()</span><br>    <span class="hljs-comment">// 实际：调用Transaction::logTransaction()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>析构过程中的虚函数调用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Resource</span>() &#123;<br>        <span class="hljs-comment">// ❌ 危险：在析构函数中调用虚函数</span><br>        <span class="hljs-built_in">cleanup</span>();  <span class="hljs-comment">// 总是调用Resource::cleanup()</span><br>                    <span class="hljs-comment">// 即使这是派生类对象的析构</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource cleanup: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseResource</span> : <span class="hljs-keyword">public</span> Resource &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DatabaseResource</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">Resource</span>(name), <span class="hljs-built_in">data_</span>(<span class="hljs-number">1000</span>) &#123;&#125;<br>    <br>    ~<span class="hljs-built_in">DatabaseResource</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DatabaseResource destructor\n&quot;</span>;<br>        <span class="hljs-comment">// 在这个析构函数执行后，Resource的析构函数会调用cleanup()</span><br>        <span class="hljs-comment">// 但调用的是Resource::cleanup()，而不是DatabaseResource::cleanup()</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Database cleanup with &quot;</span> &lt;&lt; data_.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; elements\n&quot;</span>;<br>        data_.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 在析构期间这可能已经无意义或危险！</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDestructionProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    DatabaseResource* db = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DatabaseResource</span>(<span class="hljs-string">&quot;TestDB&quot;</span>);<br>    <span class="hljs-keyword">delete</span> db;  <span class="hljs-comment">// 输出：</span><br>                <span class="hljs-comment">// &quot;DatabaseResource destructor&quot;     ← 派生类析构函数</span><br>                <span class="hljs-comment">// &quot;Resource cleanup: TestDB&quot;        ← 基类版本被调用</span><br>                <br>    <span class="hljs-comment">// 期望：调用DatabaseResource::cleanup()</span><br>    <span class="hljs-comment">// 实际：调用Resource::cleanup()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-为什么虚函数在构造-析构中不起作用"><a href="#2-为什么虚函数在构造-析构中不起作用" class="headerlink" title="2. 为什么虚函数在构造&#x2F;析构中不起作用"></a>2. <strong>为什么虚函数在构造&#x2F;析构中不起作用</strong></h4><p><strong>对象构造的阶段性：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base constructor start\n&quot;</span>;<br>        <br>        <span class="hljs-comment">// 此时对象的类型是Base，不是Derived</span><br>        <span class="hljs-comment">// 虚函数表指针指向Base的虚函数表</span><br>        <span class="hljs-built_in">virtualFunction</span>();  <span class="hljs-comment">// 调用Base::virtualFunction()</span><br>        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base constructor end\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">virtualFunction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::virtualFunction()\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-string">&quot;Derived data&quot;</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived constructor\n&quot;</span>;<br>        <span class="hljs-comment">// 只有到这里，对象才真正变成Derived类型</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">virtualFunction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::virtualFunction() with data: &quot;</span> &lt;&lt; data_ &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// 如果在Base构造函数中调用，data_还未初始化！</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStageConstruction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Creating Derived object:\n&quot;</span>;<br>    Derived d;  <span class="hljs-comment">// 构造顺序：</span><br>                <span class="hljs-comment">// 1. Base constructor start</span><br>                <span class="hljs-comment">// 2. Base::virtualFunction()      ← 不是Derived版本！</span><br>                <span class="hljs-comment">// 3. Base constructor end</span><br>                <span class="hljs-comment">// 4. Derived constructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>类型安全的考虑：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafetyDemo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SafetyDemo</span>() &#123;<br>        <span class="hljs-comment">// C++的设计确保类型安全</span><br>        <span class="hljs-comment">// 在构造期间，对象的&quot;类型&quot;就是当前正在构造的类</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Type during construction: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SafetyDemo</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSafety</span> : <span class="hljs-keyword">public</span> SafetyDemo &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteSafety</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Type in derived constructor: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 现在可以安全调用虚函数，因为对象构造完成</span><br>        <span class="hljs-built_in">identify</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ConcreteSafety object\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-解决方案：避免在构造-析构中调用虚函数"><a href="#3-解决方案：避免在构造-析构中调用虚函数" class="headerlink" title="3. 解决方案：避免在构造&#x2F;析构中调用虚函数"></a>3. <strong>解决方案：避免在构造&#x2F;析构中调用虚函数</strong></h4><p><strong>方案1：使用非虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; type)</span> </span>&#123;<br>        <span class="hljs-comment">// ✅ 调用非虚函数，传递必要信息</span><br>        <span class="hljs-built_in">logTransaction</span>(type);<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Transaction</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 非虚函数，在构造期间安全调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; type)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Transaction logged: &quot;</span> &lt;&lt; type &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span> : <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BuyTransaction</span>() : <span class="hljs-built_in">Transaction</span>(<span class="hljs-string">&quot;Buy&quot;</span>) &#123;  <span class="hljs-comment">// 传递类型信息给基类</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;BuyTransaction construction complete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span> : <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SellTransaction</span>() : <span class="hljs-built_in">Transaction</span>(<span class="hljs-string">&quot;Sell&quot;</span>) &#123;  <span class="hljs-comment">// 传递类型信息给基类</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SellTransaction construction complete\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>方案2：静态函数辅助</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">logCreation</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; objectType, <span class="hljs-type">const</span> std::string&amp; details)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Creating &quot;</span> &lt;&lt; objectType &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; details &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">logDestruction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; objectType)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destroying &quot;</span> &lt;&lt; objectType &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Resource</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> : name_(name) &#123;</span><br>        <span class="hljs-comment">// ✅ 基类只记录自己的创建</span><br>        Logger::<span class="hljs-built_in">logCreation</span>(<span class="hljs-string">&quot;Resource&quot;</span>, name_);<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Resource</span>() &#123;<br>        <span class="hljs-comment">// ✅ 基类只记录自己的销毁</span><br>        Logger::<span class="hljs-built_in">logDestruction</span>(<span class="hljs-string">&quot;Resource&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileResource</span> : <span class="hljs-keyword">public</span> Resource &#123;<br><span class="hljs-keyword">private</span>:<br>    std::ofstream file_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FileResource</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span><br><span class="hljs-function">        : Resource(filename), file_(filename) &#123;</span><br>        <br>        <span class="hljs-comment">// ✅ 派生类记录自己的特定创建逻辑</span><br>        Logger::<span class="hljs-built_in">logCreation</span>(<span class="hljs-string">&quot;FileResource&quot;</span>, <span class="hljs-string">&quot;opened file: &quot;</span> + filename);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">FileResource</span>() &#123;<br>        <span class="hljs-comment">// ✅ 派生类记录自己的特定销毁逻辑</span><br>        Logger::<span class="hljs-built_in">logDestruction</span>(<span class="hljs-string">&quot;FileResource&quot;</span>);<br>        file_.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>方案3：两阶段构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexObject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">bool</span> initialized_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ComplexObject</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span><br><span class="hljs-function">        : name_(name), initialized_(false) &#123;</span><br>        <span class="hljs-comment">// 构造函数只做基本初始化，不调用虚函数</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 提供初始化函数，在对象完全构造后调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!initialized_) &#123;<br>            <span class="hljs-built_in">performInitialization</span>();  <span class="hljs-comment">// 现在可以安全调用虚函数</span><br>            initialized_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ComplexObject</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">performInitialization</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ComplexObject initialized: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInitialized</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> initialized_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecializedObject</span> : <span class="hljs-keyword">public</span> ComplexObject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SpecializedObject</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span><br><span class="hljs-function">        : ComplexObject(name), data_(<span class="hljs-number">100</span>) &#123;</span><br>        <span class="hljs-comment">// 派生类构造完成后再初始化</span><br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ComplexObject::<span class="hljs-built_in">performInitialization</span>();  <span class="hljs-comment">// 调用基类版本</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SpecializedObject initialized with &quot;</span> &lt;&lt; data_.<span class="hljs-built_in">size</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot; elements\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateTwoPhaseConstruction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SpecializedObject <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-string">&quot;test&quot;</span>)</span></span>;<br>    obj.<span class="hljs-built_in">initialize</span>();  <span class="hljs-comment">// 现在虚函数调用按预期工作</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-实际应用中的最佳实践"><a href="#4-实际应用中的最佳实践" class="headerlink" title="4. 实际应用中的最佳实践"></a>4. <strong>实际应用中的最佳实践</strong></h4><p><strong>RAII类的正确设计：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string endpoint_;<br>    <span class="hljs-type">bool</span> connected_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Connection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; endpoint)</span> </span><br><span class="hljs-function">        : endpoint_(endpoint), connected_(false) &#123;</span><br>        <span class="hljs-comment">// ✅ 构造函数不调用虚函数</span><br>        <span class="hljs-built_in">establishConnection</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Connection</span>() &#123;<br>        <span class="hljs-comment">// ✅ 析构函数使用非虚函数清理</span><br>        <span class="hljs-keyword">if</span> (connected_) &#123;<br>            <span class="hljs-built_in">closeConnection</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 非虚函数，供构造函数安全调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">establishConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 建立连接的通用逻辑</span><br>        connected_ = <span class="hljs-literal">true</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connection established to &quot;</span> &lt;&lt; endpoint_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 关闭连接的通用逻辑</span><br>        connected_ = <span class="hljs-literal">false</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connection closed\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 虚函数供外部调用，不在构造/析构中使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sendData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">receiveData</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> connected_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPConnection</span> : <span class="hljs-keyword">public</span> Connection &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TCPConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; endpoint)</span> </span><br><span class="hljs-function">        : Connection(endpoint) &#123;</span><br>        <span class="hljs-comment">// 基类已经安全地建立了连接</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TCP connection ready\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isConnected</span>()) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Sending TCP data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">receiveData</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isConnected</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TCP data received&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>工厂模式避免构造期间的虚函数调用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string title_;<br>    <br>    <span class="hljs-comment">// 保护构造函数，防止直接构造</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Document</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; title)</span> : title_(title) &#123;</span>&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Document</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// ✅ 工厂方法，确保对象完全构造后再调用虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">static</span> std::unique_ptr&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; title)</span> </span>&#123;<br>        <span class="hljs-built_in">static_assert</span>(std::is_base_of_v&lt;Document, T&gt;, <span class="hljs-string">&quot;T must derive from Document&quot;</span>);<br>        <br>        <span class="hljs-keyword">auto</span> doc = std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(title));<br>        doc-&gt;<span class="hljs-built_in">afterConstruction</span>();  <span class="hljs-comment">// 对象完全构造后调用</span><br>        <span class="hljs-keyword">return</span> doc;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 虚函数，在对象完全构造后调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">afterConstruction</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Document &#x27;&quot;</span> &lt;&lt; title_ &lt;&lt; <span class="hljs-string">&quot;&#x27; ready\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextDocument</span> : <span class="hljs-keyword">public</span> Document &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string content_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TextDocument</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; title)</span> </span><br><span class="hljs-function">        : Document(title), content_(<span class="hljs-string">&quot;&quot;</span>) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Saving text document: &quot;</span> &lt;&lt; title_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Printing: &quot;</span> &lt;&lt; title_ &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; content_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content)</span> </span>&#123;<br>        content_ = content;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">afterConstruction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        Document::<span class="hljs-built_in">afterConstruction</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TextDocument specific initialization\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span>;  <span class="hljs-comment">// 允许工厂方法访问private构造函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateFactoryPattern</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> doc = Document::<span class="hljs-built_in">create</span>&lt;TextDocument&gt;(<span class="hljs-string">&quot;My Document&quot;</span>);<br>    <span class="hljs-comment">// 输出：</span><br>    <span class="hljs-comment">// Document &#x27;My Document&#x27; ready</span><br>    <span class="hljs-comment">// TextDocument specific initialization</span><br>    <br>    doc-&gt;<span class="hljs-built_in">save</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><strong>构造&#x2F;析构期间虚函数调用的问题：</strong></p>
<ol>
<li><strong>虚函数不会表现出多态行为</strong></li>
<li><strong>只调用当前构造&#x2F;析构类的版本</strong></li>
<li><strong>可能访问未初始化或已销毁的成员</strong></li>
</ol>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>避免在构造&#x2F;析构函数中调用虚函数</strong></li>
<li><strong>使用非虚函数处理构造&#x2F;析构逻辑</strong></li>
<li><strong>传递参数给基类构造函数</strong></li>
<li><strong>使用两阶段构造模式</strong></li>
<li><strong>采用工厂模式确保完全构造后再调用虚函数</strong></li>
</ul>
<p><strong>最佳实践：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodDesign</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 构造函数不调用虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GoodDesign</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> : name_(name) &#123;</span>&#125;<br>    <br>    <span class="hljs-comment">// ✅ 析构函数不调用虚函数  </span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">GoodDesign</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// ✅ 虚函数供正常使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// ✅ 非虚函数供内部使用</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>记住：在构造和析构期间，千万不要调用virtual函数，因为这类调用从来不会下降至derived class（比起当前执行构造函数和析构函数的那层）。</strong></p>
<h2 id="条款10：-令-operator-返回一个reference-to-this"><a href="#条款10：-令-operator-返回一个reference-to-this" class="headerlink" title="条款10： 令 operator&#x3D; 返回一个reference to *this"></a>条款10： 令 operator&#x3D; 返回一个reference to *this</h2><blockquote>
<p>*Have assignment operators return a reference to <em>this</em></p>
</blockquote>
<h3 id="核心理念-9"><a href="#核心理念-9" class="headerlink" title="核心理念"></a>核心理念</h3><p>赋值运算符应该返回对当前对象的引用（<code>*this</code>），这样可以支持<strong>连续赋值</strong>（如<code>a = b = c</code>）并保持与内置类型赋值运算符的一致性。这个约定不仅适用于标准的赋值运算符（<code>operator=</code>），也适用于所有赋值相关的运算符（如<code>+=</code>、<code>-=</code>、<code>*=</code>等）。遵循这个约定是良好的C++编程实践。</p>
<h3 id="深度解析-9"><a href="#深度解析-9" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-内置类型的赋值行为"><a href="#1-内置类型的赋值行为" class="headerlink" title="1. 内置类型的赋值行为"></a>1. <strong>内置类型的赋值行为</strong></h4><p><strong>连续赋值的工作原理：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateBuiltinAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>    <br>    <span class="hljs-comment">// 连续赋值从右向左结合</span><br>    x = y = z = <span class="hljs-number">15</span>;<br>    <br>    <span class="hljs-comment">// 等价于：</span><br>    <span class="hljs-comment">// x = (y = (z = 15));</span><br>    <br>    <span class="hljs-comment">// 分解步骤：</span><br>    <span class="hljs-comment">// 1. z = 15  返回 z 的引用，z 现在是 15</span><br>    <span class="hljs-comment">// 2. y = z   返回 y 的引用，y 现在是 15  </span><br>    <span class="hljs-comment">// 3. x = y   返回 x 的引用，x 现在是 15</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;, z=&quot;</span> &lt;&lt; z &lt;&lt; std::endl;  <span class="hljs-comment">// 都是15</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateAssignmentReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> c;<br>    <br>    <span class="hljs-comment">// 赋值运算符返回左操作数的引用</span><br>    (c = a) = b;    <span class="hljs-comment">// c 先被赋值为 a 的值（10），然后被赋值为 b 的值（20）</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：c = 20</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-自定义类的赋值运算符实现"><a href="#2-自定义类的赋值运算符实现" class="headerlink" title="2. 自定义类的赋值运算符实现"></a>2. <strong>自定义类的赋值运算符实现</strong></h4><p><strong>基本的正确实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> std::string&amp; name = <span class="hljs-string">&quot;&quot;</span>) <br>        : <span class="hljs-built_in">value_</span>(value), <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br><br>    <span class="hljs-comment">// ✅ 正确：返回 reference to *this</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;  <span class="hljs-comment">// 自赋值检查</span><br>            value_ = rhs.value_;<br>            name_ = rhs.name_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示内容的辅助函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Widget(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="hljs-string">&quot;, \&quot;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;\&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateCustomAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;first&quot;</span>)</span></span>;<br>    <span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;second&quot;</span>)</span></span>;  <br>    <span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-string">&quot;third&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 连续赋值现在可以正常工作</span><br>    w1 = w2 = w3;<br>    <br>    w<span class="hljs-number">1.</span><span class="hljs-built_in">show</span>();  <span class="hljs-comment">// Widget(30, &quot;third&quot;)</span><br>    w<span class="hljs-number">2.</span><span class="hljs-built_in">show</span>();  <span class="hljs-comment">// Widget(30, &quot;third&quot;)</span><br>    w<span class="hljs-number">3.</span><span class="hljs-built_in">show</span>();  <span class="hljs-comment">// Widget(30, &quot;third&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>错误的实现示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadWidget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BadWidget</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>) : <span class="hljs-built_in">value_</span>(value) &#123;&#125;<br><br>    <span class="hljs-comment">// ❌ 错误：返回 void</span><br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BadWidget&amp; rhs) &#123;<br>        value_ = rhs.value_;<br>        <span class="hljs-comment">// 不返回任何值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误：返回副本</span><br>    BadWidget <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BadWidget&amp; rhs) &#123;<br>        value_ = rhs.value_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回副本，不是引用</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateBadAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">BadWidget <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">BadWidget <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">BadWidget <span class="hljs-title">b3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 这些都不能编译或不能按预期工作：</span><br>    <span class="hljs-comment">// b1 = b2 = b3;  // 编译错误：void operator= 不支持连续赋值</span><br>    <span class="hljs-comment">// (b1 = b2).getValue();  // 如果是副本返回，性能差且语义不对</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-所有赋值相关运算符的一致性"><a href="#3-所有赋值相关运算符的一致性" class="headerlink" title="3. 所有赋值相关运算符的一致性"></a>3. <strong>所有赋值相关运算符的一致性</strong></h4><p><strong>复合赋值运算符：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-type">double</span> value = <span class="hljs-number">0.0</span>)</span> : value_(value) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// ✅ 标准赋值运算符</span><br>    Number&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            value_ = rhs.value_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 复合赋值运算符都应返回 reference to *this</span><br>    Number&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        value_ += rhs.value_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Number&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        value_ -= rhs.value_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Number&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        value_ *= rhs.value_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    Number&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (rhs.value_ != <span class="hljs-number">0.0</span>) &#123;<br>            value_ /= rhs.value_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 位运算赋值运算符（如果适用）</span><br>    Number&amp; <span class="hljs-keyword">operator</span>&amp;=(<span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        <span class="hljs-comment">// 假设有意义的位运算定义</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>    <br>    <span class="hljs-comment">// 非成员函数的算术运算符</span><br>    <span class="hljs-keyword">friend</span> Number <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Number&amp; lhs, <span class="hljs-type">const</span> Number&amp; rhs) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(lhs.value_ + rhs.value_);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateCompoundAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Number <span class="hljs-title">n1</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br>    <span class="hljs-function">Number <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-number">5.0</span>)</span></span>;<br>    <span class="hljs-function">Number <span class="hljs-title">n3</span><span class="hljs-params">(<span class="hljs-number">2.0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 连续复合赋值</span><br>    (n1 += n2) *= n3;  <span class="hljs-comment">// n1 = (n1 + n2) * n3 = (10 + 5) * 2 = 30</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;n1 = &quot;</span> &lt;&lt; n<span class="hljs-number">1.</span><span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 30.0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-移动赋值运算符（C-11）"><a href="#4-移动赋值运算符（C-11）" class="headerlink" title="4. 移动赋值运算符（C++11）"></a>4. <strong>移动赋值运算符（C++11）</strong></h4><p><strong>现代C++的移动赋值：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernWidget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; data_;<br>    <span class="hljs-type">size_t</span> size_;<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernWidget</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::string&amp; name)<br>        : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size)), <span class="hljs-built_in">size_</span>(size), <span class="hljs-built_in">name_</span>(name) &#123;<br>        <br>        <span class="hljs-comment">// 初始化数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size_; ++i) &#123;<br>            data_[i] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ModernWidget</span>(<span class="hljs-type">const</span> ModernWidget&amp; other) <br>        : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(other.size_)), <br>          <span class="hljs-built_in">size_</span>(other.size_), <br>          <span class="hljs-built_in">name_</span>(other.name_) &#123;<br>        <br>        std::<span class="hljs-built_in">copy</span>(other.data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>() + size_, data_.<span class="hljs-built_in">get</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 拷贝赋值运算符</span><br>    ModernWidget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ModernWidget&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-comment">// 创建新的资源</span><br>            <span class="hljs-keyword">auto</span> new_data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(rhs.size_);<br>            std::<span class="hljs-built_in">copy</span>(rhs.data_.<span class="hljs-built_in">get</span>(), rhs.data_.<span class="hljs-built_in">get</span>() + rhs.size_, new_data.<span class="hljs-built_in">get</span>());<br>            <br>            <span class="hljs-comment">// 更新状态</span><br>            data_ = std::<span class="hljs-built_in">move</span>(new_data);<br>            size_ = rhs.size_;<br>            name_ = rhs.name_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回 reference to *this</span><br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 移动赋值运算符（C++11）</span><br>    ModernWidget&amp; <span class="hljs-keyword">operator</span>=(ModernWidget&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-comment">// 移动资源，不需要拷贝</span><br>            data_ = std::<span class="hljs-built_in">move</span>(rhs.data_);<br>            size_ = rhs.size_;<br>            name_ = std::<span class="hljs-built_in">move</span>(rhs.name_);<br>            <br>            <span class="hljs-comment">// 清理源对象</span><br>            rhs.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回 reference to *this</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateModernAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ModernWidget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;widget1&quot;</span>)</span></span>;<br>    <span class="hljs-function">ModernWidget <span class="hljs-title">w2</span><span class="hljs-params">(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;widget2&quot;</span>)</span></span>;<br>    <span class="hljs-function">ModernWidget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">300</span>, <span class="hljs-string">&quot;widget3&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 拷贝赋值的连续操作</span><br>    w1 = w2 = w3;  <span class="hljs-comment">// 都支持连续赋值</span><br><br>    <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-function">ModernWidget <span class="hljs-title">w4</span><span class="hljs-params">(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;widget4&quot;</span>)</span></span>;<br>    w1 = std::<span class="hljs-built_in">move</span>(w4);  <span class="hljs-comment">// 移动赋值，也支持连续操作</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;w1.name() = &quot;</span> &lt;&lt; w<span class="hljs-number">1.</span><span class="hljs-built_in">name</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// widget4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-特殊情况和考虑"><a href="#5-特殊情况和考虑" class="headerlink" title="5. 特殊情况和考虑"></a>5. <strong>特殊情况和考虑</strong></h4><p><strong>自赋值安全：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeAssignment</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string* data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeAssignment</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span><br><span class="hljs-function">        : data_(new std::string(str)) &#123;</span>&#125;<br><br>    ~<span class="hljs-built_in">SafeAssignment</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data_;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 自赋值安全的实现</span><br>    SafeAssignment&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SafeAssignment&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;  <span class="hljs-comment">// 自赋值检查</span><br>            <span class="hljs-keyword">delete</span> data_;<br>            data_ = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*rhs.data_);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 更安全的实现：copy-and-swap</span><br>    SafeAssignment&amp; <span class="hljs-keyword">operator</span>=(SafeAssignment rhs) &#123;  <span class="hljs-comment">// 按值传递，触发拷贝</span><br>        <span class="hljs-built_in">swap</span>(rhs);  <span class="hljs-comment">// 交换资源</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// rhs析构时释放旧资源</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(SafeAssignment&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(data_, other.data_);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>异常安全：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionSafeAssignment</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ExceptionSafeAssignment</span>(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">const</span> std::string&amp; name)<br>        : <span class="hljs-built_in">data_</span>(data), <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br><br>    <span class="hljs-comment">// ✅ 强异常安全保证</span><br>    ExceptionSafeAssignment&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ExceptionSafeAssignment&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-comment">// 先创建临时副本（可能抛异常）</span><br>            std::vector&lt;<span class="hljs-type">int</span>&gt; temp_data = rhs.data_;<br>            std::string temp_name = rhs.name_;<br>            <br>            <span class="hljs-comment">// 只有在没有异常的情况下才修改状态</span><br>            data_ = std::<span class="hljs-built_in">move</span>(temp_data);<br>            name_ = std::<span class="hljs-built_in">move</span>(temp_name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 使用copy-and-swap提供强异常安全</span><br>    ExceptionSafeAssignment&amp; <span class="hljs-keyword">operator</span>=(ExceptionSafeAssignment rhs) &#123;<br>        <span class="hljs-built_in">swap</span>(rhs);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(ExceptionSafeAssignment&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        data_.<span class="hljs-built_in">swap</span>(other.data_);<br>        name_.<span class="hljs-built_in">swap</span>(other.name_);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-与标准库的一致性"><a href="#6-与标准库的一致性" class="headerlink" title="6. 与标准库的一致性"></a>6. <strong>与标准库的一致性</strong></h4><p><strong>标准库容器的行为：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStandardLibraryConsistency</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v3 = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-comment">// 标准库容器支持连续赋值</span><br>    v1 = v2 = v3;<br>    <br>    <span class="hljs-comment">// 复合赋值也返回引用</span><br>    std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::string s2 = <span class="hljs-string">&quot; World&quot;</span>;<br>    std::string s3 = <span class="hljs-string">&quot;!&quot;</span>;<br>    <br>    (s1 += s2) += s3;  <span class="hljs-comment">// 连续复合赋值</span><br>    std::cout &lt;&lt; s1 &lt;&lt; std::endl;  <span class="hljs-comment">// &quot;Hello World!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>与算术类型的一致性：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;<br>        <span class="hljs-keyword">if</span> (denominator_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Denominator cannot be zero&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 赋值运算符返回引用，与内置类型一致</span><br>    Rational&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            numerator_ = rhs.numerator_;<br>            denominator_ = rhs.denominator_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 复合赋值运算符</span><br>    Rational&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        numerator_ = numerator_ * rhs.denominator_ + rhs.numerator_ * denominator_;<br>        denominator_ *= rhs.denominator_;<br>        <span class="hljs-built_in">reduce</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 显示分数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; numerator_ &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; denominator_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> gcd_val = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(numerator_), <span class="hljs-built_in">abs</span>(denominator_));<br>        numerator_ /= gcd_val;<br>        denominator_ /= gcd_val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateRationalAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;   <span class="hljs-comment">// 1/2</span><br>    <span class="hljs-function">Rational <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;   <span class="hljs-comment">// 1/3</span><br>    <span class="hljs-function">Rational <span class="hljs-title">r3</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;   <span class="hljs-comment">// 1/4</span><br><br>    <span class="hljs-comment">// 连续赋值</span><br>    r1 = r2 = r3;<br>    r<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 1/4</span><br><br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 连续复合赋值</span><br>    <span class="hljs-function">Rational <span class="hljs-title">r4</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">r5</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>    (r4 += r5) += r3;  <span class="hljs-comment">// (1/2 + 1/4) + 1/4 = 1</span><br>    r<span class="hljs-number">4.</span><span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 1/1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-最佳实践和常见模式"><a href="#7-最佳实践和常见模式" class="headerlink" title="7. 最佳实践和常见模式"></a>7. <strong>最佳实践和常见模式</strong></h4><p><strong>推荐的赋值运算符模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AssignmentTemplate</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AssignmentTemplate</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; data)</span> : data_(data) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// ✅ 标准模板：拷贝赋值</span><br>    AssignmentTemplate&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AssignmentTemplate&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            data_ = rhs.data_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 标准模板：移动赋值（C++11）</span><br>    AssignmentTemplate&amp; <span class="hljs-keyword">operator</span>=(AssignmentTemplate&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            data_ = std::<span class="hljs-built_in">move</span>(rhs.data_);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 复合赋值运算符模板</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br>    AssignmentTemplate&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> U&amp; value) &#123;<br>        data_ += value;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>*<em>返回reference to <em>this的核心价值：</em></em></p>
<ol>
<li><strong>支持连续赋值</strong>：<code>a = b = c</code> 语法</li>
<li><strong>与内置类型一致</strong>：行为符合直觉</li>
<li><strong>支持复合操作</strong>：<code>(a += b) *= c</code> 等</li>
<li><strong>标准库兼容</strong>：与STL容器行为一致</li>
</ol>
<p><strong>实现要点：</strong></p>
<ul>
<li><strong>返回类型</strong>：<code>ClassName&amp;</code>，不是<code>void</code>或<code>ClassName</code></li>
<li><strong>返回值</strong>：<code>return *this;</code></li>
<li><strong>自赋值安全</strong>：检查<code>this != &amp;rhs</code></li>
<li><strong>异常安全</strong>：考虑强异常安全保证</li>
</ul>
<p><strong>适用范围：</strong></p>
<ul>
<li><code>operator=</code>（拷贝和移动）</li>
<li><code>operator+=</code>、<code>operator-=</code>、<code>operator*=</code> 等复合赋值</li>
<li><code>operator&amp;=</code>、<code>operator|=</code>、<code>operator^=</code> 等位运算赋值</li>
<li><code>operator&lt;&lt;=</code>、<code>operator&gt;&gt;=</code> 等移位赋值</li>
</ul>
<p><strong>现代C++最佳实践：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 拷贝赋值</span><br>    ModernClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ModernClass&amp; rhs) &#123;<br>        <span class="hljs-comment">// 实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值</span><br>    ModernClass&amp; <span class="hljs-keyword">operator</span>=(ModernClass&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 复合赋值</span><br>    ModernClass&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> ModernClass&amp; rhs) &#123;<br>        <span class="hljs-comment">// 实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>*<em>记住：令赋值（assignment）操作符返回一个reference to <em>this。</em></em></p>
<h2 id="条款11：-在operator-中处理”自我赋值”"><a href="#条款11：-在operator-中处理”自我赋值”" class="headerlink" title="条款11： 在operator&#x3D;中处理”自我赋值”"></a>条款11： 在operator&#x3D;中处理”自我赋值”</h2><blockquote>
<p><em>Handle assignment to self in operator&#x3D;</em></p>
</blockquote>
<h3 id="核心理念-10"><a href="#核心理念-10" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>确保当对象自我赋值时operator&#x3D;有良好行为</strong>。自我赋值看似不常见，但在实际编程中可能通过别名、引用、指针间接发生。如果operator&#x3D;没有正确处理自我赋值，可能导致资源重复释放、数据损坏或程序崩溃。处理自我赋值的技术包括：身份测试、精心安排语句顺序，以及copy-and-swap技术。</p>
<h3 id="深度解析-10"><a href="#深度解析-10" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-自我赋值的现实场景"><a href="#1-自我赋值的现实场景" class="headerlink" title="1. 自我赋值的现实场景"></a>1. <strong>自我赋值的现实场景</strong></h4><p>自我赋值不仅仅是<code>a = a</code>这样显而易见的情况，更多时候是通过间接方式发生的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Bitmap* pb_;  <span class="hljs-comment">// 指向一个在heap上分配的对象</span><br><br><span class="hljs-keyword">public</span>:<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs);<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// ❌ 看似不可能的自我赋值实际上很常见</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateAliasing</span><span class="hljs-params">()</span> </span>&#123;<br>    Widget w;<br>    <br>    <span class="hljs-comment">// 直接自我赋值（显而易见）</span><br>    w = w;  <span class="hljs-comment">// 看起来愚蠢，但确实可能发生</span><br>    <br>    <span class="hljs-comment">// 通过指针或引用的间接自我赋值（隐蔽）</span><br>    Widget* pw1 = &amp;w;<br>    Widget* pw2 = &amp;w;<br>    *pw1 = *pw2;  <span class="hljs-comment">// 实际上是自我赋值！</span><br>    <br>    <span class="hljs-comment">// 数组中的自我赋值</span><br>    Widget widgets[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>, j = <span class="hljs-number">5</span>;<br>    widgets[i] = widgets[j];  <span class="hljs-comment">// 如果i == j，就是自我赋值</span><br>    <br>    <span class="hljs-comment">// 函数参数中的自我赋值</span><br>    <span class="hljs-function">Widget&amp; <span class="hljs-title">getWidget</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>    widgets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">getWidget</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果getWidget(0)返回widgets[0]的引用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-危险的operator-实现"><a href="#2-危险的operator-实现" class="headerlink" title="2. 危险的operator&#x3D;实现"></a>2. <strong>危险的operator&#x3D;实现</strong></h4><p>没有考虑自我赋值的operator&#x3D;实现可能导致严重问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 危险的实现：没有处理自我赋值</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>    <span class="hljs-keyword">delete</span> pb_;                    <span class="hljs-comment">// 销毁当前对象的资源</span><br>    pb_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb_);    <span class="hljs-comment">// 从rhs复制资源</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    Widget w;<br>    <span class="hljs-comment">// ... 初始化w ...</span><br>    <br>    w = w;  <span class="hljs-comment">// 灾难！</span><br>    <br>    <span class="hljs-comment">// 执行过程：</span><br>    <span class="hljs-comment">// 1. delete pb_;           - 销毁了w.pb_指向的对象</span><br>    <span class="hljs-comment">// 2. pb_ = new Bitmap(*rhs.pb_);  - 但rhs就是*this！</span><br>    <span class="hljs-comment">//    rhs.pb_现在指向一个已删除的对象！</span><br>    <span class="hljs-comment">//    导致未定义行为，通常是程序崩溃</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-解决方案1：身份测试"><a href="#3-解决方案1：身份测试" class="headerlink" title="3. 解决方案1：身份测试"></a>3. <strong>解决方案1：身份测试</strong></h4><p>最直接的解决方案是检查是否为自我赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 解决方案1：身份测试</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) &#123;        <span class="hljs-comment">// 身份测试：检查自我赋值</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;          <span class="hljs-comment">// 如果是自我赋值，直接返回</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">delete</span> pb_;                <span class="hljs-comment">// 安全：确定不是自我赋值后才删除</span><br>    pb_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 优化版本：处理异常安全性</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 身份测试</span><br>    <br>    Bitmap* pOrig = pb_;             <span class="hljs-comment">// 记住原先的pb_</span><br>    pb_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb_);      <span class="hljs-comment">// 先创建新对象</span><br>    <span class="hljs-keyword">delete</span> pOrig;                    <span class="hljs-comment">// 删除原先的对象</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-解决方案2：异常安全的语句顺序"><a href="#4-解决方案2：异常安全的语句顺序" class="headerlink" title="4. 解决方案2：异常安全的语句顺序"></a>4. <strong>解决方案2：异常安全的语句顺序</strong></h4><p>通过重新安排语句顺序，既保证异常安全又自动处理自我赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 解决方案2：异常安全的语句顺序</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>    Bitmap* pOrig = pb_;             <span class="hljs-comment">// 记住原先的pb_</span><br>    pb_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb_);      <span class="hljs-comment">// 先复制rhs的资源</span><br>    <span class="hljs-keyword">delete</span> pOrig;                    <span class="hljs-comment">// 删除原先的资源</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateExceptionSafety</span><span class="hljs-params">()</span> </span>&#123;<br>    Widget w1, w2;<br>    <span class="hljs-comment">// ... 初始化 ...</span><br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        w1 = w2;  <span class="hljs-comment">// 如果new Bitmap抛出异常</span><br>                  <span class="hljs-comment">// w1.pb_仍然指向原始有效对象</span><br>                  <span class="hljs-comment">// 没有资源泄漏或数据损坏</span><br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// w1仍然处于有效状态</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自我赋值也能正确工作：</span><br>    w1 = w1;  <span class="hljs-comment">// 虽然效率不高（会创建不必要的副本），但是安全的</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-解决方案3：copy-and-swap技术"><a href="#5-解决方案3：copy-and-swap技术" class="headerlink" title="5. 解决方案3：copy-and-swap技术"></a>5. <strong>解决方案3：copy-and-swap技术</strong></h4><p>最优雅和通用的解决方案是copy-and-swap惯用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Bitmap* pb_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ copy-and-swap技术</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) &#123;<br>        Widget <span class="hljs-built_in">temp</span>(rhs);        <span class="hljs-comment">// 复制rhs（调用拷贝构造函数）</span><br>        <span class="hljs-built_in">swap</span>(temp);              <span class="hljs-comment">// 交换*this和temp的内容</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;            <span class="hljs-comment">// temp离开作用域时自动清理旧资源</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 或者更简洁的版本（pass-by-value）</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget rhs) &#123;  <span class="hljs-comment">// 注意：按值传递（自动创建副本）</span><br>        <span class="hljs-built_in">swap</span>(rhs);                   <span class="hljs-comment">// 交换内容</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// rhs离开作用域时清理旧资源</span><br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(pb_, other.pb_);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 需要实现拷贝构造函数</span><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; rhs) : <span class="hljs-built_in">pb_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb_)) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Widget</span>() &#123; <span class="hljs-keyword">delete</span> pb_; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-现代C-的改进实现"><a href="#6-现代C-的改进实现" class="headerlink" title="6. 现代C++的改进实现"></a>6. <strong>现代C++的改进实现</strong></h4><p>使用智能指针和现代C++特性可以大大简化实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernWidget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;Bitmap&gt; pb_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ModernWidget</span>() : <span class="hljs-built_in">pb_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Bitmap&gt;()) &#123;&#125;  <span class="hljs-comment">// C++14</span><br>    <br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ModernWidget</span>(<span class="hljs-type">const</span> ModernWidget&amp; other) <br>        : <span class="hljs-built_in">pb_</span>(other.pb_ ? std::<span class="hljs-built_in">make_unique</span>&lt;Bitmap&gt;(*other.pb_) : <span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ModernWidget</span>(ModernWidget&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">pb_</span>(std::<span class="hljs-built_in">move</span>(other.pb_)) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 现代赋值运算符：使用copy-and-swap</span><br>    ModernWidget&amp; <span class="hljs-keyword">operator</span>=(ModernWidget other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-built_in">swap</span>(other);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 交换函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(ModernWidget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(pb_, other.pb_);<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 智能指针自动处理资源管理，无需显式析构函数</span><br>&#125;;<br><br><span class="hljs-comment">// 非成员swap函数（可选，但推荐）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(ModernWidget&amp; a, ModernWidget&amp; b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateModernSafety</span><span class="hljs-params">()</span> </span>&#123;<br>    ModernWidget w1, w2;<br>    <br>    <span class="hljs-comment">// 所有这些操作都是安全的</span><br>    w1 = w2;                    <span class="hljs-comment">// 拷贝赋值</span><br>    w1 = w1;                    <span class="hljs-comment">// 自我赋值，完全安全</span><br>    w1 = std::<span class="hljs-built_in">move</span>(w2);         <span class="hljs-comment">// 移动赋值</span><br>    w1 = ModernWidget&#123;&#125;;        <span class="hljs-comment">// 临时对象赋值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-多资源管理的复杂情况"><a href="#7-多资源管理的复杂情况" class="headerlink" title="7. 多资源管理的复杂情况"></a>7. <strong>多资源管理的复杂情况</strong></h4><p>当类管理多个资源时，需要特别小心异常安全性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexWidget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string* pName_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;* pData_;<br>    std::unique_ptr&lt;Bitmap&gt; pBitmap_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 危险的实现：部分修改后可能抛出异常</span><br>    ComplexWidget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ComplexWidget&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        <span class="hljs-keyword">delete</span> pName_;<br>        <span class="hljs-keyword">delete</span> pData_;<br>        <span class="hljs-comment">// 如果下面的操作抛出异常，对象处于部分修改状态</span><br>        pName_ = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*rhs.pName_);<br>        pData_ = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(*rhs.pData_);<br>        pBitmap_ = std::<span class="hljs-built_in">make_unique</span>&lt;Bitmap&gt;(*rhs.pBitmap_);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 安全的实现：要么完全成功，要么保持原状</span><br>    ComplexWidget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ComplexWidget&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        <span class="hljs-comment">// 先创建所有新资源</span><br>        <span class="hljs-function">std::unique_ptr&lt;std::string&gt; <span class="hljs-title">newName</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string(*rhs.pName_))</span></span>;<br>        std::unique_ptr&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">newData</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(*rhs.pData_));<br>        <span class="hljs-function">std::unique_ptr&lt;Bitmap&gt; <span class="hljs-title">newBitmap</span><span class="hljs-params">(std::make_unique&lt;Bitmap&gt;(*rhs.pBitmap_))</span></span>;<br>        <br>        <span class="hljs-comment">// 如果到这里没有异常，安全地替换资源</span><br>        <span class="hljs-keyword">delete</span> pName_;<br>        <span class="hljs-keyword">delete</span> pData_;<br>        pName_ = newName.<span class="hljs-built_in">release</span>();<br>        pData_ = newData.<span class="hljs-built_in">release</span>();<br>        pBitmap_ = std::<span class="hljs-built_in">move</span>(newBitmap);<br>        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 更好的现代实现：全部使用智能指针</span><br>    <span class="hljs-comment">// std::unique_ptr&lt;std::string&gt; pName_;</span><br>    <span class="hljs-comment">// std::unique_ptr&lt;std::vector&lt;int&gt;&gt; pData_;</span><br>    <span class="hljs-comment">// std::unique_ptr&lt;Bitmap&gt; pBitmap_;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="8-性能考虑和最佳实践"><a href="#8-性能考虑和最佳实践" class="headerlink" title="8. 性能考虑和最佳实践"></a>8. <strong>性能考虑和最佳实践</strong></h4><p>不同的实现方式有不同的性能特征。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceWidget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;  <span class="hljs-comment">// 大容量数据</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 针对性能优化的实现</span><br>    PerformanceWidget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PerformanceWidget&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 避免自我赋值的开销</span><br>        <br>        <span class="hljs-comment">// 直接赋值，复用现有容量</span><br>        data_ = rhs.data_;  <span class="hljs-comment">// vector的operator=已经是异常安全的</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 支持移动语义的现代实现</span><br>    PerformanceWidget&amp; <span class="hljs-keyword">operator</span>=(PerformanceWidget rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>        data_.<span class="hljs-built_in">swap</span>(rhs.data_);  <span class="hljs-comment">// 高效的交换操作</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 性能测试示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performanceComparison</span><span class="hljs-params">()</span> </span>&#123;<br>    PerformanceWidget w1, w2;<br>    <span class="hljs-comment">// 假设w1和w2包含大量数据</span><br>    <br>    <span class="hljs-comment">// 测量自我赋值的开销</span><br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i) &#123;<br>        w1 = w1;  <span class="hljs-comment">// 有身份测试的版本会立即返回</span><br>    &#125;<br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Self-assignment time: &quot;</span> <br>              &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start).<span class="hljs-built_in">count</span>() <br>              &lt;&lt; <span class="hljs-string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><strong>自我赋值处理的三种主要策略：</strong></p>
<ol>
<li><strong>身份测试</strong>：简单直接，但只优化了自我赋值的情况</li>
<li><strong>精心安排语句顺序</strong>：提供异常安全性，自动处理自我赋值</li>
<li><strong>copy-and-swap</strong>：最优雅，同时提供异常安全性和自我赋值处理</li>
</ol>
<p><strong>现代C++最佳实践：</strong></p>
<ul>
<li><strong>使用智能指针</strong>：自动管理资源，减少手动内存管理的复杂性</li>
<li><strong>使用copy-and-swap惯用法</strong>：简洁、安全、易于理解</li>
<li><strong>支持移动语义</strong>：提高性能，特别是对于大对象</li>
</ul>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>异常安全性优先</strong>：确保即使发生异常，对象也保持有效状态</li>
<li><strong>简洁性</strong>：优先选择简单、易理解的实现</li>
<li><strong>性能考虑</strong>：在保证正确性的前提下优化性能</li>
</ul>
<p><strong>记住：确保当对象自我赋值时operator&#x3D;有良好行为。技术包括比较”来源对象”和”目标对象”的地址、精心周到的语句顺序，以及copy-and-swap。确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</strong></p>
<h2 id="条款12：-复制对象时勿忘其每一个成分"><a href="#条款12：-复制对象时勿忘其每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其每一个成分"></a>条款12： 复制对象时勿忘其每一个成分</h2><blockquote>
<p><em>Copy all parts of an object</em></p>
</blockquote>
<h3 id="核心理念-11"><a href="#核心理念-11" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>Copying函数应确保复制”对象内的所有成员变量”以及”所有base class成分”</strong>。当你编写拷贝构造函数和赋值运算符时，必须确保复制对象的每一个成分，包括所有成员变量和基类部分。同时，不要尝试以某个copying函数实现另一个copying函数，应该将共同功能放进第三个函数中，并由两个copying函数共同调用。</p>
<h3 id="深度解析-11"><a href="#深度解析-11" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-常见错误：遗漏新增的成员变量"><a href="#1-常见错误：遗漏新增的成员变量" class="headerlink" title="1. 常见错误：遗漏新增的成员变量"></a>1. <strong>常见错误：遗漏新增的成员变量</strong></h4><p>最常见的错误是在添加新成员变量时忘记更新拷贝函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>    Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>&#125;;<br><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>    : <span class="hljs-built_in">name_</span>(rhs.name_) &#123;  <span class="hljs-comment">// 复制所有成员变量</span><br>&#125;<br><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs) &#123;<br>    name_ = rhs.name_;   <span class="hljs-comment">// 复制所有成员变量</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// ❌ 后来添加了新成员变量，但忘记更新拷贝函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>    Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    Date lastTransaction_;  <span class="hljs-comment">// 新增成员变量！</span><br>&#125;;<br><br><span class="hljs-comment">// 拷贝构造函数遗漏了新成员变量</span><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>    : <span class="hljs-built_in">name_</span>(rhs.name_) &#123;  <span class="hljs-comment">// ❌ 遗漏了lastTransaction_！</span><br>    <span class="hljs-comment">// lastTransaction_会被默认构造，而不是从rhs复制</span><br>&#125;<br><br><span class="hljs-comment">// 赋值运算符也遗漏了新成员变量</span><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs) &#123;<br>    name_ = rhs.name_;   <span class="hljs-comment">// ❌ 遗漏了lastTransaction_！</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        <span class="hljs-comment">// lastTransaction_保持不变</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-正确的成员变量复制"><a href="#2-正确的成员变量复制" class="headerlink" title="2. 正确的成员变量复制"></a>2. <strong>正确的成员变量复制</strong></h4><p>确保所有成员变量都被正确复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> std::string&amp; name) <br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">lastTransaction_</span>(Date::<span class="hljs-built_in">today</span>()) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的拷贝构造函数：复制所有成员变量</span><br>    <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>        : <span class="hljs-built_in">name_</span>(rhs.name_), <br>          <span class="hljs-built_in">lastTransaction_</span>(rhs.lastTransaction_) &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的赋值运算符：复制所有成员变量</span><br>    Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 处理自我赋值</span><br>        <br>        name_ = rhs.name_;<br>        lastTransaction_ = rhs.lastTransaction_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    Date lastTransaction_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateCorrectCopying</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Customer <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alice&quot;</span>)</span></span>;<br>    <span class="hljs-function">Customer <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-function">Customer <span class="hljs-title">c3</span><span class="hljs-params">(c1)</span></span>;     <span class="hljs-comment">// 调用拷贝构造函数</span><br>    c2 = c1;             <span class="hljs-comment">// 调用赋值运算符</span><br>    <br>    <span class="hljs-comment">// 现在c3和c2都完整地复制了c1的所有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-继承中的复制问题"><a href="#3-继承中的复制问题" class="headerlink" title="3. 继承中的复制问题"></a>3. <strong>继承中的复制问题</strong></h4><p>在继承关系中，最容易忘记复制基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> year_, month_, day_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day) <br>        : <span class="hljs-built_in">year_</span>(year), <span class="hljs-built_in">month_</span>(month), <span class="hljs-built_in">day_</span>(day) &#123;&#125;<br>    <br>    <span class="hljs-comment">// Date类的拷贝函数（假设已正确实现）</span><br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Date&amp; rhs) <br>        : <span class="hljs-built_in">year_</span>(rhs.year_), <span class="hljs-built_in">month_</span>(rhs.month_), <span class="hljs-built_in">day_</span>(rhs.day_) &#123;&#125;<br>    <br>    Date&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Date&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        year_ = rhs.year_;<br>        month_ = rhs.month_;<br>        day_ = rhs.day_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span> : <span class="hljs-keyword">public</span> Customer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> priority)<br>        : <span class="hljs-built_in">Customer</span>(name), <span class="hljs-built_in">priority_</span>(priority) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误的拷贝构造函数：忘记调用基类拷贝构造函数</span><br>    <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>        : <span class="hljs-built_in">priority_</span>(rhs.priority_) &#123;  <span class="hljs-comment">// 只复制了派生类成员</span><br>        <span class="hljs-comment">// Customer基类部分会被默认构造！</span><br>        <span class="hljs-comment">// 基类的name_和lastTransaction_不会从rhs复制</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误的赋值运算符：忘记调用基类赋值运算符</span><br>    PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs) &#123;<br>        priority_ = rhs.priority_;  <span class="hljs-comment">// 只复制了派生类成员</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;               <span class="hljs-comment">// 基类部分保持不变！</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> priority_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateInheritanceProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc2</span><span class="hljs-params">(pc1)</span></span>;  <span class="hljs-comment">// 基类部分没有被正确复制！</span><br>    <br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc3</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<br>    pc3 = pc1;                  <span class="hljs-comment">// 基类部分没有被正确复制！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-正确的继承中的复制"><a href="#4-正确的继承中的复制" class="headerlink" title="4. 正确的继承中的复制"></a>4. <strong>正确的继承中的复制</strong></h4><p>在派生类的拷贝函数中必须调用基类的拷贝函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span> : <span class="hljs-keyword">public</span> Customer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> priority)<br>        : <span class="hljs-built_in">Customer</span>(name), <span class="hljs-built_in">priority_</span>(priority) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的拷贝构造函数：调用基类拷贝构造函数</span><br>    <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>        : <span class="hljs-built_in">Customer</span>(rhs),            <span class="hljs-comment">// 调用基类拷贝构造函数</span><br>          <span class="hljs-built_in">priority_</span>(rhs.priority_)  <span class="hljs-comment">// 复制派生类成员</span><br>    &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的赋值运算符：调用基类赋值运算符</span><br>    PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        Customer::<span class="hljs-keyword">operator</span>=(rhs);   <span class="hljs-comment">// 调用基类赋值运算符</span><br>        priority_ = rhs.priority_;  <span class="hljs-comment">// 复制派生类成员</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> priority_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateCorrectInheritanceCopying</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc2</span><span class="hljs-params">(pc1)</span></span>;  <span class="hljs-comment">// 现在完整复制了基类和派生类部分</span><br>    <br>    <span class="hljs-function">PriorityCustomer <span class="hljs-title">pc3</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<br>    pc3 = pc1;                  <span class="hljs-comment">// 现在完整复制了基类和派生类部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-多重继承中的复制"><a href="#5-多重继承中的复制" class="headerlink" title="5. 多重继承中的复制"></a>5. <strong>多重继承中的复制</strong></h4><p>多重继承使复制变得更加复杂，必须确保所有基类都被正确复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Named</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string name_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Named</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <br>    <span class="hljs-built_in">Named</span>(<span class="hljs-type">const</span> Named&amp; rhs) : <span class="hljs-built_in">name_</span>(rhs.name_) &#123;&#125;<br>    <br>    Named&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Named&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        name_ = rhs.name_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timestamped</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    Date timestamp_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Timestamped</span>() : <span class="hljs-built_in">timestamp_</span>(Date::<span class="hljs-built_in">today</span>()) &#123;&#125;<br>    <br>    <span class="hljs-built_in">Timestamped</span>(<span class="hljs-type">const</span> Timestamped&amp; rhs) : <span class="hljs-built_in">timestamp_</span>(rhs.timestamp_) &#123;&#125;<br>    <br>    Timestamped&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Timestamped&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        timestamp_ = rhs.timestamp_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedTimestamped</span> : <span class="hljs-keyword">public</span> Named, <span class="hljs-keyword">public</span> Timestamped &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NamedTimestamped</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">Named</span>(name), <span class="hljs-built_in">Timestamped</span>() &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的多重继承拷贝构造函数</span><br>    <span class="hljs-built_in">NamedTimestamped</span>(<span class="hljs-type">const</span> NamedTimestamped&amp; rhs)<br>        : <span class="hljs-built_in">Named</span>(rhs),           <span class="hljs-comment">// 复制第一个基类</span><br>          <span class="hljs-built_in">Timestamped</span>(rhs)      <span class="hljs-comment">// 复制第二个基类</span><br>    &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的多重继承赋值运算符</span><br>    NamedTimestamped&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NamedTimestamped&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        Named::<span class="hljs-keyword">operator</span>=(rhs);        <span class="hljs-comment">// 调用第一个基类的赋值运算符</span><br>        Timestamped::<span class="hljs-keyword">operator</span>=(rhs);  <span class="hljs-comment">// 调用第二个基类的赋值运算符</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-避免在拷贝函数间相互调用"><a href="#6-避免在拷贝函数间相互调用" class="headerlink" title="6. 避免在拷贝函数间相互调用"></a>6. <strong>避免在拷贝函数间相互调用</strong></h4><p>不要让拷贝构造函数和赋值运算符相互调用，而应该提取公共代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; buffer_;<br>    <span class="hljs-type">size_t</span> bufferSize_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">size_t</span> size)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">bufferSize_</span>(size), <br>          <span class="hljs-built_in">buffer_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size)) &#123;<br>        data_.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误：让拷贝构造函数调用赋值运算符</span><br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp; rhs) &#123;<br>        *<span class="hljs-keyword">this</span> = rhs;  <span class="hljs-comment">// 危险！这时对象还没有完全构造</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 错误：让赋值运算符调用拷贝构造函数</span><br>    Resource&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Resource&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        <span class="hljs-keyword">this</span>-&gt;~<span class="hljs-built_in">Resource</span>();           <span class="hljs-comment">// 销毁当前对象</span><br>        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>) <span class="hljs-built_in">Resource</span>(rhs);    <span class="hljs-comment">// 在原地重新构造</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// 危险且不可移植</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确方法：提取公共初始化代码</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> Resource&amp; rhs)</span> </span>&#123;<br>        name_ = rhs.name_;<br>        data_ = rhs.data_;<br>        bufferSize_ = rhs.bufferSize_;<br>        <br>        <span class="hljs-keyword">if</span> (rhs.buffer_) &#123;<br>            buffer_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(bufferSize_);<br>            std::<span class="hljs-built_in">copy</span>(rhs.buffer_.<span class="hljs-built_in">get</span>(), <br>                     rhs.buffer_.<span class="hljs-built_in">get</span>() + bufferSize_, <br>                     buffer_.<span class="hljs-built_in">get</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            buffer_.<span class="hljs-built_in">reset</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 正确的拷贝构造函数</span><br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp; rhs) <br>        : <span class="hljs-built_in">name_</span>(rhs.name_), <br>          <span class="hljs-built_in">data_</span>(rhs.data_), <br>          <span class="hljs-built_in">bufferSize_</span>(rhs.bufferSize_) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (rhs.buffer_) &#123;<br>            buffer_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(bufferSize_);<br>            std::<span class="hljs-built_in">copy</span>(rhs.buffer_.<span class="hljs-built_in">get</span>(), <br>                     rhs.buffer_.<span class="hljs-built_in">get</span>() + bufferSize_, <br>                     buffer_.<span class="hljs-built_in">get</span>());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的赋值运算符</span><br>    Resource&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Resource&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        <span class="hljs-built_in">copyFrom</span>(rhs);  <span class="hljs-comment">// 使用公共函数</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-现代C-的最佳实践"><a href="#7-现代C-的最佳实践" class="headerlink" title="7. 现代C++的最佳实践"></a>7. <strong>现代C++的最佳实践</strong></h4><p>使用现代C++特性可以简化复制操作的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernResource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; buffer_;<br>    <span class="hljs-type">size_t</span> bufferSize_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernResource</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">size_t</span> size)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">bufferSize_</span>(size), <br>          <span class="hljs-built_in">buffer_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size)) &#123;<br>        data_.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 拷贝构造函数：使用成员初始化列表</span><br>    <span class="hljs-built_in">ModernResource</span>(<span class="hljs-type">const</span> ModernResource&amp; rhs)<br>        : <span class="hljs-built_in">name_</span>(rhs.name_),<br>          <span class="hljs-built_in">data_</span>(rhs.data_),<br>          <span class="hljs-built_in">bufferSize_</span>(rhs.bufferSize_),<br>          <span class="hljs-built_in">buffer_</span>(rhs.buffer_ ? std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(rhs.bufferSize_) : <span class="hljs-literal">nullptr</span>) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (buffer_ &amp;&amp; rhs.buffer_) &#123;<br>            std::<span class="hljs-built_in">copy</span>(rhs.buffer_.<span class="hljs-built_in">get</span>(), <br>                     rhs.buffer_.<span class="hljs-built_in">get</span>() + bufferSize_, <br>                     buffer_.<span class="hljs-built_in">get</span>());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 使用copy-and-swap的赋值运算符</span><br>    ModernResource&amp; <span class="hljs-keyword">operator</span>=(ModernResource rhs) &#123;  <span class="hljs-comment">// 按值传递</span><br>        <span class="hljs-built_in">swap</span>(rhs);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 移动构造函数</span><br>    <span class="hljs-built_in">ModernResource</span>(ModernResource&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span><br>        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(rhs.name_)),<br>          <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(rhs.data_)),<br>          <span class="hljs-built_in">buffer_</span>(std::<span class="hljs-built_in">move</span>(rhs.buffer_)),<br>          <span class="hljs-built_in">bufferSize_</span>(rhs.bufferSize_) &#123;<br>        rhs.bufferSize_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(ModernResource&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(name_, other.name_);<br>        <span class="hljs-built_in">swap</span>(data_, other.data_);<br>        <span class="hljs-built_in">swap</span>(buffer_, other.buffer_);<br>        <span class="hljs-built_in">swap</span>(bufferSize_, other.bufferSize_);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="8-复杂继承层次中的最佳实践"><a href="#8-复杂继承层次中的最佳实践" class="headerlink" title="8. 复杂继承层次中的最佳实践"></a>8. <strong>复杂继承层次中的最佳实践</strong></h4><p>在复杂的继承层次中，确保每一层都正确处理复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string make_;<br>    std::string model_;<br>    <span class="hljs-type">int</span> year_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vehicle</span>(<span class="hljs-type">const</span> std::string&amp; make, <span class="hljs-type">const</span> std::string&amp; model, <span class="hljs-type">int</span> year)<br>        : <span class="hljs-built_in">make_</span>(make), <span class="hljs-built_in">model_</span>(model), <span class="hljs-built_in">year_</span>(year) &#123;&#125;<br>    <br>    <span class="hljs-built_in">Vehicle</span>(<span class="hljs-type">const</span> Vehicle&amp; rhs)<br>        : <span class="hljs-built_in">make_</span>(rhs.make_), <span class="hljs-built_in">model_</span>(rhs.model_), <span class="hljs-built_in">year_</span>(rhs.year_) &#123;&#125;<br>    <br>    Vehicle&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vehicle&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        make_ = rhs.make_;<br>        model_ = rhs.model_;<br>        year_ = rhs.year_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Vehicle</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 中间层</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MotorVehicle</span> : <span class="hljs-keyword">public</span> Vehicle &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string engineType_;<br>    <span class="hljs-type">int</span> horsePower_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MotorVehicle</span>(<span class="hljs-type">const</span> std::string&amp; make, <span class="hljs-type">const</span> std::string&amp; model, <br>                 <span class="hljs-type">int</span> year, <span class="hljs-type">const</span> std::string&amp; engine, <span class="hljs-type">int</span> hp)<br>        : <span class="hljs-built_in">Vehicle</span>(make, model, year), <span class="hljs-built_in">engineType_</span>(engine), <span class="hljs-built_in">horsePower_</span>(hp) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确调用基类拷贝构造函数</span><br>    <span class="hljs-built_in">MotorVehicle</span>(<span class="hljs-type">const</span> MotorVehicle&amp; rhs)<br>        : <span class="hljs-built_in">Vehicle</span>(rhs),                    <span class="hljs-comment">// 调用基类拷贝构造函数</span><br>          <span class="hljs-built_in">engineType_</span>(rhs.engineType_),<br>          <span class="hljs-built_in">horsePower_</span>(rhs.horsePower_) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确调用基类赋值运算符</span><br>    MotorVehicle&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MotorVehicle&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        Vehicle::<span class="hljs-keyword">operator</span>=(rhs);           <span class="hljs-comment">// 调用基类赋值运算符</span><br>        engineType_ = rhs.engineType_;<br>        horsePower_ = rhs.horsePower_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 最终派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">public</span> MotorVehicle &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numberOfDoors_;<br>    <span class="hljs-type">bool</span> isConvertible_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">const</span> std::string&amp; make, <span class="hljs-type">const</span> std::string&amp; model, <span class="hljs-type">int</span> year,<br>        <span class="hljs-type">const</span> std::string&amp; engine, <span class="hljs-type">int</span> hp, <span class="hljs-type">int</span> doors, <span class="hljs-type">bool</span> convertible)<br>        : <span class="hljs-built_in">MotorVehicle</span>(make, model, year, engine, hp),<br>          <span class="hljs-built_in">numberOfDoors_</span>(doors), <span class="hljs-built_in">isConvertible_</span>(convertible) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 完整的拷贝构造函数</span><br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">const</span> Car&amp; rhs)<br>        : <span class="hljs-built_in">MotorVehicle</span>(rhs),               <span class="hljs-comment">// 调用基类拷贝构造函数</span><br>          <span class="hljs-built_in">numberOfDoors_</span>(rhs.numberOfDoors_),<br>          <span class="hljs-built_in">isConvertible_</span>(rhs.isConvertible_) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 完整的赋值运算符</span><br>    Car&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Car&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        MotorVehicle::<span class="hljs-keyword">operator</span>=(rhs);      <span class="hljs-comment">// 调用基类赋值运算符</span><br>        numberOfDoors_ = rhs.numberOfDoors_;<br>        isConvertible_ = rhs.isConvertible_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="9-编译器辅助检测遗漏"><a href="#9-编译器辅助检测遗漏" class="headerlink" title="9. 编译器辅助检测遗漏"></a>9. <strong>编译器辅助检测遗漏</strong></h4><p>使用现代编译器的警告来帮助检测遗漏的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 开启编译器警告来检测未初始化的成员变量</span><br><span class="hljs-comment">// GCC/Clang: -Wuninitialized -Weffc++</span><br><span class="hljs-comment">// MSVC: /Wall</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WarnableClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> value_;<br>    <span class="hljs-type">double</span> ratio_;<br>    <span class="hljs-type">bool</span> flag_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 编译器会警告任何未在成员初始化列表中的成员变量</span><br>    <span class="hljs-built_in">WarnableClass</span>(<span class="hljs-type">const</span> WarnableClass&amp; rhs)<br>        : <span class="hljs-built_in">name_</span>(rhs.name_),<br>          <span class="hljs-built_in">value_</span>(rhs.value_),<br>          <span class="hljs-built_in">ratio_</span>(rhs.ratio_)<br>          <span class="hljs-comment">// ❌ 缺少flag_，编译器会发出警告</span><br>    &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 完整的初始化</span><br>    <span class="hljs-built_in">WarnableClass</span>(<span class="hljs-type">const</span> WarnableClass&amp; rhs)<br>        : <span class="hljs-built_in">name_</span>(rhs.name_),<br>          <span class="hljs-built_in">value_</span>(rhs.value_),<br>          <span class="hljs-built_in">ratio_</span>(rhs.ratio_),<br>          <span class="hljs-built_in">flag_</span>(rhs.flag_)      <span class="hljs-comment">// 现在所有成员都被初始化了</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><strong>复制完整性的检查清单：</strong></p>
<ol>
<li><strong>所有成员变量</strong>：确保每个成员变量都被复制</li>
<li><strong>所有基类部分</strong>：在派生类中调用基类的拷贝函数</li>
<li><strong>多重继承</strong>：确保所有基类都被正确处理</li>
<li><strong>资源管理</strong>：深拷贝vs浅拷贝的正确选择</li>
<li><strong>异常安全性</strong>：确保拷贝过程中的异常安全</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>使用成员初始化列表</strong>：在拷贝构造函数中使用成员初始化列表</li>
<li><strong>避免函数间相互调用</strong>：不要让拷贝构造函数和赋值运算符相互调用</li>
<li><strong>提取公共代码</strong>：将公共的复制逻辑提取到私有函数中</li>
<li><strong>使用现代C++特性</strong>：智能指针、移动语义、copy-and-swap</li>
</ul>
<p><strong>现代C++建议：</strong></p>
<ul>
<li><strong>Rule of Zero</strong>：尽可能使用智能指针和标准容器，避免手动资源管理</li>
<li><strong>Rule of Five</strong>：如果需要自定义析构函数，通常也需要自定义拷贝构造函数、拷贝赋值运算符、移动构造函数和移动赋值运算符</li>
<li><strong>使用&#x3D;default和&#x3D;delete</strong>：明确表示意图</li>
</ul>
<p><strong>记住：Copying函数应确保复制”对象内的所有成员变量”以及”所有base class成分”。不要尝试以某个copying函数实现另一个copying函数。应该将共同功能放进第三个函数中，并由两个copying函数共同调用。</strong> </p>
<h2 id="条款13：-以对象管理资源"><a href="#条款13：-以对象管理资源" class="headerlink" title="条款13： 以对象管理资源"></a>条款13： 以对象管理资源</h2><blockquote>
<p><em>Use objects to manage resources</em></p>
</blockquote>
<h3 id="核心理念-12"><a href="#核心理念-12" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</strong>。RAII（Resource Acquisition Is Initialization）是C++中最重要的资源管理技术，它利用C++的构造函数和析构函数的确定性调用来自动管理资源生命周期。这种技术不仅适用于内存管理，还适用于文件、网络连接、互斥锁等各种资源。</p>
<h3 id="深度解析-12"><a href="#深度解析-12" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-传统资源管理的问题"><a href="#1-传统资源管理的问题" class="headerlink" title="1. 传统资源管理的问题"></a>1. <strong>传统资源管理的问题</strong></h4><p>手动资源管理容易导致资源泄漏和异常安全问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 传统的手动资源管理方式的问题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分配资源</span><br>    <span class="hljs-type">int</span>* data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000</span>];<br>    FILE* file = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <br>    <span class="hljs-comment">// 处理数据...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">someErrorCondition</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// ❌ 忘记释放资源就返回了！</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 可能抛出异常的操作</span><br>    <span class="hljs-built_in">riskyOperation</span>();  <span class="hljs-comment">// ❌ 如果抛出异常，资源不会被释放</span><br>    <br>    <span class="hljs-comment">// 正常路径下的清理</span><br>    <span class="hljs-keyword">delete</span>[] data;<br>    <span class="hljs-built_in">fclose</span>(file);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-RAII的基本原理"><a href="#2-RAII的基本原理" class="headerlink" title="2. RAII的基本原理"></a>2. <strong>RAII的基本原理</strong></h4><p>RAII利用对象的生命周期来自动管理资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ RAII原理示例：简单的数组包装器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IntArray</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> : size_(size) &#123;</span><br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">IntArray</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123; <span class="hljs-keyword">return</span> data_[index]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <br>    <span class="hljs-comment">// 禁用拷贝（简化示例）</span><br>    <span class="hljs-built_in">IntArray</span>(<span class="hljs-type">const</span> IntArray&amp;) = <span class="hljs-keyword">delete</span>;<br>    IntArray&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> IntArray&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 使用RAII的安全版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processDataSafely</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">IntArray <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span></span>;        <span class="hljs-comment">// 自动管理内存</span><br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">someErrorCondition</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// ✅ data的析构函数会自动释放内存</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">riskyOperation</span>();  <span class="hljs-comment">// ✅ 即使抛出异常，析构函数也会被调用</span><br>    <br>    <span class="hljs-comment">// ✅ 函数结束时，data的析构函数自动释放资源</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>记住：为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。现代C++中常用的RAII类包括std::unique_ptr和std::shared_ptr等智能指针。</strong></p>
<h2 id="条款14：-在资源管理类中小心copying行为"><a href="#条款14：-在资源管理类中小心copying行为" class="headerlink" title="条款14： 在资源管理类中小心copying行为"></a>条款14： 在资源管理类中小心copying行为</h2><blockquote>
<p><em>Think carefully about copying behavior in resource-managing classes</em></p>
</blockquote>
<h3 id="核心理念-13"><a href="#核心理念-13" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</strong>。当设计资源管理类时，必须仔细考虑拷贝行为，因为不当的拷贝可能导致资源重复释放、悬挂指针或资源泄漏。普遍而常见的RAII class copying行为包括：抑制copying、施行引用计数法（reference counting）、深拷贝资源，或转移资源所有权。</p>
<h3 id="深度解析-13"><a href="#深度解析-13" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-资源管理类的拷贝问题"><a href="#1-资源管理类的拷贝问题" class="headerlink" title="1. 资源管理类的拷贝问题"></a>1. <strong>资源管理类的拷贝问题</strong></h4><p>当RAII类管理资源时，默认的拷贝行为通常是不安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 有问题的RAII类：默认拷贝行为危险</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NaiveLock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex* pm_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NaiveLock</span><span class="hljs-params">(std::mutex* pm)</span> : pm_(pm) &#123;</span><br>        pm_-&gt;<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">NaiveLock</span>() &#123;<br>        pm_-&gt;<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用编译器生成的默认拷贝构造函数和赋值运算符</span><br>    <span class="hljs-comment">// 这会导致问题！</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    std::mutex m;<br>    <br>    &#123;<br>        <span class="hljs-function">NaiveLock <span class="hljs-title">lock1</span><span class="hljs-params">(&amp;m)</span></span>;      <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-function">NaiveLock <span class="hljs-title">lock2</span><span class="hljs-params">(lock1)</span></span>;   <span class="hljs-comment">// ❌ 拷贝构造，现在两个对象管理同一个锁</span><br>        <br>        <span class="hljs-comment">// lock2离开作用域，调用unlock()</span><br>    &#125;  <span class="hljs-comment">// lock1离开作用域，再次调用unlock() - 错误！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-解决方案1：禁止拷贝"><a href="#2-解决方案1：禁止拷贝" class="headerlink" title="2. 解决方案1：禁止拷贝"></a>2. <strong>解决方案1：禁止拷贝</strong></h4><p>最简单和常见的解决方案是禁止拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 禁止拷贝的RAII类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonCopyableLock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex* pm_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NonCopyableLock</span><span class="hljs-params">(std::mutex* pm)</span> : pm_(pm) &#123;</span><br>        pm_-&gt;<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">NonCopyableLock</span>() &#123;<br>        pm_-&gt;<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除拷贝构造函数和赋值运算符</span><br>    <span class="hljs-built_in">NonCopyableLock</span>(<span class="hljs-type">const</span> NonCopyableLock&amp;) = <span class="hljs-keyword">delete</span>;<br>    NonCopyableLock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NonCopyableLock&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 可以选择支持移动语义</span><br>    <span class="hljs-built_in">NonCopyableLock</span>(NonCopyableLock&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">pm_</span>(other.pm_) &#123;<br>        other.pm_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    NonCopyableLock&amp; <span class="hljs-keyword">operator</span>=(NonCopyableLock&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">if</span> (pm_) pm_-&gt;<span class="hljs-built_in">unlock</span>();<br>            pm_ = other.pm_;<br>            other.pm_ = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateNonCopyable</span><span class="hljs-params">()</span> </span>&#123;<br>    std::mutex m;<br>    <br>    <span class="hljs-function">NonCopyableLock <span class="hljs-title">lock1</span><span class="hljs-params">(&amp;m)</span></span>;<br>    <span class="hljs-comment">// NonCopyableLock lock2(lock1);  // ❌ 编译错误：拷贝被禁用</span><br>    <br>    NonCopyableLock lock3 = std::<span class="hljs-built_in">move</span>(lock1);  <span class="hljs-comment">// ✅ 移动是允许的</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-解决方案2：引用计数"><a href="#3-解决方案2：引用计数" class="headerlink" title="3. 解决方案2：引用计数"></a>3. <strong>解决方案2：引用计数</strong></h4><p>允许多个对象共享资源，使用引用计数管理生命周期。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 使用引用计数的RAII类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedLock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;std::mutex&gt; pm_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SharedLock</span><span class="hljs-params">(std::mutex* pm)</span> </span><br><span class="hljs-function">        : pm_(pm, [](std::mutex* m) &#123;</span> m-&gt;<span class="hljs-built_in">unlock</span>(); &#125;) &#123;<br>        pm-&gt;<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 默认拷贝行为现在是安全的</span><br>    <span class="hljs-comment">// shared_ptr会自动管理引用计数</span><br>    <br>    ~<span class="hljs-built_in">SharedLock</span>() &#123;<br>        <span class="hljs-comment">// shared_ptr的析构函数会在引用计数为0时调用deleter</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSharedLock</span><span class="hljs-params">()</span> </span>&#123;<br>    std::mutex m;<br>    <br>    &#123;<br>        <span class="hljs-function">SharedLock <span class="hljs-title">lock1</span><span class="hljs-params">(&amp;m)</span></span>;      <span class="hljs-comment">// 引用计数 = 1，获取锁</span><br>        &#123;<br>            <span class="hljs-function">SharedLock <span class="hljs-title">lock2</span><span class="hljs-params">(lock1)</span></span>;   <span class="hljs-comment">// ✅ 引用计数 = 2，共享锁</span><br>            SharedLock lock3 = lock1;  <span class="hljs-comment">// ✅ 引用计数 = 3</span><br>            <br>            <span class="hljs-comment">// lock3离开作用域，引用计数 = 2</span><br>        &#125;<br>        <span class="hljs-comment">// lock2离开作用域，引用计数 = 1</span><br>    &#125;<br>    <span class="hljs-comment">// lock1离开作用域，引用计数 = 0，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-解决方案3：深拷贝"><a href="#4-解决方案3：深拷贝" class="headerlink" title="4. 解决方案3：深拷贝"></a>4. <strong>解决方案3：深拷贝</strong></h4><p>创建资源的副本，每个对象管理自己的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 深拷贝的RAII类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopyResource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DeepCopyResource</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Allocated &quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot; integers&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数：深拷贝</span><br>    <span class="hljs-built_in">DeepCopyResource</span>(<span class="hljs-type">const</span> DeepCopyResource&amp; other) : <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::<span class="hljs-built_in">copy</span>(other.data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>() + size_, data_.<span class="hljs-built_in">get</span>());<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deep copied &quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot; integers&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 赋值运算符：深拷贝</span><br>    DeepCopyResource&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeepCopyResource&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        size_ = other.size_;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::<span class="hljs-built_in">copy</span>(other.data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>() + size_, data_.<span class="hljs-built_in">get</span>());<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deep copy assigned &quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot; integers&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">DeepCopyResource</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deallocated &quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot; integers&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123; <span class="hljs-keyword">return</span> data_[index]; &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> data_[index]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDeepCopy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">DeepCopyResource <span class="hljs-title">res1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    res1[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;<br>    <br>    <span class="hljs-function">DeepCopyResource <span class="hljs-title">res2</span><span class="hljs-params">(res1)</span></span>;  <span class="hljs-comment">// ✅ 深拷贝，每个对象有自己的资源</span><br>    res2[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;res1[0] = &quot;</span> &lt;&lt; res1[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出42</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;res2[0] = &quot;</span> &lt;&lt; res2[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出99</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-解决方案4：转移所有权"><a href="#5-解决方案4：转移所有权" class="headerlink" title="5. 解决方案4：转移所有权"></a>5. <strong>解决方案4：转移所有权</strong></h4><p>将资源所有权从一个对象转移到另一个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 转移所有权的RAII类（类似std::unique_ptr）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferOwnership</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TransferOwnership</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 禁用拷贝</span><br>    <span class="hljs-built_in">TransferOwnership</span>(<span class="hljs-type">const</span> TransferOwnership&amp;) = <span class="hljs-keyword">delete</span>;<br>    TransferOwnership&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TransferOwnership&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 移动构造函数：转移所有权</span><br>    <span class="hljs-built_in">TransferOwnership</span>(TransferOwnership&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(other.data_)), <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        other.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符：转移所有权</span><br>    TransferOwnership&amp; <span class="hljs-keyword">operator</span>=(TransferOwnership&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            data_ = std::<span class="hljs-built_in">move</span>(other.data_);<br>            size_ = other.size_;<br>            other.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123; <span class="hljs-keyword">return</span> data_[index]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateOwnershipTransfer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">TransferOwnership <span class="hljs-title">res1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    res1[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;<br>    <br>    TransferOwnership res2 = std::<span class="hljs-built_in">move</span>(res1);  <span class="hljs-comment">// ✅ 转移所有权</span><br>    <span class="hljs-comment">// 现在res1不再拥有资源，res2拥有资源</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;res2[0] = &quot;</span> &lt;&lt; res2[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出42</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; res1[0];  // ❌ 未定义行为，res1已不拥有资源</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><strong>资源管理类的四种拷贝策略：</strong></p>
<ol>
<li><p><strong>禁止拷贝</strong>：删除拷贝构造函数和赋值运算符</p>
<ul>
<li>适用场景：独占资源（如文件句柄、锁）</li>
<li>优点：简单、安全</li>
<li>缺点：限制了使用灵活性</li>
</ul>
</li>
<li><p><strong>引用计数</strong>：多个对象共享资源</p>
<ul>
<li>适用场景：可共享的资源（如内存、缓存）</li>
<li>优点：灵活、自动管理</li>
<li>缺点：有引用计数开销，可能有循环引用问题</li>
</ul>
</li>
<li><p><strong>深拷贝</strong>：为每个对象创建资源副本</p>
<ul>
<li>适用场景：可复制的资源（如数据容器）</li>
<li>优点：每个对象独立、无共享问题</li>
<li>缺点：资源开销大</li>
</ul>
</li>
<li><p><strong>转移所有权</strong>：使用移动语义转移资源</p>
<ul>
<li>适用场景：独占且可转移的资源</li>
<li>优点：高效、明确的所有权语义</li>
<li>缺点：资源在转移后不可访问</li>
</ul>
</li>
</ol>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>明确资源语义</strong>：确定资源是独占、共享还是可复制的</li>
<li><strong>选择合适的策略</strong>：根据资源特性选择拷贝行为</li>
<li><strong>保持一致性</strong>：整个类的设计要保持一致的资源管理语义</li>
<li><strong>使用标准库</strong>：优先使用std::unique_ptr、std::shared_ptr等</li>
</ul>
<p><strong>记住：复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现。</strong></p>
<h2 id="条款15：-在资源管理类中提供对原始资源的访问"><a href="#条款15：-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15： 在资源管理类中提供对原始资源的访问"></a>条款15： 在资源管理类中提供对原始资源的访问</h2><blockquote>
<p><em>Provide access to raw resources in resource-managing classes</em></p>
</blockquote>
<h3 id="核心理念-14"><a href="#核心理念-14" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个”取得其所管理之资源”的办法</strong>。对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。设计资源管理类时，需要在安全性和易用性之间找到平衡。</p>
<h3 id="深度解析-14"><a href="#深度解析-14" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-为什么需要访问原始资源"><a href="#1-为什么需要访问原始资源" class="headerlink" title="1. 为什么需要访问原始资源"></a>1. <strong>为什么需要访问原始资源</strong></h4><p>RAII类封装了资源，但现实中的API往往需要直接访问底层资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 现实中的API通常需要原始资源</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processFile</span><span class="hljs-params">(FILE* file)</span></span>;           <span class="hljs-comment">// C API需要FILE*</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawTexture</span><span class="hljs-params">(GLuint textureId)</span></span>;     <span class="hljs-comment">// OpenGL API需要纹理ID</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendData</span><span class="hljs-params">(<span class="hljs-type">int</span> socket)</span></span>;              <span class="hljs-comment">// 网络API需要socket句柄</span><br><br><span class="hljs-comment">// RAII类必须提供访问原始资源的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileRAII</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 需要某种方式让外部API访问file_</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-显式转换：安全的访问方式"><a href="#2-显式转换：安全的访问方式" class="headerlink" title="2. 显式转换：安全的访问方式"></a>2. <strong>显式转换：安全的访问方式</strong></h4><p>通过明确的成员函数提供对原始资源的访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FileHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span></span><br><span class="hljs-function">        : file_(std::fopen(filename, mode)) &#123;</span><br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">FileHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) &#123;<br>            std::<span class="hljs-built_in">fclose</span>(file_);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 显式转换：提供get()函数访问底层资源</span><br>    <span class="hljs-function">FILE* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供更多有用的方法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> file_ != <span class="hljs-literal">nullptr</span>; &#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">readLine</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!file_) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fgets</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer), file_)) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buffer);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateExplicitAccess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">FileHandle <span class="hljs-title">fileHandle</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// ✅ 通过显式调用get()函数来访问底层FILE*指针</span><br>    FILE* rawFile = fileHandle.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">if</span> (rawFile) &#123;<br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>        std::<span class="hljs-built_in">fgets</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer), rawFile);<br>        std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buffer);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 意图明确：我们明确知道在访问底层资源</span><br>    <span class="hljs-built_in">processFile</span>(fileHandle.<span class="hljs-built_in">get</span>());  <span class="hljs-comment">// 传递给需要FILE*的API</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>显式转换的优点：</strong></p>
<ul>
<li>意图明确，代码可读性好</li>
<li>不会发生意外的类型转换</li>
<li>便于调试和维护</li>
</ul>
<p><strong>显式转换的缺点：</strong></p>
<ul>
<li>使用稍显繁琐</li>
<li>需要记住调用get()函数</li>
</ul>
<h4 id="3-隐式转换：便利但有风险的访问方式"><a href="#3-隐式转换：便利但有风险的访问方式" class="headerlink" title="3. 隐式转换：便利但有风险的访问方式"></a>3. <strong>隐式转换：便利但有风险的访问方式</strong></h4><p>通过类型转换运算符提供自动转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImplicitFileHandle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ImplicitFileHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span></span><br><span class="hljs-function">        : file_(std::fopen(filename, mode)) &#123;</span><br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ImplicitFileHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) &#123;<br>            std::<span class="hljs-built_in">fclose</span>(file_);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ⚠️ 隐式转换：自动转换为FILE*</span><br>    <span class="hljs-keyword">operator</span> FILE*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> file_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 也可以提供bool转换，用于条件判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_ != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateImplicitAccess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ImplicitFileHandle <span class="hljs-title">fileHandle</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// ✅ 简洁：无需显式调用，自动转换为FILE*</span><br>    <span class="hljs-keyword">if</span> (fileHandle) &#123;  <span class="hljs-comment">// 自动转换为bool进行检查</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>        std::<span class="hljs-built_in">fgets</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer), fileHandle); <span class="hljs-comment">// 隐式转换为FILE*</span><br>        std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buffer);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 直接传递给API，自动转换</span><br>    <span class="hljs-built_in">processFile</span>(fileHandle);  <span class="hljs-comment">// 自动转换为FILE*</span><br>    <br>    <span class="hljs-comment">// ❌ 但可能导致意外的转换</span><br>    FILE* rawFile = fileHandle;  <span class="hljs-comment">// 可能不是有意的</span><br>    <span class="hljs-keyword">if</span> (fileHandle == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;  <span class="hljs-comment">// 意外的指针比较</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>隐式转换的优点：</strong></p>
<ul>
<li>使用简洁方便</li>
<li>代码更接近使用原始资源的风格</li>
<li>减少了重复的get()调用</li>
</ul>
<p><strong>隐式转换的缺点：</strong></p>
<ul>
<li>可能发生意外的类型转换</li>
<li>降低了代码的明确性</li>
<li>增加了出错的可能性</li>
</ul>
<h4 id="4-智能指针的设计借鉴"><a href="#4-智能指针的设计借鉴" class="headerlink" title="4. 智能指针的设计借鉴"></a>4. <strong>智能指针的设计借鉴</strong></h4><p>标准库智能指针提供了很好的设计参考。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSmartPointerAccess</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);  <span class="hljs-comment">// C++14</span><br>    <br>    <span class="hljs-comment">// ✅ 显式访问</span><br>    <span class="hljs-type">int</span>* rawPtr = ptr.<span class="hljs-built_in">get</span>();        <span class="hljs-comment">// 明确的get()函数</span><br>    <span class="hljs-type">int</span> value = *ptr;               <span class="hljs-comment">// 解引用操作符</span><br>    <br>    <span class="hljs-comment">// ✅ 条件判断</span><br>    <span class="hljs-keyword">if</span> (ptr) &#123;                      <span class="hljs-comment">// 隐式转换为bool</span><br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 没有隐式转换为原始指针</span><br>    <span class="hljs-comment">// int* raw = ptr;              // 编译错误</span><br>&#125;<br><br><span class="hljs-comment">// 应用到我们的设计中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BestPracticeFileHandle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BestPracticeFileHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span></span><br><span class="hljs-function">        : file_(std::fopen(filename, mode)) &#123;</span><br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">BestPracticeFileHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) &#123;<br>            std::<span class="hljs-built_in">fclose</span>(file_);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ✅ 显式访问：类似智能指针的get()</span><br>    <span class="hljs-function">FILE* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 解引用访问（如果适用）</span><br>    FILE&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (!file_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;File not open&quot;</span>);<br>        <span class="hljs-keyword">return</span> *file_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 箭头操作符（如果FILE是结构体的话）</span><br>    FILE* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> file_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 隐式转换为bool，用于条件判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_ != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-不同资源类型的访问模式"><a href="#5-不同资源类型的访问模式" class="headerlink" title="5. 不同资源类型的访问模式"></a>5. <strong>不同资源类型的访问模式</strong></h4><p>不同类型的资源可能需要不同的访问策略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 网络socket：通常只需要文件描述符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketHandle</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> socket_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SocketHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建socket连接</span><br>        socket_ = <span class="hljs-built_in">createConnection</span>(host, port);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">SocketHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (socket_ != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">close</span>(socket_);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 显式访问socket描述符</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> socket_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 条件判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> socket_ != <span class="hljs-number">-1</span>; &#125;<br>    <br>    <span class="hljs-comment">// ❌ 不提供隐式转换，避免意外使用</span><br>    <span class="hljs-comment">// operator int() const &#123; return socket_; &#125;</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">// 实现网络连接</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 示例</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// OpenGL纹理：可能需要多种访问方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextureHandle</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> textureId_;<br>    <span class="hljs-type">int</span> width_, height_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextureHandle</span>(<span class="hljs-type">const</span> std::string&amp; filename) &#123;<br>        <span class="hljs-comment">// 加载纹理</span><br>        textureId_ = <span class="hljs-built_in">loadTexture</span>(filename, width_, height_);<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">TextureHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (textureId_ != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">deleteTexture</span>(textureId_);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 提供多种访问方式</span><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> textureId_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> width_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> height_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 为特定用途提供便利函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">bindTexture</span>(textureId_);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> textureId_ != <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">loadTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, <span class="hljs-type">int</span>&amp; w, <span class="hljs-type">int</span>&amp; h)</span> </span>&#123;<br>        w = h = <span class="hljs-number">256</span>; <span class="hljs-comment">// 示例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">// 示例</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteTexture</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindTexture</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><strong>资源访问策略的选择指南：</strong></p>
<ol>
<li><p><strong>显式转换（推荐）</strong>：</p>
<ul>
<li>提供get()或类似的明确函数</li>
<li>适用于大多数RAII类</li>
<li>安全性高，意图明确</li>
</ul>
</li>
<li><p><strong>隐式转换（谨慎使用）</strong>：</p>
<ul>
<li>只在使用频繁且转换安全时考虑</li>
<li>避免意外的类型转换</li>
<li>考虑提供explicit转换</li>
</ul>
</li>
<li><p><strong>混合策略</strong>：</p>
<ul>
<li>显式访问原始资源</li>
<li>隐式转换为bool用于条件判断</li>
<li>根据资源特性提供专门的操作函数</li>
</ul>
</li>
</ol>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>安全第一</strong>：避免意外的类型转换</li>
<li><strong>明确意图</strong>：让代码清楚地表达访问资源的意图</li>
<li><strong>便利性</strong>：在安全的前提下提供便利的访问方式</li>
<li><strong>一致性</strong>：在整个项目中保持一致的访问模式</li>
</ul>
<p><strong>记住：APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个”取得其所管理之资源”的办法。对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。</strong></p>
<h2 id="条款16：-成对使用new和delete时要采取相同形式"><a href="#条款16：-成对使用new和delete时要采取相同形式" class="headerlink" title="条款16： 成对使用new和delete时要采取相同形式"></a>条款16： 成对使用new和delete时要采取相同形式</h2><blockquote>
<p><em>Use the same form in corresponding uses of new and delete</em></p>
</blockquote>
<h3 id="核心理念-15"><a href="#核心理念-15" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]</strong>。这个规则看似简单，但违反它会导致未定义行为。new和delete的不匹配是C++中常见的内存管理错误之一，现代C++通过智能指针和容器可以完全避免这类问题。</p>
<h3 id="深度解析-15"><a href="#深度解析-15" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-new和delete的基本配对规则"><a href="#1-new和delete的基本配对规则" class="headerlink" title="1. new和delete的基本配对规则"></a>1. <strong>new和delete的基本配对规则</strong></h4><p>每种new操作都有对应的delete操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确的配对</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);          <span class="hljs-comment">// 单个对象</span><br><span class="hljs-keyword">delete</span> p1;                      <span class="hljs-comment">// 对应的delete</span><br><br><span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];         <span class="hljs-comment">// 数组</span><br><span class="hljs-keyword">delete</span>[] p2;                    <span class="hljs-comment">// 对应的delete[]</span><br><br><span class="hljs-comment">// ❌ 错误的配对 - 未定义行为</span><br><span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">delete</span>[] p3;                    <span class="hljs-comment">// ❌ 单个对象用delete[]</span><br><br><span class="hljs-type">int</span>* p4 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">delete</span> p4;                      <span class="hljs-comment">// ❌ 数组用delete</span><br></code></pre></td></tr></table></figure>

<h4 id="2-为什么混用会导致未定义行为"><a href="#2-为什么混用会导致未定义行为" class="headerlink" title="2. 为什么混用会导致未定义行为"></a>2. <strong>为什么混用会导致未定义行为</strong></h4><p>new[]和delete[]处理的内存布局与new&#x2F;delete不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>(<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>) : <span class="hljs-built_in">value_</span>(val) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Demo(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="hljs-string">&quot;) constructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">Demo</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Demo(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="hljs-string">&quot;) destructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateUndefinedBehavior</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// new[]可能在内存中存储额外信息（如数组大小）</span><br>    Demo* array = <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>];  <span class="hljs-comment">// 创建3个Demo对象</span><br>    <br>    <span class="hljs-comment">// ❌ 使用delete而不是delete[] - 未定义行为！</span><br>    <span class="hljs-comment">// delete array;  // 只调用一次析构函数，而不是3次</span><br>    <br>    <span class="hljs-comment">// ✅ 正确的方式</span><br>    <span class="hljs-keyword">delete</span>[] array;  <span class="hljs-comment">// 正确调用3次析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSingleObject</span><span class="hljs-params">()</span> </span>&#123;<br>    Demo* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Demo</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 创建单个对象</span><br>    <br>    <span class="hljs-comment">// ❌ 使用delete[]而不是delete - 未定义行为！</span><br>    <span class="hljs-comment">// delete[] obj;  // 可能尝试读取不存在的数组大小信息</span><br>    <br>    <span class="hljs-comment">// ✅ 正确的方式</span><br>    <span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 正确调用一次析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-常见错误场景"><a href="#3-常见错误场景" class="headerlink" title="3. 常见错误场景"></a>3. <strong>常见错误场景</strong></h4><p>typedef和using声明容易导致混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 容易混淆的场景</span><br><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];  <span class="hljs-comment">// 数组类型的typedef</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">problematicCode</span><span class="hljs-params">()</span> </span>&#123;<br>    AddressLines* pal = <span class="hljs-keyword">new</span> AddressLines;  <span class="hljs-comment">// 实际上是 new std::string[4]</span><br>    <br>    <span class="hljs-comment">// ❌ 错误：看起来像单个对象，实际上是数组</span><br>    <span class="hljs-comment">// delete pal;  // 应该用delete[]</span><br>    <br>    <span class="hljs-comment">// ✅ 正确：必须用delete[]</span><br>    <span class="hljs-keyword">delete</span>[] pal;<br>&#125;<br><br><span class="hljs-comment">// ✅ 更清晰的现代写法</span><br><span class="hljs-keyword">using</span> AddressArray = std::array&lt;std::string, <span class="hljs-number">4</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">betterCode</span><span class="hljs-params">()</span> </span>&#123;<br>    AddressArray* pal = <span class="hljs-keyword">new</span> AddressArray;  <span class="hljs-comment">// 真正的单个对象</span><br>    <span class="hljs-keyword">delete</span> pal;  <span class="hljs-comment">// 正确使用delete</span><br>    <br>    <span class="hljs-comment">// 或者更好：避免裸指针</span><br>    <span class="hljs-keyword">auto</span> pal2 = std::<span class="hljs-built_in">make_unique</span>&lt;AddressArray&gt;();  <span class="hljs-comment">// 自动管理</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-编译器无法检测的问题"><a href="#4-编译器无法检测的问题" class="headerlink" title="4. 编译器无法检测的问题"></a>4. <strong>编译器无法检测的问题</strong></h4><p>这类错误在编译时无法检测，只能在运行时发现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Resource</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-number">1000</span>) &#123;  <span class="hljs-comment">// 分配较大的内存</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource created&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">Resource</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">silentErrors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这些错误代码可能编译通过，但运行时有问题</span><br>    <br>    <span class="hljs-comment">// 场景1：数组误用delete</span><br>    Resource* resources = <span class="hljs-keyword">new</span> Resource[<span class="hljs-number">5</span>];<br>    <span class="hljs-comment">// delete resources;     // ❌ 可能只销毁第一个对象</span><br>    <span class="hljs-keyword">delete</span>[] resources;      <span class="hljs-comment">// ✅ 正确</span><br>    <br>    <span class="hljs-comment">// 场景2：单对象误用delete[]</span><br>    Resource* resource = <span class="hljs-keyword">new</span> Resource;<br>    <span class="hljs-comment">// delete[] resource;    // ❌ 可能读取无效的数组信息</span><br>    <span class="hljs-keyword">delete</span> resource;         <span class="hljs-comment">// ✅ 正确</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-现代C-的解决方案"><a href="#5-现代C-的解决方案" class="headerlink" title="5. 现代C++的解决方案"></a>5. <strong>现代C++的解决方案</strong></h4><p>使用智能指针和标准容器避免手动内存管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-comment">// ✅ 现代C++最佳实践</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modernApproach</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 使用智能指针管理单个对象</span><br>    <span class="hljs-keyword">auto</span> obj = std::<span class="hljs-built_in">make_unique</span>&lt;Demo&gt;(<span class="hljs-number">42</span>);  <span class="hljs-comment">// C++14</span><br>    <span class="hljs-comment">// 自动调用正确的delete</span><br>    <br>    <span class="hljs-comment">// 2. 使用vector管理动态数组</span><br>    <span class="hljs-function">std::vector&lt;Demo&gt; <span class="hljs-title">dynamicArray</span><span class="hljs-params">(<span class="hljs-number">5</span>, Demo(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-comment">// 自动管理内存，无需手动delete</span><br>    <br>    <span class="hljs-comment">// 3. 使用array管理固定大小数组</span><br>    <span class="hljs-keyword">auto</span> fixedArray = std::make_unique&lt;std::array&lt;Demo, <span class="hljs-number">3</span>&gt;&gt;();  <span class="hljs-comment">// C++14</span><br>    <span class="hljs-comment">// 智能指针自动管理</span><br>    <br>    <span class="hljs-comment">// 4. 管理数组的智能指针（C++14起）</span><br>    <span class="hljs-keyword">auto</span> smartArray = std::<span class="hljs-built_in">make_unique</span>&lt;Demo[]&gt;(<span class="hljs-number">5</span>);  <span class="hljs-comment">// C++14</span><br>    <span class="hljs-comment">// 自动调用delete[]</span><br>&#125;<br><br><span class="hljs-comment">// 自定义删除器示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">customDeleterExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 对于特殊情况，可以使用自定义删除器</span><br>    <span class="hljs-function">std::unique_ptr&lt;Demo[]&gt; <span class="hljs-title">arrayPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Demo[<span class="hljs-number">5</span>])</span></span>;<br>    <span class="hljs-comment">// 编译器知道这是数组，会自动调用delete[]</span><br>    <br>    <span class="hljs-comment">// 或者显式指定删除器</span><br>    <span class="hljs-function">std::unique_ptr&lt;Demo, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Demo*)</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>], </span></span><br><span class="hljs-params"><span class="hljs-function">        [](Demo* p) &#123; <span class="hljs-keyword">delete</span>[] p; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-调试和检测工具"><a href="#6-调试和检测工具" class="headerlink" title="6. 调试和检测工具"></a>6. <strong>调试和检测工具</strong></h4><p>使用工具帮助检测内存管理错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 调试版本可以添加内存跟踪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrackedDemo</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> instanceCount_;<br>    <span class="hljs-type">int</span> id_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TrackedDemo</span>() : <span class="hljs-built_in">id_</span>(++instanceCount_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TrackedDemo &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; created&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">TrackedDemo</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TrackedDemo &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; destroyed&quot;</span> &lt;&lt; std::endl;<br>        --instanceCount_;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getInstanceCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> instanceCount_; &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> TrackedDemo::instanceCount_ = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memoryLeakDetection</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Initial count: &quot;</span> &lt;&lt; TrackedDemo::<span class="hljs-built_in">getInstanceCount</span>() &lt;&lt; std::endl;<br>    <br>    &#123;<br>        TrackedDemo* array = <span class="hljs-keyword">new</span> TrackedDemo[<span class="hljs-number">3</span>];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;After creation: &quot;</span> &lt;&lt; TrackedDemo::<span class="hljs-built_in">getInstanceCount</span>() &lt;&lt; std::endl;<br>        <br>        <span class="hljs-keyword">delete</span>[] array;  <span class="hljs-comment">// 正确释放</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;After deletion: &quot;</span> &lt;&lt; TrackedDemo::<span class="hljs-built_in">getInstanceCount</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用AddressSanitizer, Valgrind等工具可以检测这类错误</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-特殊情况和注意事项"><a href="#7-特殊情况和注意事项" class="headerlink" title="7. 特殊情况和注意事项"></a>7. <strong>特殊情况和注意事项</strong></h4><p>某些场景需要特别注意。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// placement new的特殊处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">placementNewExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-built_in">sizeof</span>(Demo) * <span class="hljs-number">3</span>];<br>    <br>    <span class="hljs-comment">// placement new数组</span><br>    Demo* array = <span class="hljs-built_in">new</span>(buffer) Demo[<span class="hljs-number">3</span>];<br>    <br>    <span class="hljs-comment">// ❌ 不能用delete或delete[]，因为内存不是通过new分配的</span><br>    <span class="hljs-comment">// delete[] array;  // 错误</span><br>    <br>    <span class="hljs-comment">// ✅ 手动调用析构函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        array[i].~<span class="hljs-built_in">Demo</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数参数传递中的陷阱</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionParameterTrap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ❌ 危险：容易忘记正确的delete形式</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(Demo* arr)</span></span>;  <span class="hljs-comment">// 不知道是单个对象还是数组</span><br>    <br>    <span class="hljs-comment">// ✅ 更好：使用明确的类型</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(std::vector&lt;Demo&gt;&amp; arr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(std::array&lt;Demo, <span class="hljs-number">5</span>&gt;&amp; arr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processArray</span><span class="hljs-params">(std::unique_ptr&lt;Demo[]&gt; arr)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><strong>基本规则：</strong></p>
<ul>
<li><strong>new 配对 delete</strong>：用于单个对象</li>
<li><strong>new[] 配对 delete[]</strong>：用于数组</li>
<li><strong>绝不混用</strong>：违反此规则导致未定义行为</li>
</ul>
<p><strong>常见问题：</strong></p>
<ul>
<li><strong>typedef隐藏数组性质</strong>：需要仔细检查类型定义</li>
<li><strong>编译器无法检测</strong>：错误在运行时才显现</li>
<li><strong>析构函数调用次数错误</strong>：可能导致资源泄漏或多次析构</li>
</ul>
<p><strong>现代C++解决方案：</strong></p>
<ul>
<li><strong>优先使用智能指针</strong>：<code>std::unique_ptr</code>、<code>std::shared_ptr</code></li>
<li><strong>使用标准容器</strong>：<code>std::vector</code>、<code>std::array</code></li>
<li><strong>避免裸指针</strong>：除非与C API交互</li>
<li><strong>使用make_函数</strong>：<code>std::make_unique</code>(C++14)、<code>std::make_shared</code></li>
</ul>
<p><strong>调试建议：</strong></p>
<ul>
<li><strong>使用内存检测工具</strong>：AddressSanitizer、Valgrind</li>
<li><strong>开启编译器警告</strong>：检测可能的内存管理问题</li>
<li><strong>编写测试代码</strong>：验证内存管理的正确性</li>
</ul>
<p><strong>记住：如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。现代C++通过智能指针和标准容器可以完全避免这类问题。</strong></p>
<h2 id="条款17-以独立语句将-new（ed）-对象置入智能指针！"><a href="#条款17-以独立语句将-new（ed）-对象置入智能指针！" class="headerlink" title="条款17 : 以独立语句将 new（ed） 对象置入智能指针！"></a>条款17 : 以独立语句将 new（ed） 对象置入智能指针！</h2><blockquote>
<p>（Store newed objects in smart pointers in standalone statements）</p>
</blockquote>
<ul>
<li>以独立语句将 <strong>new</strong>ed对象存储于（置入）智能指针内。 如果不这样做， 一旦异常被抛出， 有可能导致难以察觉的资源泄露。</li>
</ul>
<h3 id="核心理念-16"><a href="#核心理念-16" class="headerlink" title="核心理念"></a>核心理念</h3><p>在将动态分配的对象存入智能指针时，应该使用<strong>独立语句</strong>，避免在复杂表达式中直接创建智能指针。这是为了防止在创建智能指针的过程中发生异常，导致对象没有被正确管理，从而出现资源泄露。</p>
<h4 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h4><blockquote>
<p>假设你写了一行代码，用 <code>new</code> 分配一个对象，并且直接传递给智能指针的构造函数。如果在这行代码中间发生异常（例如，智能指针的构造函数中出现异常），就可能导致对象没有被智能指针接管而泄露，导致内存泄露。因此，应该在<strong>独立语句</strong>中先用 <code>new</code> 创建对象，再将它传给智能指针。这样可以确保即使发生异常，程序也不会丢失这个对象的控制权。</p>
</blockquote>
<h3 id="深度解析-16"><a href="#深度解析-16" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-函数参数的求值顺序不确定"><a href="#1-函数参数的求值顺序不确定" class="headerlink" title="1. 函数参数的求值顺序不确定"></a>1. 函数参数的求值顺序不确定</h4><p>在 C++ 中，不同参数的求值顺序由编译器决定，不是固定的。这意味着你无法保证 <code>new</code> 表达式一定先执行，并立即被智能指针接管。</p>
<h4 id="2-异常安全性丧失-→-隐性内存泄漏"><a href="#2-异常安全性丧失-→-隐性内存泄漏" class="headerlink" title="2. 异常安全性丧失 → 隐性内存泄漏"></a>2. 异常安全性丧失 → 隐性内存泄漏</h4><p>如果在函数调用参数中写入 <code>new</code>，但在别的参数求值中抛出异常，此时 <code>new</code> 的结果并未交给智能指针，导致资源泄露。</p>
<h4 id="3-使用独立语句确保-new-的资源被立即管理"><a href="#3-使用独立语句确保-new-的资源被立即管理" class="headerlink" title="3. 使用独立语句确保 new 的资源被立即管理"></a>3. 使用独立语句确保 new 的资源被立即管理</h4><p>使用两步操作将对象交由智能指针托管，可以显式地控制资源的所有权转移过程。</p>
<h3 id="✨-推荐写法-vs-危险写法对比"><a href="#✨-推荐写法-vs-危险写法对比" class="headerlink" title="✨ 推荐写法 vs 危险写法对比"></a>✨ 推荐写法 vs 危险写法对比</h3><p>✅ <strong>推荐写法（独立语句）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">move</span>(pw));<br></code></pre></td></tr></table></figure>

<p>❌ <strong>不推荐写法（复杂表达式）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget));<br><span class="hljs-comment">// 如果 processWidget 的其他参数抛出异常，new 出来的 Widget 无人管理 → 泄漏</span><br></code></pre></td></tr></table></figure>

<h3 id="💡-拓展建议"><a href="#💡-拓展建议" class="headerlink" title="💡 拓展建议"></a>💡 拓展建议</h3><ol>
<li><p>使用 <code>std::make_unique</code>(C++14) 或 <code>std::make_shared</code></p>
<ol>
<li><p>在 C++14&#x2F;17 中，推荐使用 <code>make_unique</code> 替代 <code>new</code>，它避免了显式裸指针暴露，并确保创建和接管对象是<strong>原子操作</strong>，更安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_unique</span>&lt;Wiget&gt;();<br></code></pre></td></tr></table></figure>
</li>
<li><p>但及时使用 <code>std::make_unique</code> 或 <code>std::make_shared</code>，也要避免这样的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;(), <span class="hljs-built_in">computeSomething</span>()); <br><span class="hljs-comment">// computeSomething() 抛异常 → std::make_unique&lt;Widget&gt;() 的资源未被接管 → 浪费或泄露风险</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="🧠-小结"><a href="#🧠-小结" class="headerlink" title="🧠 小结"></a>🧠 小结</h3><p>在构造智能指针管理对象时，<strong>使用独立语句</strong>是保障异常安全的关键手段。</p>
<blockquote>
<p><strong>一句话总结</strong>：<br> <strong>不要把 <code>new</code> 写进复杂表达式里，万一异常发生，没人能帮你回收这块内存了！</strong></p>
</blockquote>
<h2 id="条款18：-让接口容易被正确使用，不易被误用"><a href="#条款18：-让接口容易被正确使用，不易被误用" class="headerlink" title="条款18： 让接口容易被正确使用，不易被误用"></a>条款18： 让接口容易被正确使用，不易被误用</h2><blockquote>
<p><em>Make interfaces easy to use correctly and hard to use incorrectly</em></p>
</blockquote>
<h3 id="核心理念-17"><a href="#核心理念-17" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质</strong>。接口设计是软件工程中最重要的技能之一，因为它直接影响代码的可维护性、可读性和错误率。”促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。”阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</p>
<h3 id="深度解析-17"><a href="#深度解析-17" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-促进正确使用的设计策略"><a href="#1-促进正确使用的设计策略" class="headerlink" title="1. 促进正确使用的设计策略"></a>1. <strong>促进正确使用的设计策略</strong></h4><p>设计接口时应该让正确的用法变得自然和直观。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 容易误用的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);  <span class="hljs-comment">// 参数顺序容易混淆</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">problemExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Date <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>;   <span class="hljs-comment">// 意图：1995年3月30日</span><br>    <span class="hljs-function">Date <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1995</span>)</span></span>;   <span class="hljs-comment">// 但参数顺序错了！实际是：30月3日1995年</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 促进正确使用的接口</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> : val(d) &#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> : val(m) &#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> : val(y) &#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BetterDate</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BetterDate</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">betterExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">BetterDate <span class="hljs-title">d1</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <span class="hljs-comment">// 清晰明确</span><br>    <span class="hljs-comment">// BetterDate d2(Day(30), Month(3), Year(1995));  // 编译错误！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-阻止误用的类型系统"><a href="#2-阻止误用的类型系统" class="headerlink" title="2. 阻止误用的类型系统"></a>2. <strong>阻止误用的类型系统</strong></h4><p>使用类型系统防止常见错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 使用原始类型容易出错</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transferMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> amount, <span class="hljs-type">int</span> fromAccount, <span class="hljs-type">int</span> toAccount)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dangerousUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">transferMoney</span>(<span class="hljs-number">1000.0</span>, <span class="hljs-number">12345</span>, <span class="hljs-number">67890</span>);  <span class="hljs-comment">// 参数顺序可能错误</span><br>    <span class="hljs-built_in">transferMoney</span>(<span class="hljs-number">-500.0</span>, <span class="hljs-number">12345</span>, <span class="hljs-number">67890</span>);  <span class="hljs-comment">// 负数金额应该被阻止</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 使用强类型防止错误</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Amount</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Amount</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span> : value_(val) &#123;</span><br>        <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Amount cannot be negative&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountId</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AccountId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> : id_(id) &#123;</span><br>        <span class="hljs-keyword">if</span> (id &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Account ID must be positive&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> id_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankTransaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transferMoney</span><span class="hljs-params">(<span class="hljs-type">const</span> Amount&amp; amount, </span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> AccountId&amp; from, </span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> AccountId&amp; to)</span> </span>&#123;<br>        <span class="hljs-comment">// 类型安全的实现</span><br>        <span class="hljs-keyword">if</span> (from.<span class="hljs-built_in">getId</span>() == to.<span class="hljs-built_in">getId</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Cannot transfer to same account&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 执行转账...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safeUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    BankTransaction bank;<br>    <span class="hljs-function">Amount <span class="hljs-title">amt</span><span class="hljs-params">(<span class="hljs-number">1000.0</span>)</span></span>;<br>    <span class="hljs-function">AccountId <span class="hljs-title">from</span><span class="hljs-params">(<span class="hljs-number">12345</span>)</span></span>;<br>    <span class="hljs-function">AccountId <span class="hljs-title">to</span><span class="hljs-params">(<span class="hljs-number">67890</span>)</span></span>;<br>    <br>    bank.<span class="hljs-built_in">transferMoney</span>(amt, from, to);  <span class="hljs-comment">// 类型安全</span><br>    <span class="hljs-comment">// bank.transferMoney(amt, to, from);  // 仍可能错误，但至少类型正确</span><br>    <span class="hljs-comment">// bank.transferMoney(Amount(-500), from, to);  // 运行时错误，但被检测到</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-接口一致性"><a href="#3-接口一致性" class="headerlink" title="3. 接口一致性"></a>3. <strong>接口一致性</strong></h4><p>保持接口在整个系统中的一致性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 不一致的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InconsistentContainer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;        <span class="hljs-comment">// 返回size_t</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;         <span class="hljs-comment">// 返回int，名称不一致</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 非const，行为不一致</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// void返回</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>; <span class="hljs-comment">// bool返回</span><br>&#125;;<br><br><span class="hljs-comment">// ✅ 一致的接口设计</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentContainer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 一致的命名约定</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">// 一致的返回类型约定</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-comment">// 一致的const正确性</span><br>    <span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-comment">// 一致的异常处理策略</span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index);          <span class="hljs-comment">// 不检查边界</span><br>    <span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>;                  <span class="hljs-comment">// 检查边界，抛出异常</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-消除客户的资源管理责任"><a href="#4-消除客户的资源管理责任" class="headerlink" title="4. 消除客户的资源管理责任"></a>4. <strong>消除客户的资源管理责任</strong></h4><p>让接口自动管理资源，减少客户端错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 要求客户管理资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Widget* <span class="hljs-title">createWidget</span><span class="hljs-params">(WidgetType type)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(type);  <span class="hljs-comment">// 客户需要记住delete</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">riskyClientCode</span><span class="hljs-params">()</span> </span>&#123;<br>    Widget* w = BadFactory::<span class="hljs-built_in">createWidget</span>(WidgetType::Button);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">someCondition</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// ❌ 忘记delete，内存泄漏</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">delete</span> w;  <span class="hljs-comment">// 客户必须记住这个</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 自动资源管理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::unique_ptr&lt;Widget&gt; <span class="hljs-title">createWidget</span><span class="hljs-params">(WidgetType type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;(type);  <span class="hljs-comment">// 自动管理 (C++14)</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Widget&gt; <span class="hljs-title">createSharedWidget</span><span class="hljs-params">(WidgetType type)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(type);  <span class="hljs-comment">// 共享所有权</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safeClientCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> w = GoodFactory::<span class="hljs-built_in">createWidget</span>(WidgetType::Button);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">someCondition</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// ✅ 自动清理，无泄漏</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 作用域结束时自动清理</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-限制对象值和操作"><a href="#5-限制对象值和操作" class="headerlink" title="5. 限制对象值和操作"></a>5. <strong>限制对象值和操作</strong></h4><p>通过设计限制无效的操作和值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 月份类：限制有效值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Mar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">3</span>); &#125;<br>    <span class="hljs-comment">// ... 其他月份</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> month_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> : month_(m) &#123;</span>&#125;  <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-type">int</span> month_;<br>&#125;;<br><br><span class="hljs-comment">// 线程安全的单例：限制实例数量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeConfig</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ThreadSafeConfig&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> ThreadSafeConfig instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">ThreadSafeConfig</span>(<span class="hljs-type">const</span> ThreadSafeConfig&amp;) = <span class="hljs-keyword">delete</span>;<br>    ThreadSafeConfig&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadSafeConfig&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSetting</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key, <span class="hljs-type">const</span> std::string&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        settings_[key] = value;<br>    &#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">getSetting</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">auto</span> it = settings_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">return</span> (it != settings_.<span class="hljs-built_in">end</span>()) ? it-&gt;second : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">ThreadSafeConfig</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-keyword">mutable</span> std::mutex mutex_;<br>    std::map&lt;std::string, std::string&gt; settings_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-自定义删除器和RAII"><a href="#6-自定义删除器和RAII" class="headerlink" title="6. 自定义删除器和RAII"></a>6. <strong>自定义删除器和RAII</strong></h4><p>使用智能指针的自定义删除器解决特殊资源管理问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理C API资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileManager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> FilePtr = std::unique_ptr&lt;FILE, <span class="hljs-built_in">int</span>(*)(FILE*)&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> FilePtr <span class="hljs-title">openFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span> </span>&#123;<br>        FILE* file = <span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), mode);<br>        <span class="hljs-keyword">if</span> (!file) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file: &quot;</span> + filename);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">FilePtr</span>(file, fclose);  <span class="hljs-comment">// 自动调用fclose</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 处理系统资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MutexManager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> MutexPtr = std::unique_ptr&lt;std::mutex, <span class="hljs-built_in">void</span>(*)(std::mutex*)&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> MutexPtr <span class="hljs-title">createMutex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">MutexPtr</span>(<br>            <span class="hljs-keyword">new</span> std::mutex,<br>            [](std::mutex* m) &#123; <span class="hljs-keyword">delete</span> m; &#125;<br>        );<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 处理网络连接</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ConnectionDeleter</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Connection* conn)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (conn) &#123;<br>                conn-&gt;<span class="hljs-built_in">close</span>();     <span class="hljs-comment">// 确保连接被关闭</span><br>                <span class="hljs-keyword">delete</span> conn;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ConnectionPtr = std::unique_ptr&lt;Connection, ConnectionDeleter&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> ConnectionPtr <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port)</span> </span>&#123;<br>        Connection* conn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>(host, port);<br>        <span class="hljs-keyword">if</span> (!conn-&gt;<span class="hljs-built_in">isConnected</span>()) &#123;<br>            <span class="hljs-keyword">delete</span> conn;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to connect&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ConnectionPtr</span>(conn);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="7-错误处理的接口设计"><a href="#7-错误处理的接口设计" class="headerlink" title="7. 错误处理的接口设计"></a>7. <strong>错误处理的接口设计</strong></h4><p>设计清晰的错误处理机制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 不明确的错误处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadParser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input, Result&amp; result)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回bool，但不知道具体错误</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 明确的错误处理</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ParseError</span> &#123;<br>    None,<br>    InvalidFormat,<br>    MissingField,<br>    TypeMismatch,<br>    OutOfRange<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseResult</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::optional&lt;T&gt; value_;  <span class="hljs-comment">// C++17</span><br>    ParseError error_;<br>    std::string errorMessage_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ParseResult</span>(T value) : <span class="hljs-built_in">value_</span>(std::<span class="hljs-built_in">move</span>(value)), <span class="hljs-built_in">error_</span>(ParseError::None) &#123;&#125;<br>    <br>    <span class="hljs-built_in">ParseResult</span>(ParseError error, std::string message) <br>        : <span class="hljs-built_in">error_</span>(error), <span class="hljs-built_in">errorMessage_</span>(std::<span class="hljs-built_in">move</span>(message)) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSuccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_.<span class="hljs-built_in">has_value</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_.<span class="hljs-built_in">value</span>(); &#125;<br>    <span class="hljs-function">ParseError <span class="hljs-title">getError</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> error_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getErrorMessage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> errorMessage_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodParser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ParseResult&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">size_t</span> pos;<br>            <span class="hljs-type">int</span> result = std::<span class="hljs-built_in">stoi</span>(input, &amp;pos);<br>            <span class="hljs-keyword">if</span> (pos != input.<span class="hljs-built_in">length</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">ParseResult</span>&lt;<span class="hljs-type">int</span>&gt;(ParseError::InvalidFormat, <br>                                      <span class="hljs-string">&quot;Extra characters after number&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ParseResult</span>&lt;<span class="hljs-type">int</span>&gt;(result);<br>        &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp;) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ParseResult</span>&lt;<span class="hljs-type">int</span>&gt;(ParseError::InvalidFormat, <br>                                  <span class="hljs-string">&quot;Not a valid number&quot;</span>);<br>        &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range&amp;) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ParseResult</span>&lt;<span class="hljs-type">int</span>&gt;(ParseError::OutOfRange, <br>                                  <span class="hljs-string">&quot;Number too large&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><strong>促进正确使用的策略：</strong></p>
<ul>
<li><strong>类型安全</strong>：使用强类型防止参数错误</li>
<li><strong>接口一致性</strong>：在整个系统中保持命名和行为一致</li>
<li><strong>符合直觉</strong>：让接口行为符合用户期望</li>
<li><strong>提供便利</strong>：减少样板代码和重复操作</li>
</ul>
<p><strong>阻止误用的技术：</strong></p>
<ul>
<li><strong>限制值域</strong>：只允许有效的值和操作</li>
<li><strong>编译时检查</strong>：利用类型系统在编译时发现错误</li>
<li><strong>运行时验证</strong>：在必要时进行运行时检查</li>
<li><strong>资源自动管理</strong>：使用RAII和智能指针</li>
</ul>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>最小惊讶原则</strong>：接口行为应该符合用户期望</li>
<li><strong>渐进式披露</strong>：提供简单的默认用法和高级选项</li>
<li><strong>失败快速原则</strong>：尽早检测和报告错误</li>
<li><strong>正交性</strong>：独立的功能应该独立设计</li>
</ul>
<p><strong>现代C++工具：</strong></p>
<ul>
<li><strong>智能指针</strong>：自动资源管理</li>
<li><strong>RAII</strong>：确保资源正确释放</li>
<li><strong>类型系统</strong>：编译时错误检测</li>
<li><strong>标准库容器</strong>：避免手动内存管理</li>
</ul>
<p><strong>记住：好的接口很容易被正确使用，不容易被误用。通过类型安全、接口一致性、自动资源管理和明确的错误处理，可以显著提高代码质量和用户体验。</strong></p>
<h2 id="条款19：-设计class犹如设计type"><a href="#条款19：-设计class犹如设计type" class="headerlink" title="条款19： 设计class犹如设计type"></a>条款19： 设计class犹如设计type</h2><blockquote>
<p><em>Treat class design as type design</em></p>
</blockquote>
<h3 id="核心理念-18"><a href="#核心理念-18" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>Class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题</strong>。设计类就像设计内置类型一样，需要考虑对象的创建、销毁、初始化、赋值、拷贝、移动、类型转换、操作符重载、内存管理、继承关系等各个方面。一个好的类设计应该具有清晰的语义、一致的接口、正确的资源管理和合理的性能特征。</p>
<h3 id="深度解析-18"><a href="#深度解析-18" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-新type的对象应该如何被创建和销毁？"><a href="#1-新type的对象应该如何被创建和销毁？" class="headerlink" title="1. 新type的对象应该如何被创建和销毁？"></a>1. <strong>新type的对象应该如何被创建和销毁？</strong></h4><p>考虑对象的完整生命周期管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernString</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">size_t</span> capacity_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">ModernString</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 参数构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ModernString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;<br>        size_ = <span class="hljs-built_in">strlen</span>(str);<br>        capacity_ = size_ + <span class="hljs-number">1</span>;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[capacity_];<br>        <span class="hljs-built_in">strcpy</span>(data_, str);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ModernString</span>(<span class="hljs-type">const</span> ModernString&amp; other) <br>        : <span class="hljs-built_in">size_</span>(other.size_), <span class="hljs-built_in">capacity_</span>(other.capacity_) &#123;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[capacity_];<br>        <span class="hljs-built_in">strcpy</span>(data_, other.data_);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ModernString</span>(ModernString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">data_</span>(other.data_), <span class="hljs-built_in">size_</span>(other.size_), <span class="hljs-built_in">capacity_</span>(other.capacity_) &#123;<br>        other.data_ = <span class="hljs-literal">nullptr</span>;<br>        other.size_ = other.capacity_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">ModernString</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义内存管理（可选）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Custom new for ModernString&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Custom delete for ModernString&quot;</span> &lt;&lt; std::endl;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-对象初始化与赋值有何区别？"><a href="#2-对象初始化与赋值有何区别？" class="headerlink" title="2. 对象初始化与赋值有何区别？"></a>2. <strong>对象初始化与赋值有何区别？</strong></h4><p>明确区分初始化和赋值的语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; data_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：负责初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Resource</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> : size_(size) &#123;</span><br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource initialized with size &quot;</span> &lt;&lt; size_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数：初始化新对象</span><br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp; other) : <span class="hljs-built_in">size_</span>(other.size_) &#123;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::<span class="hljs-built_in">copy</span>(other.data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>() + size_, data_.<span class="hljs-built_in">get</span>());<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource copy-initialized&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 赋值运算符：修改已存在的对象</span><br>    Resource&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Resource&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource assigned&quot;</span> &lt;&lt; std::endl;<br>        <br>        <span class="hljs-comment">// 重新分配资源</span><br>        size_ = other.size_;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(size_);<br>        std::<span class="hljs-built_in">copy</span>(other.data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>() + size_, data_.<span class="hljs-built_in">get</span>());<br>        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    Resource&amp; <span class="hljs-keyword">operator</span>=(Resource&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource move-assigned&quot;</span> &lt;&lt; std::endl;<br>        <br>        data_ = std::<span class="hljs-built_in">move</span>(other.data_);<br>        size_ = other.size_;<br>        other.size_ = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateInitializationVsAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Resource <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;        <span class="hljs-comment">// 初始化</span><br>    Resource r2 = r1;       <span class="hljs-comment">// 拷贝初始化（调用拷贝构造函数）</span><br>    <span class="hljs-function">Resource <span class="hljs-title">r3</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;         <span class="hljs-comment">// 初始化</span><br>    r3 = r1;               <span class="hljs-comment">// 赋值（调用赋值运算符）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-新type的对象如果被passed-by-value，意味着什么？"><a href="#3-新type的对象如果被passed-by-value，意味着什么？" class="headerlink" title="3. 新type的对象如果被passed by value，意味着什么？"></a>3. <strong>新type的对象如果被passed by value，意味着什么？</strong></h4><p>考虑拷贝语义和性能影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpensiveObject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data_;<br>    std::string name_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ExpensiveObject</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">size_t</span> size) <br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">data_</span>(size, <span class="hljs-number">0.0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; with &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; elements&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数：按值传递时被调用</span><br>    <span class="hljs-built_in">ExpensiveObject</span>(<span class="hljs-type">const</span> ExpensiveObject&amp; other) <br>        : <span class="hljs-built_in">name_</span>(other.name_ + <span class="hljs-string">&quot;_copy&quot;</span>), <span class="hljs-built_in">data_</span>(other.data_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copied &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数：移动语义优化</span><br>    <span class="hljs-built_in">ExpensiveObject</span>(ExpensiveObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(other.name_)), <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(other.data_)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Moved &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">size</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// ❌ 按值传递：昂贵的拷贝</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processExpensiveByValue</span><span class="hljs-params">(ExpensiveObject obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Processing &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// ✅ 按引用传递：避免拷贝</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processExpensiveByReference</span><span class="hljs-params">(<span class="hljs-type">const</span> ExpensiveObject&amp; obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Processing &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot; (by reference)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// ✅ 移动语义：高效的所有权转移</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processExpensiveByMove</span><span class="hljs-params">(ExpensiveObject obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Processing moved &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstratePassByValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ExpensiveObject <span class="hljs-title">original</span><span class="hljs-params">(<span class="hljs-string">&quot;BigData&quot;</span>, <span class="hljs-number">1000000</span>)</span></span>;<br>    <br>    <span class="hljs-built_in">processExpensiveByValue</span>(original);        <span class="hljs-comment">// 触发拷贝</span><br>    <span class="hljs-built_in">processExpensiveByReference</span>(original);    <span class="hljs-comment">// 无拷贝</span><br>    <span class="hljs-built_in">processExpensiveByMove</span>(std::<span class="hljs-built_in">move</span>(original)); <span class="hljs-comment">// 移动</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-什么是新type的合法值？"><a href="#4-什么是新type的合法值？" class="headerlink" title="4. 什么是新type的合法值？"></a>4. <strong>什么是新type的合法值？</strong></h4><p>定义值域和不变量约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> celsius_;<br>    <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> ABSOLUTE_ZERO = <span class="hljs-number">-273.15</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> MAX_TEMP = <span class="hljs-number">1000000.0</span>; <span class="hljs-comment">// 实用上限</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Temperature</span><span class="hljs-params">(<span class="hljs-type">double</span> celsius = <span class="hljs-number">0.0</span>)</span> : celsius_(celsius) &#123;</span><br>        <span class="hljs-keyword">if</span> (celsius &lt; ABSOLUTE_ZERO) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Temperature cannot be below absolute zero&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (celsius &gt; MAX_TEMP) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Temperature too high&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 访问器</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">celsius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> celsius_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fahrenheit</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> celsius_ * <span class="hljs-number">9.0</span> / <span class="hljs-number">5.0</span> + <span class="hljs-number">32.0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">kelvin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> celsius_ + <span class="hljs-number">273.15</span>; &#125;<br>    <br>    <span class="hljs-comment">// 修改器：维护不变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCelsius</span><span class="hljs-params">(<span class="hljs-type">double</span> celsius)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (celsius &lt; ABSOLUTE_ZERO || celsius &gt; MAX_TEMP) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid temperature value&quot;</span>);<br>        &#125;<br>        celsius_ = celsius;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 操作符：确保结果有效</span><br>    Temperature <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Temperature&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Temperature</span>(celsius_ + other.celsius_);<br>    &#125;<br>    <br>    Temperature <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Temperature&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Temperature</span>(celsius_ - other.celsius_);<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Temperature&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> celsius_ &lt; other.celsius_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateValidValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">Temperature <span class="hljs-title">room</span><span class="hljs-params">(<span class="hljs-number">20.0</span>)</span></span>;           <span class="hljs-comment">// ✅ 有效</span><br>        Temperature hot = room + <span class="hljs-built_in">Temperature</span>(<span class="hljs-number">50.0</span>); <span class="hljs-comment">// ✅ 有效运算</span><br>        <br>        <span class="hljs-comment">// Temperature invalid(-300.0);  // ❌ 抛出异常</span><br>        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Room: &quot;</span> &lt;&lt; room.<span class="hljs-built_in">celsius</span>() &lt;&lt; <span class="hljs-string">&quot;°C&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hot: &quot;</span> &lt;&lt; hot.<span class="hljs-built_in">fahrenheit</span>() &lt;&lt; <span class="hljs-string">&quot;°F&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-新type需要配合某个继承图系吗？"><a href="#5-新type需要配合某个继承图系吗？" class="headerlink" title="5. 新type需要配合某个继承图系吗？"></a>5. <strong>新type需要配合某个继承图系吗？</strong></h4><p>考虑继承关系和多态设计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类：定义接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string name_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Shape</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> : name_(name) &#123;</span>&#125;<br>    <br>    <span class="hljs-comment">// 虚析构函数：支持多态销毁</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 纯虚函数：定义接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 非虚函数：公共功能</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <br>    <span class="hljs-comment">// 模板方法模式</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shape: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Area: &quot;</span> &lt;&lt; <span class="hljs-built_in">area</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Perimeter: &quot;</span> &lt;&lt; <span class="hljs-built_in">perimeter</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">draw</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类：具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> </span><br><span class="hljs-function">        : Shape(<span class="hljs-string">&quot;Circle&quot;</span>), radius_(radius) &#123;</span><br>        <span class="hljs-keyword">if</span> (radius &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Radius must be positive&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius_ * radius_;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">3.14159</span> * radius_;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing circle with radius &quot;</span> &lt;&lt; radius_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> radius_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height) <br>        : <span class="hljs-built_in">Shape</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>), <span class="hljs-built_in">width_</span>(width), <span class="hljs-built_in">height_</span>(height) &#123;<br>        <span class="hljs-keyword">if</span> (width &lt;= <span class="hljs-number">0</span> || height &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Dimensions must be positive&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> width_ * height_;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (width_ + height_);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing rectangle &quot;</span> &lt;&lt; width_ &lt;&lt; <span class="hljs-string">&quot;x&quot;</span> &lt;&lt; height_ &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateInheritance</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;<br>    shapes.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Circle&gt;(<span class="hljs-number">5.0</span>));<br>    shapes.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Rectangle&gt;(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) &#123;<br>        shape-&gt;<span class="hljs-built_in">display</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;---&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-新type需要什么类型的转换？"><a href="#6-新type需要什么类型的转换？" class="headerlink" title="6. 新type需要什么类型的转换？"></a>6. <strong>新type需要什么类型的转换？</strong></h4><p>设计类型转换的策略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Money</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cents_;  <span class="hljs-comment">// 以分为单位存储，避免浮点精度问题</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 显式构造：防止意外转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Money</span><span class="hljs-params">(<span class="hljs-type">double</span> dollars)</span> : cents_(static_cast&lt;int&gt;(dollars * <span class="hljs-number">100</span>)) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Money</span><span class="hljs-params">(<span class="hljs-type">int</span> cents)</span> : cents_(cents) &#123;</span>&#125;<br>    <br>    <span class="hljs-comment">// 访问器</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dollars</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cents_ / <span class="hljs-number">100.0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cents</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cents_; &#125;<br>    <br>    <span class="hljs-comment">// 显式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">dollars</span>(); &#125;<br>    <br>    <span class="hljs-comment">// 隐式转换到bool（用于条件判断）</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cents_ != <span class="hljs-number">0</span>; &#125;<br>    <br>    <span class="hljs-comment">// 运算符重载</span><br>    Money <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Money&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Money</span>(cents_ + other.cents_);<br>    &#125;<br>    <br>    Money&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Money&amp; other) &#123;<br>        cents_ += other.cents_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Money&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> cents_ == other.cents_;<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Money&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> cents_ &lt; other.cents_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 相关的非成员函数</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Money&amp; money) &#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;$&quot;</span> &lt;&lt; money.<span class="hljs-built_in">dollars</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateTypeConversion</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Money <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-number">10.50</span>)</span></span>;  <span class="hljs-comment">// explicit构造</span><br>    <span class="hljs-function">Money <span class="hljs-title">m2</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span></span>;   <span class="hljs-comment">// 1000分 = $10.00</span><br>    <br>    Money total = m1 + m2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 显式转换</span><br>    <span class="hljs-type">double</span> amount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(total);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Amount: &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 条件判断</span><br>    <span class="hljs-keyword">if</span> (total) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Total is non-zero&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><strong>设计类时需要考虑的12个问题：</strong></p>
<ol>
<li><strong>创建和销毁</strong>：构造函数、析构函数、内存管理</li>
<li><strong>初始化vs赋值</strong>：拷贝构造函数vs赋值运算符</li>
<li><strong>值传递语义</strong>：拷贝构造函数的性能和正确性</li>
<li><strong>合法值域</strong>：不变量、约束条件、错误处理</li>
<li><strong>继承关系</strong>：是否需要虚函数、多态设计</li>
<li><strong>类型转换</strong>：隐式vs显式转换、转换运算符</li>
<li><strong>操作符和函数</strong>：成员vs非成员、运算符重载</li>
<li><strong>禁用操作</strong>：&#x3D;delete、private声明</li>
<li><strong>访问控制</strong>：public&#x2F;protected&#x2F;private、friend</li>
<li><strong>隐含接口</strong>：异常安全、资源管理、性能保证</li>
<li><strong>泛化程度</strong>：是否需要模板化</li>
<li><strong>必要性</strong>：是否真的需要新类型</li>
</ol>
<p><strong>现代C++设计原则：</strong></p>
<ul>
<li><strong>RAII</strong>：资源获取即初始化</li>
<li><strong>Rule of Zero&#x2F;Three&#x2F;Five</strong>：明确拷贝&#x2F;移动语义</li>
<li><strong>强类型</strong>：使用类型系统防止错误</li>
<li><strong>异常安全</strong>：提供异常安全保证</li>
<li><strong>const正确性</strong>：合理使用const</li>
<li><strong>移动语义</strong>：支持高效的资源转移</li>
</ul>
<p><strong>记住：Class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过所有相关的设计决策。一个好的类设计应该具有清晰的语义、一致的接口、正确的资源管理和合理的性能特征。</strong> </p>
<h2 id="条款20：-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20： 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20： 宁以pass-by-reference-to-const替换pass-by-value</h2><blockquote>
<p><em>Prefer pass-by-reference-to-const to pass-by-value</em></p>
</blockquote>
<h3 id="核心理念-19"><a href="#核心理念-19" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）</strong>。但这个规则并不适用于内置类型、以及STL的迭代器和函数对象，对它们而言，pass-by-value往往比较恰当。选择正确的参数传递方式对程序性能和正确性都有重要影响。</p>
<h3 id="深度解析-19"><a href="#深度解析-19" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-切割问题的严重性"><a href="#1-切割问题的严重性" class="headerlink" title="1. 切割问题的严重性"></a>1. <strong>切割问题的严重性</strong></h4><p>当派生类对象按值传递时，只会复制基类部分，导致多态行为丢失。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Window</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Window</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying window: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Window&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    std::string name_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span> : <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string specialFeature_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpecialWindow</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; feature) <br>        : <span class="hljs-built_in">Window</span>(name), <span class="hljs-built_in">specialFeature_</span>(feature) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying special window: &quot;</span> &lt;&lt; name_ <br>                  &lt;&lt; <span class="hljs-string">&quot; with feature: &quot;</span> &lt;&lt; specialFeature_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SpecialWindow&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getSpecialFeature</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> specialFeature_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ❌ 按值传递：发生切割</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWindowByValue</span><span class="hljs-params">(Window w)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Type: &quot;</span> &lt;&lt; w.<span class="hljs-built_in">getType</span>() &lt;&lt; std::endl;<br>    w.<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 总是调用Window::display()，丢失多态性</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 按引用传递：保持多态性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWindowByReference</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Type: &quot;</span> &lt;&lt; w.<span class="hljs-built_in">getType</span>() &lt;&lt; std::endl;<br>    w.<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 正确调用派生类的版本</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSlicing</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SpecialWindow <span class="hljs-title">sw</span><span class="hljs-params">(<span class="hljs-string">&quot;MainWindow&quot;</span>, <span class="hljs-string">&quot;ResizableFrame&quot;</span>)</span></span>;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== Pass by value (slicing occurs) ===&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">printWindowByValue</span>(sw);    <span class="hljs-comment">// 切割：只保留Window部分</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n=== Pass by reference (no slicing) ===&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">printWindowByReference</span>(sw); <span class="hljs-comment">// 保持完整对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-性能差异的量化分析"><a href="#2-性能差异的量化分析" class="headerlink" title="2. 性能差异的量化分析"></a>2. <strong>性能差异的量化分析</strong></h4><p>大对象的拷贝开销可能非常昂贵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data_;<br>    std::string description_;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; metadata_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LargeObject</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function">        : data_(size, <span class="hljs-number">3.14159</span>), </span><br><span class="hljs-function">          description_(<span class="hljs-string">&quot;Large object with &quot;</span> + std::to_string(size) + <span class="hljs-string">&quot; elements&quot;</span>) &#123;</span><br>        <br>        <span class="hljs-comment">// 添加一些元数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>            metadata_[<span class="hljs-string">&quot;key&quot;</span> + std::<span class="hljs-built_in">to_string</span>(i)] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数：显示拷贝开销</span><br>    <span class="hljs-built_in">LargeObject</span>(<span class="hljs-type">const</span> LargeObject&amp; other) <br>        : <span class="hljs-built_in">data_</span>(other.data_), <br>          <span class="hljs-built_in">description_</span>(other.description_), <br>          <span class="hljs-built_in">metadata_</span>(other.metadata_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Expensive copy of LargeObject with &quot;</span> <br>                  &lt;&lt; data_.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; elements&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">size</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> description_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">computeSum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(data_.<span class="hljs-built_in">begin</span>(), data_.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0.0</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ❌ 按值传递：昂贵的拷贝</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">processLargeObjectByValue</span><span class="hljs-params">(LargeObject obj)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">computeSum</span>();<br>&#125;<br><br><span class="hljs-comment">// ✅ 按引用传递：无拷贝开销</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">processLargeObjectByReference</span><span class="hljs-params">(<span class="hljs-type">const</span> LargeObject&amp; obj)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">computeSum</span>();<br>&#125;<br><br><span class="hljs-comment">// 性能测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performanceComparison</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">LargeObject <span class="hljs-title">bigObj</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;  <span class="hljs-comment">// 100万个元素</span><br>    <br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">double</span> result1 = <span class="hljs-built_in">processLargeObjectByValue</span>(bigObj);  <span class="hljs-comment">// 触发昂贵拷贝</span><br>    <span class="hljs-keyword">auto</span> mid = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">double</span> result2 = <span class="hljs-built_in">processLargeObjectByReference</span>(bigObj);  <span class="hljs-comment">// 无拷贝</span><br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <br>    <span class="hljs-keyword">auto</span> copyTime = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(mid - start);<br>    <span class="hljs-keyword">auto</span> refTime = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - mid);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Pass by value time: &quot;</span> &lt;&lt; copyTime.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; μs&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Pass by reference time: &quot;</span> &lt;&lt; refTime.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; μs&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Performance ratio: &quot;</span> &lt;&lt; copyTime.<span class="hljs-built_in">count</span>() / (<span class="hljs-type">double</span>)refTime.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;x&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-内置类型和小对象的例外"><a href="#3-内置类型和小对象的例外" class="headerlink" title="3. 内置类型和小对象的例外"></a>3. <strong>内置类型和小对象的例外</strong></h4><p>对于内置类型、迭代器和小对象，按值传递通常更好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 内置类型：按值传递更自然</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>&#125;<br><br><span class="hljs-comment">// ✅ 小对象：按值传递通常没问题</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point2D</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>    <br>    <span class="hljs-built_in">Point2D</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>    <br>    Point2D <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point2D&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point2D</span>(x + other.x, y + other.y);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Point2D <span class="hljs-title">calculateMidpoint</span><span class="hljs-params">(Point2D p1, Point2D p2)</span> </span>&#123;  <span class="hljs-comment">// 按值传递小对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point2D</span>((p<span class="hljs-number">1.</span>x + p<span class="hljs-number">2.</span>x) / <span class="hljs-number">2</span>, (p<span class="hljs-number">1.</span>y + p<span class="hljs-number">2.</span>y) / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// ✅ STL迭代器：按值传递</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">typename</span> Iterator::value_type <span class="hljs-title">findMax</span><span class="hljs-params">(Iterator first, Iterator last)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (first == last) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Empty range&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">auto</span> maxVal = *first;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = first; it != last; ++it) &#123;<br>        <span class="hljs-keyword">if</span> (*it &gt; maxVal) &#123;<br>            maxVal = *it;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxVal;<br>&#125;<br><br><span class="hljs-comment">// ✅ 函数对象：通常按值传递</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Predicate&gt;</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">filterVector</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; vec, Predicate pred)</span> </span>&#123;<br>    std::vector&lt;T&gt; result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : vec) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pred</span>(item)) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(item);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateBuiltinTypes</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 内置类型</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">addNumbers</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">double</span> product = <span class="hljs-built_in">multiply</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">2.0</span>);<br>    <br>    <span class="hljs-comment">// 小对象</span><br>    <span class="hljs-function">Point2D <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point2D <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    Point2D mid = <span class="hljs-built_in">calculateMidpoint</span>(p1, p2);<br>    <br>    <span class="hljs-comment">// STL迭代器</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> maxNum = <span class="hljs-built_in">findMax</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 函数对象</span><br>    <span class="hljs-keyword">auto</span> filtered = <span class="hljs-built_in">filterVector</span>(numbers, [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">3</span>; &#125;);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot;, Product: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Midpoint: (&quot;</span> &lt;&lt; mid.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; mid.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max: &quot;</span> &lt;&lt; maxNum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-引用传递的实现细节"><a href="#4-引用传递的实现细节" class="headerlink" title="4. 引用传递的实现细节"></a>4. <strong>引用传递的实现细节</strong></h4><p>引用在底层通常实现为指针，但语法更安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">double</span>&gt;&gt; data_;<br>    <span class="hljs-type">size_t</span> rows_, cols_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">size_t</span> rows, <span class="hljs-type">size_t</span> cols) <br>        : <span class="hljs-built_in">rows_</span>(rows), <span class="hljs-built_in">cols_</span>(cols), <span class="hljs-built_in">data_</span>(rows, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(cols, <span class="hljs-number">0.0</span>)) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">double</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> row, <span class="hljs-type">size_t</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data_[row][col];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> row, <span class="hljs-type">size_t</span> col)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data_[row][col];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rows</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rows_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">cols</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cols_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 引用传递：高效且类型安全</span><br><span class="hljs-function">Matrix <span class="hljs-title">multiplyMatrices</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; a, <span class="hljs-type">const</span> Matrix&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">cols</span>() != b.<span class="hljs-built_in">rows</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Matrix dimensions don&#x27;t match&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function">Matrix <span class="hljs-title">result</span><span class="hljs-params">(a.rows(), b.cols())</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">rows</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; b.<span class="hljs-built_in">cols</span>(); ++j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> k = <span class="hljs-number">0</span>; k &lt; a.<span class="hljs-built_in">cols</span>(); ++k) &#123;<br>                result.<span class="hljs-built_in">at</span>(i, j) += a.<span class="hljs-built_in">at</span>(i, k) * b.<span class="hljs-built_in">at</span>(k, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// ❌ 指针传递：容易出错</span><br><span class="hljs-function">Matrix <span class="hljs-title">multiplyMatricesWithPointers</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix* a, <span class="hljs-type">const</span> Matrix* b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!a || !b) &#123;  <span class="hljs-comment">// 需要检查空指针</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Null matrix pointer&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (a-&gt;<span class="hljs-built_in">cols</span>() != b-&gt;<span class="hljs-built_in">rows</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Matrix dimensions don&#x27;t match&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实现相同，但语法更复杂且容易出错</span><br>    <span class="hljs-function">Matrix <span class="hljs-title">result</span><span class="hljs-params">(a-&gt;rows(), b-&gt;cols())</span></span>;<br>    <span class="hljs-comment">// ... 矩阵乘法实现</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-const引用的重要性"><a href="#5-const引用的重要性" class="headerlink" title="5. const引用的重要性"></a>5. <strong>const引用的重要性</strong></h4><p>使用const引用表明函数不会修改参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string content_;<br>    std::string title_;<br>    std::vector&lt;std::string&gt; tags_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Document</span>(<span class="hljs-type">const</span> std::string&amp; title, <span class="hljs-type">const</span> std::string&amp; content) <br>        : <span class="hljs-built_in">title_</span>(title), <span class="hljs-built_in">content_</span>(content) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTag</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; tag)</span> </span>&#123;<br>        tags_.<span class="hljs-built_in">push_back</span>(tag);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getTitle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> title_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> content_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; <span class="hljs-title">getTags</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tags_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getWordCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(content_)</span></span>;<br>        std::string word;<br>        <span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (iss &gt;&gt; word) &#123;<br>            ++count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ const引用：明确表示只读操作</span><br><span class="hljs-function">std::string <span class="hljs-title">generateSummary</span><span class="hljs-params">(<span class="hljs-type">const</span> Document&amp; doc)</span> </span>&#123;<br>    std::ostringstream summary;<br>    summary &lt;&lt; <span class="hljs-string">&quot;Title: &quot;</span> &lt;&lt; doc.<span class="hljs-built_in">getTitle</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    summary &lt;&lt; <span class="hljs-string">&quot;Word count: &quot;</span> &lt;&lt; doc.<span class="hljs-built_in">getWordCount</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    summary &lt;&lt; <span class="hljs-string">&quot;Tags: &quot;</span>;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tags = doc.<span class="hljs-built_in">getTags</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; tags.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) summary &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        summary &lt;&lt; tags[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> summary.<span class="hljs-built_in">str</span>();<br>&#125;<br><br><span class="hljs-comment">// ❌ 非const引用：误导性，暗示可能修改</span><br><span class="hljs-function">std::string <span class="hljs-title">generateSummaryMisleading</span><span class="hljs-params">(Document&amp; doc)</span> </span>&#123;  <span class="hljs-comment">// 不应该需要非const</span><br>    <span class="hljs-comment">// 实现相同，但接口暗示可能修改doc</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateSummary</span>(doc);<br>&#125;<br><br><span class="hljs-comment">// ✅ 区分只读和修改操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processDocument</span><span class="hljs-params">(Document&amp; doc)</span> </span>&#123;  <span class="hljs-comment">// 非const：会修改</span><br>    doc.<span class="hljs-built_in">addTag</span>(<span class="hljs-string">&quot;processed&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">analyzeDocument</span><span class="hljs-params">(<span class="hljs-type">const</span> Document&amp; doc)</span> </span>&#123;  <span class="hljs-comment">// const：只读分析</span><br>    <span class="hljs-keyword">return</span> doc.<span class="hljs-built_in">getWordCount</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-现代C-的参数传递最佳实践"><a href="#6-现代C-的参数传递最佳实践" class="headerlink" title="6. 现代C++的参数传递最佳实践"></a>6. <strong>现代C++的参数传递最佳实践</strong></h4><p>结合移动语义和完美转发的现代技巧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; items_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 对于复制：使用const引用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> </span>&#123;<br>        items_.<span class="hljs-built_in">push_back</span>(item);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 对于移动：使用右值引用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(T&amp;&amp; item)</span> </span>&#123;<br>        items_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(item));<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 完美转发：统一处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">emplaceItem</span><span class="hljs-params">(U&amp;&amp; item)</span> </span>&#123;<br>        items_.<span class="hljs-built_in">emplace_back</span>(std::forward&lt;U&gt;(item));<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 只读访问：const引用</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> items_.<span class="hljs-built_in">at</span>(index);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 修改访问：非const引用</span><br>    <span class="hljs-function">T&amp; <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> items_.<span class="hljs-built_in">at</span>(index);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> items_.<span class="hljs-built_in">size</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateModernPassing</span><span class="hljs-params">()</span> </span>&#123;<br>    Container&lt;std::string&gt; container;<br>    <br>    std::string str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    container.<span class="hljs-built_in">addItem</span>(str1);                    <span class="hljs-comment">// 拷贝</span><br>    container.<span class="hljs-built_in">addItem</span>(<span class="hljs-string">&quot;World&quot;</span>);                 <span class="hljs-comment">// 移动（从临时对象）</span><br>    container.<span class="hljs-built_in">emplaceItem</span>(<span class="hljs-string">&quot;Perfect&quot;</span>);           <span class="hljs-comment">// 完美转发</span><br>    <br>    <span class="hljs-comment">// 只读访问</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; first = container.<span class="hljs-built_in">getItem</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First item: &quot;</span> &lt;&lt; first &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-性能测量和选择指南"><a href="#7-性能测量和选择指南" class="headerlink" title="7. 性能测量和选择指南"></a>7. <strong>性能测量和选择指南</strong></h4><p>如何决定使用哪种传递方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 测量对象大小的工具</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">analyzeType</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Type: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T) &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Recommended: &quot;</span>;<br>    <br>    <span class="hljs-keyword">if</span> (std::is_fundamental_v&lt;T&gt; || <span class="hljs-built_in">sizeof</span>(T) &lt;= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Pass by value&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Pass by const reference&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateTypeAnalysis</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">analyzeType</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    <span class="hljs-built_in">analyzeType</span>&lt;<span class="hljs-type">double</span>&gt;();<br>    <span class="hljs-built_in">analyzeType</span>&lt;std::string&gt;();<br>    analyzeType&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;();<br>    <span class="hljs-built_in">analyzeType</span>&lt;Point2D&gt;();<br>    <span class="hljs-built_in">analyzeType</span>&lt;Matrix&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p><strong>选择参数传递方式的指南：</strong></p>
<ol>
<li><p><strong>Pass-by-value适用于：</strong></p>
<ul>
<li>内置类型（int, double, bool等）</li>
<li>枚举类型</li>
<li>指针类型</li>
<li>STL迭代器</li>
<li>函数对象（通常）</li>
<li>小型自定义类型（通常≤2个指针大小）</li>
</ul>
</li>
<li><p><strong>Pass-by-reference-to-const适用于：</strong></p>
<ul>
<li>用户自定义类型（除非很小）</li>
<li>STL容器</li>
<li>字符串类型</li>
<li>任何拷贝开销较大的类型</li>
</ul>
</li>
<li><p><strong>Pass-by-reference（非const）适用于：</strong></p>
<ul>
<li>需要修改参数的情况</li>
<li>输出参数</li>
</ul>
</li>
</ol>
<p><strong>现代C++扩展：</strong></p>
<ul>
<li><strong>右值引用</strong>：支持移动语义</li>
<li><strong>完美转发</strong>：模板函数的通用解决方案</li>
<li><strong>结构化绑定</strong>：简化多返回值</li>
</ul>
<p><strong>性能考虑：</strong></p>
<ul>
<li><strong>测量优于猜测</strong>：使用性能分析工具</li>
<li><strong>编译器优化</strong>：现代编译器很聪明，但基本原则仍然重要</li>
<li><strong>缓存友好性</strong>：引用传递通常更缓存友好</li>
</ul>
<p><strong>记住：尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。但这个规则并不适用于内置类型、以及STL的迭代器和函数对象，对它们而言，pass-by-value往往比较恰当。</strong></p>
<h2 id="条款21：-必须返回对象时，别妄想返回其-reference"><a href="#条款21：-必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款21： 必须返回对象时，别妄想返回其 reference"></a>条款21： 必须返回对象时，别妄想返回其 reference</h2><blockquote>
<p><em>Don’t try to return a reference when you must return an object</em></p>
</blockquote>
<h3 id="核心理念-20"><a href="#核心理念-20" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象</strong>。当函数必须返回一个新对象时，就让它返回一个新对象，不要试图通过返回引用来避免对象构造的成本。虽然返回引用看起来更高效，但如果引用指向的对象不存在或管理不当，会导致未定义行为或内存泄漏。</p>
<h3 id="深度解析-20"><a href="#深度解析-20" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-返回局部对象引用的危险性"><a href="#1-返回局部对象引用的危险性" class="headerlink" title="1. 返回局部对象引用的危险性"></a>1. <strong>返回局部对象引用的危险性</strong></h4><p>当函数结束时，局部对象会被自动销毁，返回的引用将指向一个不存在的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 危险：返回局部对象的引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.numerator() * rhs.numerator(),</span></span><br><span class="hljs-params"><span class="hljs-function">                   lhs.denominator() * rhs.denominator())</span></span>;<br>    <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 返回对局部对象的引用！</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDanger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <br>    <span class="hljs-type">const</span> Rational&amp; product = <span class="hljs-built_in">multiply</span>(a, b);  <span class="hljs-comment">// 未定义行为！</span><br>    std::cout &lt;&lt; product;  <span class="hljs-comment">// 访问已销毁的对象</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 正确：返回对象本身</span><br><span class="hljs-function">Rational <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-返回堆分配对象引用的问题"><a href="#2-返回堆分配对象引用的问题" class="headerlink" title="2. 返回堆分配对象引用的问题"></a>2. <strong>返回堆分配对象引用的问题</strong></h4><p>虽然堆对象不会自动销毁，但会带来内存管理的负担和潜在的内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 问题：返回堆分配对象的引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    Rational* result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    <span class="hljs-keyword">return</span> *result;  <span class="hljs-comment">// 谁来删除这个对象？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateMemoryLeak</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 内存泄漏！无法知道何时删除返回的对象</span><br>    <span class="hljs-type">const</span> Rational&amp; product1 = <span class="hljs-built_in">multiply</span>(a, b);<br>    <span class="hljs-type">const</span> Rational&amp; product2 = <span class="hljs-built_in">multiply</span>(a, b);<br>    <br>    <span class="hljs-comment">// delete &amp;product1;  // 危险！客户端不应该负责内存管理</span><br>    <span class="hljs-comment">// delete &amp;product2;  // 而且很容易忘记</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 正确：返回对象本身，让编译器优化</span><br><span class="hljs-function">Rational <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-静态对象的局限性"><a href="#3-静态对象的局限性" class="headerlink" title="3. 静态对象的局限性"></a>3. <strong>静态对象的局限性</strong></h4><p>虽然静态对象可以安全返回引用，但会导致多线程问题和奇怪的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 问题：返回静态对象引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-type">static</span> Rational result;  <span class="hljs-comment">// 静态对象，函数结束后仍存在</span><br>    result = <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                     lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStaticProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 问题：比较总是返回true！</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">multiply</span>(a, b) == <span class="hljs-built_in">multiply</span>(c, d)) &#123;<br>        <span class="hljs-comment">// 这个条件总是成立，因为两次调用返回的是同一个静态对象</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Products are equal&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 多线程环境下更危险</span><br>    <span class="hljs-comment">// 线程1: multiply(a, b)</span><br>    <span class="hljs-comment">// 线程2: multiply(c, d)  // 可能覆盖线程1的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-正确的解决方案"><a href="#4-正确的解决方案" class="headerlink" title="4. 正确的解决方案"></a>4. <strong>正确的解决方案</strong></h4><p>相信编译器的优化能力，直接返回对象。现代编译器会应用RVO（返回值优化）来消除不必要的拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确的运算符重载</span><br>    Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(numerator_ * rhs.numerator_,<br>                       denominator_ * rhs.denominator_);<br>    &#125;<br>    <br>    Rational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(numerator_ * rhs.denominator_ + rhs.numerator_ * denominator_,<br>                       denominator_ * rhs.denominator_);<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> numerator_ * rhs.denominator_ == rhs.numerator_ * denominator_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员函数版本也是如此</span><br><span class="hljs-function">Rational <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateCorrectUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 编译器优化：通常不会有额外的拷贝</span><br>    Rational product1 = a * b;        <span class="hljs-comment">// 使用成员函数</span><br>    Rational product2 = <span class="hljs-built_in">multiply</span>(c, d);  <span class="hljs-comment">// 使用非成员函数</span><br>    <br>    <span class="hljs-comment">// 正确的比较结果</span><br>    <span class="hljs-keyword">if</span> (product1 == product2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Products are equal&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Products are different&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-现代C-的进一步优化"><a href="#5-现代C-的进一步优化" class="headerlink" title="5. 现代C++的进一步优化"></a>5. <strong>现代C++的进一步优化</strong></h4><p>使用移动语义和完美转发可以进一步减少不必要的拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernRational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernRational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ModernRational</span>(ModernRational&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">numerator_</span>(other.numerator_), <span class="hljs-built_in">denominator_</span>(other.denominator_) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    ModernRational&amp; <span class="hljs-keyword">operator</span>=(ModernRational&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        numerator_ = other.numerator_;<br>        denominator_ = other.denominator_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>    <br>    <span class="hljs-comment">// 返回值优化 + 移动语义</span><br>    ModernRational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> ModernRational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModernRational</span>(numerator_ * rhs.numerator_,<br>                             denominator_ * rhs.denominator_);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用auto和初始化列表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateModernUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> a = ModernRational&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-keyword">auto</span> b = ModernRational&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <br>    <span class="hljs-keyword">auto</span> product = a * b;  <span class="hljs-comment">// 高效：RVO + 移动语义</span><br>    <br>    <span class="hljs-comment">// 链式操作也很高效</span><br>    <span class="hljs-keyword">auto</span> result = ModernRational&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; * ModernRational&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; * ModernRational&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><strong>设计原则：</strong></p>
<ol>
<li><strong>安全第一</strong>：不返回指向局部对象的引用</li>
<li><strong>明确责任</strong>：不让客户端管理内存</li>
<li><strong>避免共享状态</strong>：不使用静态对象的引用</li>
<li><strong>相信编译器</strong>：现代编译器的优化能力很强</li>
</ol>
<p><strong>返回策略选择：</strong></p>
<ul>
<li><strong>返回对象本身</strong>：最安全、最清晰的选择</li>
<li><strong>返回智能指针</strong>：需要共享所有权时</li>
<li><strong>返回容器</strong>：需要返回多个对象时</li>
<li><strong>使用输出参数</strong>：极少数性能关键场景</li>
</ul>
<p><strong>记住：当函数必须返回一个新对象时，就让它返回一个新对象。不要试图返回reference指向某个local stack对象，或返回reference指向一个heap-allocated对象，或返回reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为”在某些单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。</strong></p>
<h2 id="条款22：-将成员变量声明为-private"><a href="#条款22：-将成员变量声明为-private" class="headerlink" title="条款22： 将成员变量声明为 private"></a>条款22： 将成员变量声明为 private</h2><blockquote>
<p><em>Declare data members private</em></p>
</blockquote>
<h3 id="核心理念-21"><a href="#核心理念-21" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>切记将成员变量声明为private</strong>。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。从封装的角度看，只有两种访问权限：private（提供封装）和其他（不提供封装）。protected并不比public更具有封装性。</p>
<h3 id="深度解析-21"><a href="#深度解析-21" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-数据封装的重要性"><a href="#1-数据封装的重要性" class="headerlink" title="1. 数据封装的重要性"></a>1. <strong>数据封装的重要性</strong></h4><p>将成员变量声明为private是良好封装的基础，它提供了接口和实现的完全分离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 不良设计：公开数据成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadPoint</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> x, y;  <span class="hljs-comment">// 公开的数据成员</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    BadPoint p;<br>    p.x = <span class="hljs-number">10.5</span>;  <span class="hljs-comment">// 直接访问</span><br>    p.y = <span class="hljs-number">20.3</span>;  <span class="hljs-comment">// 没有任何控制</span><br>    <br>    <span class="hljs-comment">// 问题：</span><br>    <span class="hljs-comment">// 1. 无法验证数据合法性</span><br>    <span class="hljs-comment">// 2. 无法在访问时执行额外操作</span><br>    <span class="hljs-comment">// 3. 无法改变内部实现</span><br>    <span class="hljs-comment">// 4. 无法统计访问次数或调试</span><br>&#125;<br><br><span class="hljs-comment">// ✅ 良好设计：私有数据成员 + 公开接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodPoint</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x_, y_;  <span class="hljs-comment">// 私有数据成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数提供初始化</span><br>    <span class="hljs-built_in">GoodPoint</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 提供受控访问</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; <br>        <span class="hljs-comment">// 可以添加验证逻辑</span><br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isfinite</span>(x)) &#123;<br>            x_ = x; <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isfinite</span>(y)) &#123;<br>            y_ = y; <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 可以提供便利的组合操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPosition</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>        <span class="hljs-built_in">setX</span>(x);<br>        <span class="hljs-built_in">setY</span>(y);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-访问控制的好处"><a href="#2-访问控制的好处" class="headerlink" title="2. 访问控制的好处"></a>2. <strong>访问控制的好处</strong></h4><p>Private成员变量配合公开的访问函数可以提供精确的控制和验证机制。</p>
<p><strong>一致性和精确控制：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string accountNumber_;<br>    <span class="hljs-type">double</span> balance_;<br>    std::vector&lt;std::string&gt; transactionHistory_;<br>    <span class="hljs-type">bool</span> isActive_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BankAccount</span>(<span class="hljs-type">const</span> std::string&amp; accountNum, <span class="hljs-type">double</span> initialBalance) <br>        : <span class="hljs-built_in">accountNumber_</span>(accountNum), <span class="hljs-built_in">balance_</span>(initialBalance), <span class="hljs-built_in">isActive_</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ✅ 只读访问：一致的接口</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getAccountNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> accountNumber_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> balance_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> isActive_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 受控的写访问：可以添加业务逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isActive_ || amount &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 验证失败</span><br>        &#125;<br>        <br>        balance_ += amount;<br>        transactionHistory_.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Deposit: $&quot;</span> + std::<span class="hljs-built_in">to_string</span>(amount));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isActive_ || amount &lt;= <span class="hljs-number">0</span> || amount &gt; balance_) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 验证失败</span><br>        &#125;<br>        <br>        balance_ -= amount;<br>        transactionHistory_.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Withdrawal: $&quot;</span> + std::<span class="hljs-built_in">to_string</span>(amount));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deactivateAccount</span><span class="hljs-params">()</span> </span>&#123;<br>        isActive_ = <span class="hljs-literal">false</span>;<br>        transactionHistory_.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Account deactivated&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 组合操作：提供更高级的功能</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">transfer</span><span class="hljs-params">(BankAccount&amp; toAccount, <span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">withdraw</span>(amount)) &#123;<br>            <span class="hljs-keyword">if</span> (toAccount.<span class="hljs-built_in">deposit</span>(amount)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 回滚操作</span><br>                <span class="hljs-built_in">deposit</span>(amount);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>实现弹性：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本1：简单实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> celsius_;  <span class="hljs-comment">// 内部以摄氏度存储</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Temperature</span>(<span class="hljs-type">double</span> celsius) : <span class="hljs-built_in">celsius_</span>(celsius) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">celsius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> celsius_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fahrenheit</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> celsius_ * <span class="hljs-number">9.0</span> / <span class="hljs-number">5.0</span> + <span class="hljs-number">32.0</span>; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCelsius</span><span class="hljs-params">(<span class="hljs-type">double</span> c)</span> </span>&#123; celsius_ = c; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFahrenheit</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span> </span>&#123; celsius_ = (f - <span class="hljs-number">32.0</span>) * <span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 版本2：优化实现（内部表示改变，接口不变）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> kelvin_;  <span class="hljs-comment">// 改为以开尔文存储，更适合科学计算</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Temperature</span>(<span class="hljs-type">double</span> celsius) : <span class="hljs-built_in">kelvin_</span>(celsius + <span class="hljs-number">273.15</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 接口保持不变！</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">celsius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> kelvin_ - <span class="hljs-number">273.15</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fahrenheit</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (kelvin_ - <span class="hljs-number">273.15</span>) * <span class="hljs-number">9.0</span> / <span class="hljs-number">5.0</span> + <span class="hljs-number">32.0</span>; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCelsius</span><span class="hljs-params">(<span class="hljs-type">double</span> c)</span> </span>&#123; kelvin_ = c + <span class="hljs-number">273.15</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFahrenheit</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span> </span>&#123; kelvin_ = (f - <span class="hljs-number">32.0</span>) * <span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span> + <span class="hljs-number">273.15</span>; &#125;<br>    <br>    <span class="hljs-comment">// 新增功能：可以直接获取开尔文温度</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">kelvin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> kelvin_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKelvin</span><span class="hljs-params">(<span class="hljs-type">double</span> k)</span> </span>&#123; kelvin_ = k; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-protected的封装性问题"><a href="#3-protected的封装性问题" class="headerlink" title="3. protected的封装性问题"></a>3. <strong>protected的封装性问题</strong></h4><p>Protected成员变量在封装性上与public成员变量没有本质区别，都会破坏封装。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 使用protected数据成员的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> area_;  <span class="hljs-comment">// protected数据成员</span><br>    std::string color_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>(<span class="hljs-type">const</span> std::string&amp; color) : <span class="hljs-built_in">area_</span>(<span class="hljs-number">0.0</span>), <span class="hljs-built_in">color_</span>(color) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> area_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getColor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> color_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height, <span class="hljs-type">const</span> std::string&amp; color) <br>        : <span class="hljs-built_in">Shape</span>(color), <span class="hljs-built_in">width_</span>(width), <span class="hljs-built_in">height_</span>(height) &#123;<br>        area_ = width_ * height_;  <span class="hljs-comment">// 直接访问基类的protected成员</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> </span>&#123;<br>        width_ = width;<br>        height_ = height;<br>        area_ = width_ * height_;  <span class="hljs-comment">// 必须记住更新area_</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br>&#125;;<br><br><span class="hljs-comment">// 问题：如果Shape类的实现改变（比如area_改为按需计算），</span><br><span class="hljs-comment">// 所有派生类都需要修改！</span><br><br><span class="hljs-comment">// ✅ 更好的设计：private数据 + protected接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BetterShape</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string color_;  <span class="hljs-comment">// private数据成员</span><br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// protected成员函数，而不是数据成员</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; color)</span> </span>&#123; color_ = color; &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BetterShape</span>(<span class="hljs-type">const</span> std::string&amp; color) : <span class="hljs-built_in">color_</span>(color) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">BetterShape</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getColor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> color_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BetterRectangle</span> : <span class="hljs-keyword">public</span> BetterShape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BetterRectangle</span>(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height, <span class="hljs-type">const</span> std::string&amp; color) <br>        : <span class="hljs-built_in">BetterShape</span>(color), <span class="hljs-built_in">width_</span>(width), <span class="hljs-built_in">height_</span>(height) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> width_ * height_;  <span class="hljs-comment">// 按需计算，不需要存储</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> </span>&#123;<br>        width_ = width;<br>        height_ = height;<br>        <span class="hljs-comment">// 不需要更新area_，因为它是计算得出的</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-设计模式中的应用"><a href="#4-设计模式中的应用" class="headerlink" title="4. 设计模式中的应用"></a>4. <strong>设计模式中的应用</strong></h4><p>Private数据成员在各种设计模式中都发挥着重要作用。</p>
<p><strong>RAII模式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandle</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    FILE* file_;  <span class="hljs-comment">// private资源</span><br>    std::string filename_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FileHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span><br><span class="hljs-function">        : filename_(filename), file_(nullptr) &#123;</span><br>        file_ = <span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!file_) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open file: &quot;</span> + filename);<br>        &#125;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">FileHandle</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) &#123;<br>            <span class="hljs-built_in">fclose</span>(file_);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除拷贝构造和赋值（或实现深拷贝）</span><br>    <span class="hljs-built_in">FileHandle</span>(<span class="hljs-type">const</span> FileHandle&amp;) = <span class="hljs-keyword">delete</span>;<br>    FileHandle&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> FileHandle&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 移动语义</span><br>    <span class="hljs-built_in">FileHandle</span>(FileHandle&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">file_</span>(other.file_), <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(other.filename_)) &#123;<br>        other.file_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    FileHandle&amp; <span class="hljs-keyword">operator</span>=(FileHandle&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">if</span> (file_) <span class="hljs-built_in">fclose</span>(file_);<br>            file_ = other.file_;<br>            filename_ = std::<span class="hljs-built_in">move</span>(other.filename_);<br>            other.file_ = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供受控访问</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> file_ != <span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFilename</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> filename_; &#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">readLine</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!file_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;File not open&quot;</span>);<br>        <br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fgets</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer), file_)) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buffer);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>观察者模式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Observer*&gt; observers_;  <span class="hljs-comment">// private观察者列表</span><br>    <span class="hljs-type">int</span> state_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer* observer)</span> </span>&#123;<br>        observers_.<span class="hljs-built_in">push_back</span>(observer);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer* observer)</span> </span>&#123;<br>        observers_.<span class="hljs-built_in">erase</span>(<br>            std::<span class="hljs-built_in">remove</span>(observers_.<span class="hljs-built_in">begin</span>(), observers_.<span class="hljs-built_in">end</span>(), observer),<br>            observers_.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (state_ != newState) &#123;<br>            state_ = newState;<br>            <span class="hljs-built_in">notifyObservers</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> state_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>* observer : observers_) &#123;<br>            observer-&gt;<span class="hljs-built_in">update</span>(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-现代C-的最佳实践"><a href="#5-现代C-的最佳实践" class="headerlink" title="5. 现代C++的最佳实践"></a>5. <strong>现代C++的最佳实践</strong></h4><p>结合现代C++特性，进一步提升private数据成员的使用效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernString</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; data_;  <span class="hljs-comment">// 使用智能指针管理内存</span><br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">size_t</span> capacity_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ModernString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;&quot;</span>)</span> </span>&#123;<br>        size_ = <span class="hljs-built_in">strlen</span>(str);<br>        capacity_ = size_ + <span class="hljs-number">1</span>;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(capacity_);<br>        <span class="hljs-built_in">strcpy</span>(data_.<span class="hljs-built_in">get</span>(), str);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ModernString</span>(<span class="hljs-type">const</span> ModernString&amp; other) <br>        : <span class="hljs-built_in">size_</span>(other.size_), <span class="hljs-built_in">capacity_</span>(other.capacity_) &#123;<br>        data_ = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(capacity_);<br>        <span class="hljs-built_in">strcpy</span>(data_.<span class="hljs-built_in">get</span>(), other.data_.<span class="hljs-built_in">get</span>());<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ModernString</span>(ModernString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">data_</span>(std::<span class="hljs-built_in">move</span>(other.data_)), <span class="hljs-built_in">size_</span>(other.size_), <span class="hljs-built_in">capacity_</span>(other.capacity_) &#123;<br>        other.size_ = <span class="hljs-number">0</span>;<br>        other.capacity_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 赋值运算符</span><br>    ModernString&amp; <span class="hljs-keyword">operator</span>=(ModernString other) &#123;<br>        <span class="hljs-built_in">swap</span>(other);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供const和non-const版本的访问</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">get</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; &#125;<br>    <br>    <span class="hljs-comment">// 支持范围for循环</span><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">get</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">get</span>() + size_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">get</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">get</span>() + size_; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(ModernString&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(data_, other.data_);<br>        <span class="hljs-built_in">swap</span>(size_, other.size_);<br>        <span class="hljs-built_in">swap</span>(capacity_, other.capacity_);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><strong>Private数据成员的优势：</strong></p>
<ol>
<li><strong>封装性</strong>：隐藏实现细节，保护数据完整性</li>
<li><strong>灵活性</strong>：可以改变内部实现而不影响客户代码</li>
<li><strong>控制性</strong>：可以添加验证、日志、统计等功能</li>
<li><strong>一致性</strong>：通过函数接口提供统一的访问方式</li>
</ol>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>数据成员始终private</strong>：除了极少数例外情况</li>
<li><strong>通过函数提供访问</strong>：getter&#x2F;setter或更高级的接口</li>
<li><strong>验证输入数据</strong>：在setter中添加合理性检查</li>
<li><strong>考虑不变量</strong>：确保对象始终处于有效状态</li>
</ul>
<p><strong>避免的陷阱：</strong></p>
<ul>
<li><strong>不要使用public数据成员</strong>：破坏封装性</li>
<li><strong>不要使用protected数据成员</strong>：同样破坏封装性</li>
<li><strong>不要过度设计</strong>：简单的数据类可以考虑struct</li>
</ul>
<p><strong>记住：切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。protected并不比public更具封装性。</strong></p>
<h2 id="条款23：-宁以non-member、non-friend替member-函数。"><a href="#条款23：-宁以non-member、non-friend替member-函数。" class="headerlink" title="条款23： 宁以non-member、non-friend替member 函数。"></a>条款23： 宁以non-member、non-friend替member 函数。</h2><blockquote>
<p><em>Prefer non-member non-friend functions to member functions</em></p>
</blockquote>
<h3 id="核心理念-22"><a href="#核心理念-22" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>非成员非友元函数比成员函数提供更好的封装性</strong>。这听起来可能违背直觉，但从封装的本质来看：封装意味着不被看到，而能够访问类私有成员的函数越少，封装性就越好。非成员非友元函数无法访问类的私有成员，因此不会增加”能够访问私有数据的函数数量”，从而提供了更好的封装性、包装弹性和功能扩展性。</p>
<h3 id="深度解析-22"><a href="#深度解析-22" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-封装性的真正含义"><a href="#1-封装性的真正含义" class="headerlink" title="1. 封装性的真正含义"></a>1. <strong>封装性的真正含义</strong></h4><p><strong>封装性的量化标准：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string bookmarks_;<br>    std::string history_;<br>    std::string cookies_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 基本操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span> </span>&#123; history_.<span class="hljs-built_in">clear</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBookmarks</span><span class="hljs-params">()</span> </span>&#123; bookmarks_.<span class="hljs-built_in">clear</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCookies</span><span class="hljs-params">()</span> </span>&#123; cookies_.<span class="hljs-built_in">clear</span>(); &#125;<br><br>    <span class="hljs-comment">// ❌ 成员函数版本：能访问所有私有数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">clearHistory</span>();<br>        <span class="hljs-built_in">clearBookmarks</span>(); <br>        <span class="hljs-built_in">clearCookies</span>();<br>        <span class="hljs-comment">// 还可以直接访问 bookmarks_, history_, cookies_</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员非友元函数版本：无法访问私有数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span> </span>&#123;<br>    wb.<span class="hljs-built_in">clearHistory</span>();<br>    wb.<span class="hljs-built_in">clearBookmarks</span>();<br>    wb.<span class="hljs-built_in">clearCookies</span>();<br>    <span class="hljs-comment">// 无法访问私有成员，封装性更好</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateEncapsulation</span><span class="hljs-params">()</span> </span>&#123;<br>    WebBrowser browser;<br>    <br>    <span class="hljs-comment">// 两种调用方式功能相同</span><br>    browser.<span class="hljs-built_in">clearEverything</span>();  <span class="hljs-comment">// 成员函数</span><br>    <span class="hljs-built_in">clearBrowser</span>(browser);      <span class="hljs-comment">// 非成员函数</span><br>    <br>    <span class="hljs-comment">// 但封装性不同：</span><br>    <span class="hljs-comment">// - 成员函数能访问3个私有变量</span><br>    <span class="hljs-comment">// - 非成员函数能访问0个私有变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>封装性的数学证明：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;     <span class="hljs-comment">// 私有数据1</span><br>    std::string metadata_;      <span class="hljs-comment">// 私有数据2</span><br>    <span class="hljs-type">bool</span> modified_;             <span class="hljs-comment">// 私有数据3</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 必需的访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; data_.<span class="hljs-built_in">push_back</span>(value); modified_ = <span class="hljs-literal">true</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; meta)</span> </span>&#123; metadata_ = meta; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isModified</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> modified_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">size</span>(); &#125;<br><br>    <span class="hljs-comment">// ❌ 成员函数：增加了能访问私有数据的函数数量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSummary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data size: &quot;</span> &lt;&lt; data_.<span class="hljs-built_in">size</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;, Metadata: &quot;</span> &lt;&lt; metadata_<br>                  &lt;&lt; <span class="hljs-string">&quot;, Modified: &quot;</span> &lt;&lt; modified_ &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员函数：不增加能访问私有数据的函数数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDataSummary</span><span class="hljs-params">(<span class="hljs-type">const</span> DataContainer&amp; container)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Data size: &quot;</span> &lt;&lt; container.<span class="hljs-built_in">size</span>()<br>              &lt;&lt; <span class="hljs-string">&quot;, Modified: &quot;</span> &lt;&lt; container.<span class="hljs-built_in">isModified</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 封装性分析：</span><br><span class="hljs-comment">// - 有成员函数版本：5个函数能访问私有数据（包括printSummary）</span><br><span class="hljs-comment">// - 有非成员函数版本：4个函数能访问私有数据（不包括printDataSummary）</span><br><span class="hljs-comment">// 结论：非成员函数版本封装性更好</span><br></code></pre></td></tr></table></figure>

<h4 id="2-包装弹性（Packaging-Flexibility）"><a href="#2-包装弹性（Packaging-Flexibility）" class="headerlink" title="2. 包装弹性（Packaging Flexibility）"></a>2. <strong>包装弹性（Packaging Flexibility）</strong></h4><p><strong>头文件组织的灵活性：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// webbrowser.h - 核心类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string bookmarks_;<br>    std::string history_;<br>    std::string cookies_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBookmarks</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCookies</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">// 只包含核心功能，保持头文件轻量</span><br>&#125;;<br><br><span class="hljs-comment">// webbrowser_utils.h - 便利函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> WebBrowserUtils &#123;<br>    <span class="hljs-comment">// ✅ 基本清理函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>    <br>    <span class="hljs-comment">// ✅ 高级清理函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowserSafely</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowserWithBackup</span><span class="hljs-params">(WebBrowser&amp; wb, <span class="hljs-type">const</span> std::string&amp; backupPath)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// webbrowser_bookmarks.h - 书签相关扩展</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> WebBrowserBookmarks &#123;<br>    <span class="hljs-comment">// ✅ 书签特定操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exportBookmarks</span><span class="hljs-params">(<span class="hljs-type">const</span> WebBrowser&amp; wb, <span class="hljs-type">const</span> std::string&amp; filename)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">importBookmarks</span><span class="hljs-params">(WebBrowser&amp; wb, <span class="hljs-type">const</span> std::string&amp; filename)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortBookmarks</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// webbrowser_history.h - 历史记录相关扩展  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> WebBrowserHistory &#123;<br>    <span class="hljs-comment">// ✅ 历史记录特定操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">analyzeHistory</span><span class="hljs-params">(<span class="hljs-type">const</span> WebBrowser&amp; wb)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exportHistory</span><span class="hljs-params">(<span class="hljs-type">const</span> WebBrowser&amp; wb, <span class="hljs-type">const</span> std::string&amp; format)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端按需包含：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 客户端1：只需要基本功能</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser_utils.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">basicUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    WebBrowser browser;<br>    WebBrowserUtils::<span class="hljs-built_in">clearBrowser</span>(browser);<br>&#125;<br><br><span class="hljs-comment">// 客户端2：需要书签功能</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser_bookmarks.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bookmarkUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    WebBrowser browser;<br>    WebBrowserBookmarks::<span class="hljs-built_in">exportBookmarks</span>(browser, <span class="hljs-string">&quot;my_bookmarks.html&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 客户端3：需要全部功能</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser_utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser_bookmarks.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webbrowser_history.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fullUsage</span><span class="hljs-params">()</span> </span>&#123;<br>    WebBrowser browser;<br>    WebBrowserUtils::<span class="hljs-built_in">clearBrowserSafely</span>(browser);<br>    WebBrowserBookmarks::<span class="hljs-built_in">sortBookmarks</span>(browser);<br>    WebBrowserHistory::<span class="hljs-built_in">analyzeHistory</span>(browser);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-功能扩展性（Extensibility）"><a href="#3-功能扩展性（Extensibility）" class="headerlink" title="3. 功能扩展性（Extensibility）"></a>3. <strong>功能扩展性（Extensibility）</strong></h4><p><strong>第三方扩展的可能性：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 原始类（无法修改）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextDocument</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string content_;<br>    std::string filename_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextDocument</span>(<span class="hljs-type">const</span> std::string&amp; filename) : <span class="hljs-built_in">filename_</span>(filename) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content)</span> </span>&#123; content_ = content; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> content_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFilename</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> filename_; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(filename_)</span></span>;<br>        file &lt;&lt; content_;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 第三方可以添加非成员函数扩展功能</span><br><span class="hljs-keyword">namespace</span> DocumentFormatting &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(TextDocument&amp; doc, <span class="hljs-type">const</span> std::string&amp; header)</span> </span>&#123;<br>        std::string content = header + <span class="hljs-string">&quot;\n&quot;</span> + doc.<span class="hljs-built_in">getContent</span>();<br>        doc.<span class="hljs-built_in">setContent</span>(content);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFooter</span><span class="hljs-params">(TextDocument&amp; doc, <span class="hljs-type">const</span> std::string&amp; footer)</span> </span>&#123;<br>        std::string content = doc.<span class="hljs-built_in">getContent</span>() + <span class="hljs-string">&quot;\n&quot;</span> + footer;<br>        doc.<span class="hljs-built_in">setContent</span>(content);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toUpperCase</span><span class="hljs-params">(TextDocument&amp; doc)</span> </span>&#123;<br>        std::string content = doc.<span class="hljs-built_in">getContent</span>();<br>        std::<span class="hljs-built_in">transform</span>(content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), content.<span class="hljs-built_in">begin</span>(), ::toupper);<br>        doc.<span class="hljs-built_in">setContent</span>(content);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> DocumentAnalysis &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">wordCount</span><span class="hljs-params">(<span class="hljs-type">const</span> TextDocument&amp; doc)</span> </span>&#123;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(doc.getContent())</span></span>;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">distance</span>(std::<span class="hljs-built_in">istream_iterator</span>&lt;std::string&gt;(iss),<br>                           std::<span class="hljs-built_in">istream_iterator</span>&lt;std::string&gt;());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">lineCount</span><span class="hljs-params">(<span class="hljs-type">const</span> TextDocument&amp; doc)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">count</span>(doc.<span class="hljs-built_in">getContent</span>().<span class="hljs-built_in">begin</span>(), doc.<span class="hljs-built_in">getContent</span>().<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">getWords</span><span class="hljs-params">(<span class="hljs-type">const</span> TextDocument&amp; doc)</span> </span>&#123;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(doc.getContent())</span></span>;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(std::<span class="hljs-built_in">istream_iterator</span>&lt;std::string&gt;(iss),<br>                                       std::<span class="hljs-built_in">istream_iterator</span>&lt;std::string&gt;());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateExtensibility</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">TextDocument <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;<br>    doc.<span class="hljs-built_in">setContent</span>(<span class="hljs-string">&quot;Hello World\nThis is a test&quot;</span>);<br>    <br>    <span class="hljs-comment">// 使用第三方扩展</span><br>    DocumentFormatting::<span class="hljs-built_in">addHeader</span>(doc, <span class="hljs-string">&quot;=== DOCUMENT ===&quot;</span>);<br>    DocumentFormatting::<span class="hljs-built_in">addFooter</span>(doc, <span class="hljs-string">&quot;=== END ===&quot;</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Word count: &quot;</span> &lt;&lt; DocumentAnalysis::<span class="hljs-built_in">wordCount</span>(doc) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Line count: &quot;</span> &lt;&lt; DocumentAnalysis::<span class="hljs-built_in">lineCount</span>(doc) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-现代C-中的应用"><a href="#4-现代C-中的应用" class="headerlink" title="4. 现代C++中的应用"></a>4. <strong>现代C++中的应用</strong></h4><p><strong>STL算法的设计哲学：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSTLPhilosophy</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">// ❌ 如果STL是面向对象设计（假想）</span><br>    <span class="hljs-comment">// numbers.sort();</span><br>    <span class="hljs-comment">// numbers.reverse();</span><br>    <span class="hljs-comment">// int sum = numbers.accumulate();</span><br>    <br>    <span class="hljs-comment">// ✅ 实际的STL设计：非成员函数</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    std::<span class="hljs-built_in">reverse</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 优势：</span><br>    <span class="hljs-comment">// 1. 算法可以用于任何容器</span><br>    <span class="hljs-comment">// 2. 容器类保持简洁</span><br>    <span class="hljs-comment">// 3. 算法可以独立扩展</span><br>&#125;<br><br><span class="hljs-comment">// 自定义容器遵循相同原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularBuffer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>    <span class="hljs-type">size_t</span> capacity_;<br>    <span class="hljs-type">size_t</span> head_;<br>    <span class="hljs-type">size_t</span> size_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CircularBuffer</span>(<span class="hljs-type">size_t</span> capacity) <br>        : <span class="hljs-built_in">data_</span>(capacity), <span class="hljs-built_in">capacity_</span>(capacity), <span class="hljs-built_in">head_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        data_[head_] = value;<br>        head_ = (head_ + <span class="hljs-number">1</span>) % capacity_;<br>        <span class="hljs-keyword">if</span> (size_ &lt; capacity_) ++size_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 提供迭代器接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">begin</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">begin</span>() + size_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员函数扩展</span><br><span class="hljs-keyword">namespace</span> CircularBufferUtils &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> CircularBuffer&amp; buffer)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(buffer.<span class="hljs-built_in">begin</span>(), buffer.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">const</span> CircularBuffer&amp; buffer)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> *std::<span class="hljs-built_in">max_element</span>(buffer.<span class="hljs-built_in">begin</span>(), buffer.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> CircularBuffer&amp; buffer)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = buffer.<span class="hljs-built_in">begin</span>(); it != buffer.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-运算符重载的应用"><a href="#5-运算符重载的应用" class="headerlink" title="5. 运算符重载的应用"></a>5. <strong>运算符重载的应用</strong></h4><p><strong>非成员运算符的优势：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员运算符：支持隐式类型转换</span><br>Rational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() + rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br>Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-comment">// ✅ 非成员输出运算符</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Rational&amp; r) &#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; r.<span class="hljs-built_in">numerator</span>() &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; r.<span class="hljs-built_in">denominator</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateOperatorOverloading</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 非成员运算符的优势：</span><br>    Rational r3 = r1 + r2;        <span class="hljs-comment">// ✅ 正常</span><br>    Rational r4 = <span class="hljs-number">2</span> + r1;         <span class="hljs-comment">// ✅ 隐式转换：2 -&gt; Rational(2,1)</span><br>    Rational r5 = r1 + <span class="hljs-number">3</span>;         <span class="hljs-comment">// ✅ 隐式转换：3 -&gt; Rational(3,1)</span><br>    <br>    std::cout &lt;&lt; r3 &lt;&lt; std::endl; <span class="hljs-comment">// ✅ 非成员输出运算符</span><br>&#125;<br><br><span class="hljs-comment">// ❌ 如果是成员函数版本的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadRational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_, denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BadRational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    BadRational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> BadRational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">BadRational</span>(numerator_ * rhs.denominator_ + rhs.numerator_ * denominator_,<br>                          denominator_ * rhs.denominator_);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateMemberOperatorProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">BadRational <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <br>    BadRational r2 = r1 + <span class="hljs-built_in">BadRational</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// ✅ 正常</span><br>    <span class="hljs-comment">// BadRational r3 = 2 + r1;                // ❌ 编译错误！</span><br>    <span class="hljs-comment">// 等价于 2.operator+(r1)，但int没有这个成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-命名空间的组织策略"><a href="#6-命名空间的组织策略" class="headerlink" title="6. 命名空间的组织策略"></a>6. <strong>命名空间的组织策略</strong></h4><p><strong>良好的命名空间设计：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// geometry.h - 核心几何类</span><br><span class="hljs-keyword">namespace</span> Geometry &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">double</span> x_, y_;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; x_ = x; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> </span>&#123; y_ = y; &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        Point topLeft_, bottomRight_;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">const</span> Point&amp; tl, <span class="hljs-type">const</span> Point&amp; br) : <span class="hljs-built_in">topLeft_</span>(tl), <span class="hljs-built_in">bottomRight_</span>(br) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">topLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> topLeft_; &#125;<br>        <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">bottomRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bottomRight_; &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// geometry_calculations.h - 计算相关非成员函数</span><br><span class="hljs-keyword">namespace</span> Geometry &#123;<br>    <span class="hljs-keyword">namespace</span> Calculations &#123;<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>            <span class="hljs-type">double</span> dx = p<span class="hljs-number">1.</span><span class="hljs-built_in">x</span>() - p<span class="hljs-number">2.</span><span class="hljs-built_in">x</span>();<br>            <span class="hljs-type">double</span> dy = p<span class="hljs-number">1.</span><span class="hljs-built_in">y</span>() - p<span class="hljs-number">2.</span><span class="hljs-built_in">y</span>();<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Rectangle&amp; rect)</span> </span>&#123;<br>            <span class="hljs-type">double</span> width = rect.<span class="hljs-built_in">bottomRight</span>().<span class="hljs-built_in">x</span>() - rect.<span class="hljs-built_in">topLeft</span>().<span class="hljs-built_in">x</span>();<br>            <span class="hljs-type">double</span> height = rect.<span class="hljs-built_in">topLeft</span>().<span class="hljs-built_in">y</span>() - rect.<span class="hljs-built_in">bottomRight</span>().<span class="hljs-built_in">y</span>();<br>            <span class="hljs-keyword">return</span> width * height;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(<span class="hljs-type">const</span> Rectangle&amp; rect)</span> </span>&#123;<br>            <span class="hljs-type">double</span> width = rect.<span class="hljs-built_in">bottomRight</span>().<span class="hljs-built_in">x</span>() - rect.<span class="hljs-built_in">topLeft</span>().<span class="hljs-built_in">x</span>();<br>            <span class="hljs-type">double</span> height = rect.<span class="hljs-built_in">topLeft</span>().<span class="hljs-built_in">y</span>() - rect.<span class="hljs-built_in">bottomRight</span>().<span class="hljs-built_in">y</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (width + height);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// geometry_transformations.h - 变换相关非成员函数</span><br><span class="hljs-keyword">namespace</span> Geometry &#123;<br>    <span class="hljs-keyword">namespace</span> Transformations &#123;<br>        <span class="hljs-function">Point <span class="hljs-title">translate</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p, <span class="hljs-type">double</span> dx, <span class="hljs-type">double</span> dy)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(p.<span class="hljs-built_in">x</span>() + dx, p.<span class="hljs-built_in">y</span>() + dy);<br>        &#125;<br>        <br>        <span class="hljs-function">Point <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p, <span class="hljs-type">double</span> angle, <span class="hljs-type">const</span> Point&amp; center = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span> </span>&#123;<br>            <span class="hljs-type">double</span> cos_a = std::<span class="hljs-built_in">cos</span>(angle);<br>            <span class="hljs-type">double</span> sin_a = std::<span class="hljs-built_in">sin</span>(angle);<br>            <span class="hljs-type">double</span> dx = p.<span class="hljs-built_in">x</span>() - center.<span class="hljs-built_in">x</span>();<br>            <span class="hljs-type">double</span> dy = p.<span class="hljs-built_in">y</span>() - center.<span class="hljs-built_in">y</span>();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(center.<span class="hljs-built_in">x</span>() + dx * cos_a - dy * sin_a,<br>                        center.<span class="hljs-built_in">y</span>() + dx * sin_a + dy * cos_a);<br>        &#125;<br>        <br>        <span class="hljs-function">Rectangle <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">const</span> Rectangle&amp; rect, <span class="hljs-type">double</span> factor)</span> </span>&#123;<br>            Point tl = rect.<span class="hljs-built_in">topLeft</span>();<br>            Point br = rect.<span class="hljs-built_in">bottomRight</span>();<br>            <span class="hljs-type">double</span> width = br.<span class="hljs-built_in">x</span>() - tl.<span class="hljs-built_in">x</span>();<br>            <span class="hljs-type">double</span> height = tl.<span class="hljs-built_in">y</span>() - br.<span class="hljs-built_in">y</span>();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rectangle</span>(tl, <span class="hljs-built_in">Point</span>(tl.<span class="hljs-built_in">x</span>() + width * factor, tl.<span class="hljs-built_in">y</span>() - height * factor));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateNamespaceOrganization</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Geometry;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Geometry::Calculations;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Geometry::Transformations;<br>    <br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Rectangle <span class="hljs-title">rect</span><span class="hljs-params">(Point(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), Point(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>))</span></span>;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Distance: &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(p1, p2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Area: &quot;</span> &lt;&lt; <span class="hljs-built_in">area</span>(rect) &lt;&lt; std::endl;<br>    <br>    Point translated = <span class="hljs-built_in">translate</span>(p1, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    Rectangle scaled = <span class="hljs-built_in">scale</span>(rect, <span class="hljs-number">2.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-实际设计案例对比"><a href="#7-实际设计案例对比" class="headerlink" title="7. 实际设计案例对比"></a>7. <strong>实际设计案例对比</strong></h4><p><strong>案例：字符串处理类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 臃肿的成员函数设计</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadString</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BadString</span>(<span class="hljs-type">const</span> std::string&amp; str) : <span class="hljs-built_in">data_</span>(str) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 基本操作</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123; data_ = str; &#125;<br>    <br>    <span class="hljs-comment">// 越来越多的成员函数...</span><br>    <span class="hljs-function">BadString <span class="hljs-title">toUpper</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">BadString <span class="hljs-title">toLower</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">BadString <span class="hljs-title">trim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">BadString <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; from, <span class="hljs-type">const</span> std::string&amp; to)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::vector&lt;BadString&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">char</span> delimiter)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; suffix)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; substring)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">BadString <span class="hljs-title">reverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">BadString <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> length)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toInt</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">toDouble</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">toHex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ... 还有更多功能</span><br>    <br>    <span class="hljs-comment">// 问题：</span><br>    <span class="hljs-comment">// 1. 类变得越来越大</span><br>    <span class="hljs-comment">// 2. 所有函数都能访问私有数据</span><br>    <span class="hljs-comment">// 3. 难以扩展</span><br>    <span class="hljs-comment">// 4. 编译依赖增加</span><br>&#125;;<br><br><span class="hljs-comment">// ✅ 简洁的核心类 + 非成员函数扩展</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodString</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string data_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoodString</span>(<span class="hljs-type">const</span> std::string&amp; str) : <span class="hljs-built_in">data_</span>(str) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 只包含核心操作</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123; data_ = str; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">length</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// string_transform.h</span><br><span class="hljs-keyword">namespace</span> StringTransform &#123;<br>    <span class="hljs-function">GoodString <span class="hljs-title">toUpper</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str)</span> </span>&#123;<br>        std::string result = str.<span class="hljs-built_in">get</span>();<br>        std::<span class="hljs-built_in">transform</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>(), ::toupper);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">GoodString</span>(result);<br>    &#125;<br>    <br>    <span class="hljs-function">GoodString <span class="hljs-title">toLower</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str)</span> </span>&#123;<br>        std::string result = str.<span class="hljs-built_in">get</span>();<br>        std::<span class="hljs-built_in">transform</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>(), ::tolower);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">GoodString</span>(result);<br>    &#125;<br>    <br>    <span class="hljs-function">GoodString <span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str)</span> </span>&#123;<br>        std::string result = str.<span class="hljs-built_in">get</span>();<br>        result.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, result.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>));<br>        result.<span class="hljs-built_in">erase</span>(result.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">GoodString</span>(result);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// string_query.h</span><br><span class="hljs-keyword">namespace</span> StringQuery &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str, <span class="hljs-type">const</span> std::string&amp; prefix)</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string&amp; data = str.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">length</span>() &gt;= prefix.<span class="hljs-built_in">length</span>() &amp;&amp; <br>               data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, prefix.<span class="hljs-built_in">length</span>()) == prefix;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str, <span class="hljs-type">const</span> std::string&amp; suffix)</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string&amp; data = str.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">length</span>() &gt;= suffix.<span class="hljs-built_in">length</span>() &amp;&amp; <br>               data.<span class="hljs-built_in">substr</span>(data.<span class="hljs-built_in">length</span>() - suffix.<span class="hljs-built_in">length</span>()) == suffix;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str, <span class="hljs-type">const</span> std::string&amp; substring)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str.<span class="hljs-built_in">get</span>().<span class="hljs-built_in">find</span>(substring) != std::string::npos;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// string_convert.h  </span><br><span class="hljs-keyword">namespace</span> StringConvert &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toInt</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">get</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">toDouble</span><span class="hljs-params">(<span class="hljs-type">const</span> GoodString&amp; str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stod</span>(str.<span class="hljs-built_in">get</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateStringDesign</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">GoodString <span class="hljs-title">text</span><span class="hljs-params">(<span class="hljs-string">&quot;  Hello World  &quot;</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 按需使用功能</span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringTransform;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringQuery;<br>    <br>    GoodString trimmed = <span class="hljs-built_in">trim</span>(text);<br>    GoodString upper = <span class="hljs-built_in">toUpper</span>(trimmed);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">startsWith</span>(upper, <span class="hljs-string">&quot;HELLO&quot;</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;String starts with HELLO&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><strong>选择非成员非友元函数的核心原因：</strong></p>
<ol>
<li><strong>更好的封装性</strong>：减少能访问私有数据的函数数量</li>
<li><strong>包装弹性</strong>：可以分布在不同的头文件和命名空间中</li>
<li><strong>扩展性</strong>：第三方可以轻松添加功能</li>
<li><strong>编译依赖性</strong>：客户端只需包含需要的功能</li>
</ol>
<p><strong>设计指导原则：</strong></p>
<ul>
<li><strong>核心类保持简洁</strong>：只包含必要的成员函数</li>
<li><strong>按功能组织非成员函数</strong>：使用命名空间分组</li>
<li><strong>提供良好的公共接口</strong>：让非成员函数能够完成工作</li>
<li><strong>遵循标准库模式</strong>：如STL算法的设计</li>
</ul>
<p><strong>何时使用成员函数：</strong></p>
<ul>
<li>需要访问私有数据时</li>
<li>虚函数需要多态行为时</li>
<li>运算符需要特殊语法时（如<code>[]</code>、<code>()</code>、<code>-&gt;</code>）</li>
</ul>
<p><strong>何时使用非成员函数：</strong></p>
<ul>
<li>可以通过公共接口实现时</li>
<li>提供便利功能时</li>
<li>扩展现有类功能时</li>
<li>支持类型转换时（运算符重载）</li>
</ul>
<p><strong>现代C++最佳实践：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 核心接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">coreOperation</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCoreData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data_;<br>&#125;;<br><br><span class="hljs-keyword">namespace</span> ModernClassUtils &#123;<br>    <span class="hljs-comment">// 扩展功能</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">convenienceFunction</span><span class="hljs-params">(ModernClass&amp; obj)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">derivedCalculation</span><span class="hljs-params">(<span class="hljs-type">const</span> ModernClass&amp; obj)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>记住：宁以non-member、non-friend替换member函数。这样做可以增加封装性、包装弹性（packaging flexibility）和机能扩充性。</strong></p>
<h2 id="条款24：-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24： 若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24： 若所有参数皆需类型转换，请为此采用non-member函数</h2><blockquote>
<p><em>Declare non-member functions when type conversions should apply to all parameters</em></p>
</blockquote>
<h3 id="核心理念-23"><a href="#核心理念-23" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member函数</strong>。这是因为只有non-member函数才能对所有参数实现隐式类型转换，而成员函数的第一个参数（this所指的对象）不会进行隐式类型转换。这在运算符重载中尤其重要，特别是当你希望支持混合类型运算时。</p>
<h3 id="深度解析-23"><a href="#深度解析-23" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-成员函数的类型转换限制"><a href="#1-成员函数的类型转换限制" class="headerlink" title="1. 成员函数的类型转换限制"></a>1. <strong>成员函数的类型转换限制</strong></h4><p>成员函数的隐式类型转换只作用于参数，而不作用于调用对象（this指针）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>)  <span class="hljs-comment">// 注意：非explicit</span><br>        : <span class="hljs-built_in">numerator_</span>(numerator), <span class="hljs-built_in">denominator_</span>(denominator) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>    <br>    <span class="hljs-comment">// ❌ 成员函数版本的乘法运算符</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(numerator_ * rhs.numerator_, <br>                       denominator_ * rhs.denominator_);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateMemberFunctionProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <br>    Rational result1 = oneHalf * oneEighth;  <span class="hljs-comment">// ✅ 正常工作</span><br>    Rational result2 = oneHalf * <span class="hljs-number">2</span>;          <span class="hljs-comment">// ✅ 正常工作：2被转换为Rational(2,1)</span><br>    <br>    <span class="hljs-comment">// Rational result3 = 2 * oneHalf;       // ❌ 编译错误！</span><br>    <span class="hljs-comment">// 等价于：2.operator*(oneHalf)</span><br>    <span class="hljs-comment">// 但是int类型没有operator*成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-非成员函数实现对称的类型转换"><a href="#2-非成员函数实现对称的类型转换" class="headerlink" title="2. 非成员函数实现对称的类型转换"></a>2. <strong>非成员函数实现对称的类型转换</strong></h4><p>非成员函数可以对所有参数进行隐式类型转换，实现完全对称的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>)  <span class="hljs-comment">// 允许隐式转换</span><br>        : <span class="hljs-built_in">numerator_</span>(numerator), <span class="hljs-built_in">denominator_</span>(denominator) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>    <br>    <span class="hljs-comment">// 提供必要的访问函数，供非成员函数使用</span><br>&#125;;<br><br><span class="hljs-comment">// ✅ 非成员函数版本：支持对称的类型转换</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateNonMemberFunctionSuccess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <br>    Rational result1 = oneHalf * oneEighth;  <span class="hljs-comment">// ✅ 正常工作</span><br>    Rational result2 = oneHalf * <span class="hljs-number">2</span>;          <span class="hljs-comment">// ✅ 正常工作：2转换为Rational(2,1)</span><br>    Rational result3 = <span class="hljs-number">2</span> * oneHalf;          <span class="hljs-comment">// ✅ 现在也正常工作了！</span><br>    <br>    <span class="hljs-comment">// 所有参数都可以进行隐式类型转换</span><br>    Rational result4 = <span class="hljs-number">3</span> * <span class="hljs-built_in">Rational</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) * <span class="hljs-number">5</span>;  <span class="hljs-comment">// ✅ 链式运算</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-完整的运算符重载设计"><a href="#3-完整的运算符重载设计" class="headerlink" title="3. 完整的运算符重载设计"></a>3. <strong>完整的运算符重载设计</strong></h4><p>设计一个支持混合类型运算的完整有理数类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br>    <br>    <span class="hljs-comment">// 辅助函数：求最大公约数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> temp = b;<br>            b = a % b;<br>            a = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 化简分数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simplify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (denominator_ &lt; <span class="hljs-number">0</span>) &#123;<br>            numerator_ = -numerator_;<br>            denominator_ = -denominator_;<br>        &#125;<br>        <span class="hljs-type">int</span> g = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(numerator_), <span class="hljs-built_in">abs</span>(denominator_));<br>        numerator_ /= g;<br>        denominator_ /= g;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：允许隐式转换</span><br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>)<br>        : <span class="hljs-built_in">numerator_</span>(numerator), <span class="hljs-built_in">denominator_</span>(denominator) &#123;<br>        <span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Denominator cannot be zero&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">simplify</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>    <br>    <span class="hljs-comment">// 类型转换函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(numerator_) / denominator_;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 一元运算符（作为成员函数）</span><br>    Rational <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(-numerator_, denominator_);<br>    &#125;<br>    <br>    Rational&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        numerator_ = numerator_ * rhs.denominator_ + rhs.numerator_ * denominator_;<br>        denominator_ *= rhs.denominator_;<br>        <span class="hljs-built_in">simplify</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    Rational&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> += (-rhs);<br>    &#125;<br>    <br>    Rational&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        numerator_ *= rhs.numerator_;<br>        denominator_ *= rhs.denominator_;<br>        <span class="hljs-built_in">simplify</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    Rational&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (rhs.numerator_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>        &#125;<br>        numerator_ *= rhs.denominator_;<br>        denominator_ *= rhs.numerator_;<br>        <span class="hljs-built_in">simplify</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 二元运算符：作为非成员函数，支持对称的类型转换</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() + rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs + (-rhs);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (rhs.<span class="hljs-built_in">numerator</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">numerator</span>());<br>&#125;<br><br><span class="hljs-comment">// 比较运算符</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() == rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>();<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() &lt; rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>();<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> rhs &lt; lhs;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs &gt; rhs);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs &lt; rhs);<br>&#125;<br><br><span class="hljs-comment">// 输入输出运算符</span><br><span class="hljs-keyword">inline</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Rational&amp; r) &#123;<br>    <span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">denominator</span>() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; r.<span class="hljs-built_in">numerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; r.<span class="hljs-built_in">numerator</span>() &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; r.<span class="hljs-built_in">denominator</span>();<br>&#125;<br><br><span class="hljs-keyword">inline</span> std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; is, Rational&amp; r) &#123;<br>    <span class="hljs-type">int</span> numerator, denominator = <span class="hljs-number">1</span>;<br>    is &gt;&gt; numerator;<br>    <br>    <span class="hljs-keyword">if</span> (is.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        is.<span class="hljs-built_in">ignore</span>();  <span class="hljs-comment">// 跳过&#x27;/&#x27;</span><br>        is &gt;&gt; denominator;<br>    &#125;<br>    <br>    r = <span class="hljs-built_in">Rational</span>(numerator, denominator);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-类型转换的实际应用示例"><a href="#4-类型转换的实际应用示例" class="headerlink" title="4. 类型转换的实际应用示例"></a>4. <strong>类型转换的实际应用示例</strong></h4><p>展示非成员函数如何实现自然的混合类型运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateSymmetricOperations</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">half</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Rational <span class="hljs-title">quarter</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// ✅ 所有这些表达式都能工作</span><br>    Rational result1 = half + quarter;      <span class="hljs-comment">// Rational + Rational</span><br>    Rational result2 = half + <span class="hljs-number">1</span>;            <span class="hljs-comment">// Rational + int</span><br>    Rational result3 = <span class="hljs-number">2</span> + half;            <span class="hljs-comment">// int + Rational</span><br>    Rational result4 = half * <span class="hljs-number">3</span>;            <span class="hljs-comment">// Rational * int  </span><br>    Rational result5 = <span class="hljs-number">4</span> * quarter;         <span class="hljs-comment">// int * Rational</span><br>    <br>    <span class="hljs-comment">// ✅ 复杂表达式也能自然工作</span><br>    Rational result6 = <span class="hljs-number">1</span> + half * <span class="hljs-number">2</span> - quarter / <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-comment">// ✅ 比较操作也支持混合类型</span><br>    <span class="hljs-keyword">if</span> (half &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;half is positive&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * quarter == half) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2 * quarter equals half&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 输出操作</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Results: &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> <br>              &lt;&lt; result3 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result4 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result5 &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// ✅ 链式运算</span><br>    Rational complex = (half + <span class="hljs-number">1</span>) * (quarter - <span class="hljs-number">2</span>) / (<span class="hljs-number">3</span> + result1);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Complex calculation: &quot;</span> &lt;&lt; complex &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-设计考虑和最佳实践"><a href="#5-设计考虑和最佳实践" class="headerlink" title="5. 设计考虑和最佳实践"></a>5. <strong>设计考虑和最佳实践</strong></h4><p>在实现支持类型转换的运算符时需要考虑的重要因素。</p>
<p><strong>explicit构造函数的权衡：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrictRational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_, denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ explicit构造函数：防止意外的隐式转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">StrictRational</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">        : numerator_(numerator), denominator_(denominator) &#123;</span>&#125;<br>    <br>    <span class="hljs-comment">// 提供显式的类型转换函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> StrictRational <span class="hljs-title">fromInt</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StrictRational</span>(value, <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 非成员函数需要显式转换</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> StrictRational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> StrictRational&amp; lhs, <span class="hljs-type">const</span> StrictRational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StrictRational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateExplicitConversion</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">StrictRational <span class="hljs-title">half</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// StrictRational result1 = half * 2;          // ❌ 编译错误</span><br>    StrictRational result2 = half * <span class="hljs-built_in">StrictRational</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// ✅ 显式转换</span><br>    StrictRational result3 = half * StrictRational::<span class="hljs-built_in">fromInt</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// ✅ 工厂函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>性能考虑：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回值优化：返回对象而不是引用</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs) &#123;<br>    <span class="hljs-comment">// 现代编译器会进行RVO（返回值优化），通常不会有额外的拷贝</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() + rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>(),<br>                   lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-comment">// 使用移动语义进一步优化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernRational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_, denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ModernRational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ModernRational</span>(ModernRational&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">numerator_</span>(other.numerator_), <span class="hljs-built_in">denominator_</span>(other.denominator_) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    ModernRational&amp; <span class="hljs-keyword">operator</span>=(ModernRational&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        numerator_ = other.numerator_;<br>        denominator_ = other.denominator_;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 支持移动语义的运算符</span><br><span class="hljs-keyword">inline</span> ModernRational <span class="hljs-keyword">operator</span>+(ModernRational lhs, <span class="hljs-type">const</span> ModernRational&amp; rhs) &#123;<br>    lhs += rhs;  <span class="hljs-comment">// 复用+=运算符</span><br>    <span class="hljs-keyword">return</span> lhs;  <span class="hljs-comment">// 返回修改后的lhs（可能触发移动）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-常见陷阱和解决方案"><a href="#6-常见陷阱和解决方案" class="headerlink" title="6. 常见陷阱和解决方案"></a>6. <strong>常见陷阱和解决方案</strong></h4><p>避免在实现非成员运算符时遇到的常见问题。</p>
<p><strong>避免无限递归：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadRational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BadRational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>) : <span class="hljs-built_in">num_</span>(n), <span class="hljs-built_in">den_</span>(d) &#123;&#125;<br>    <br>    <span class="hljs-comment">// ❌ 这会导致无限递归！</span><br>    BadRational&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> BadRational&amp; rhs) &#123;<br>        *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> + rhs;  <span class="hljs-comment">// 调用operator+，而operator+又调用operator+=</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_, den_;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 正确的实现：直接计算，不依赖其他运算符</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> BadRational <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> BadRational&amp; lhs, <span class="hljs-type">const</span> BadRational&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">BadRational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>() + rhs.<span class="hljs-built_in">numerator</span>() * lhs.<span class="hljs-built_in">denominator</span>(),<br>                      lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>处理特殊情况：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RobustRational</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_, denominator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RobustRational</span>(<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> den = <span class="hljs-number">1</span>) : <span class="hljs-built_in">numerator_</span>(num), <span class="hljs-built_in">denominator_</span>(den) &#123;<br>        <span class="hljs-keyword">if</span> (den == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Zero denominator&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> numerator_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> denominator_; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 处理除零等特殊情况</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> RobustRational <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> RobustRational&amp; lhs, <span class="hljs-type">const</span> RobustRational&amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (rhs.<span class="hljs-built_in">numerator</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">RobustRational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">denominator</span>(),<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">numerator</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><strong>何时使用非成员函数：</strong></p>
<ol>
<li><strong>需要对所有参数进行类型转换时</strong>（如对称的二元运算符）</li>
<li><strong>不需要访问私有成员时</strong></li>
<li><strong>希望支持链式操作时</strong></li>
<li><strong>实现标准库风格的接口时</strong></li>
</ol>
<p><strong>实现要点：</strong></p>
<ul>
<li><strong>提供足够的公共接口</strong>：让非成员函数能够完成工作</li>
<li><strong>考虑性能</strong>：返回值优化和移动语义</li>
<li><strong>处理异常情况</strong>：边界条件和错误处理</li>
<li><strong>保持一致性</strong>：运算符的语义要符合直觉</li>
</ul>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>对称性</strong>：<code>a op b</code>和<code>b op a</code>应该都能工作（如果语义上合理）</li>
<li><strong>组合性</strong>：运算符应该能够自然地组合使用</li>
<li><strong>效率</strong>：避免不必要的拷贝和转换</li>
<li><strong>安全性</strong>：提供适当的错误检查</li>
</ul>
<p><strong>记住：如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member函数。</strong></p>
<h2 id="条款25：考虑写出一个不抛异常的-swap-函数"><a href="#条款25：考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款25：考虑写出一个不抛异常的 swap 函数"></a>条款25：考虑写出一个不抛异常的 swap 函数</h2><blockquote>
<p><em>Consider writing a swap that won’t throw exceptions</em></p>
</blockquote>
<hr>
<h3 id="核心理念-24"><a href="#核心理念-24" class="headerlink" title="核心理念"></a>核心理念</h3><p>在 <code>C++</code> 中，<code> swap</code> 是一个基础操作，尤其在 <code>STL</code> 容器、排序算法和资源管理类中被广泛使用。为了确保程序的强异常安全保证， 你十分应该为你的类型提供一个不会抛出异常的（<code>noexcept</code>） 的 <code>swap</code> 函数。</p>
<p>原因是，如果你的类型使用了自定义资源（比如动态内存、文件句柄等）， 默认的 <code>std::swap</code> 可能调用拷贝构造&#x2F;赋值操作，这些操作很有可能抛出异常， 从而破坏程序的稳定性！</p>
<hr>
<h3 id="深度解析-24"><a href="#深度解析-24" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-标准库依赖-swap-的异常安全性"><a href="#1-标准库依赖-swap-的异常安全性" class="headerlink" title="1. 标准库依赖 swap 的异常安全性"></a>1. 标准库依赖 <code>swap</code> 的异常安全性</h4><ul>
<li>STL 算法（如 <code>sort</code>）使用 <code>swap</code>，假设它 <strong>不会抛出异常</strong>；</li>
<li>STL 容器内部操作（如 <code>resize</code>、<code>insert</code>）常以 <code>swap</code> 实现元素的移动；</li>
<li>如果 <code>swap</code> 抛出异常，<strong>STL 的异常安全保证会失效</strong>，导致<strong>资源泄漏或未定义行为</strong>。</li>
</ul>
<h4 id="2-编写自定义的-swap（）函数"><a href="#2-编写自定义的-swap（）函数" class="headerlink" title="2. 编写自定义的 swap（）函数"></a>2. 编写自定义的 <code>swap（）</code>函数</h4><ul>
<li>为类提供专门的<code>swap ()</code>成员函数，让他内部只用<code>noexcept</code>的成员变量 <code>swap</code>。</li>
<li>在全局或 <code>std </code>命名空间中为你的类型提供重载的 <code>swap</code>；</li>
<li>使用&#96;&#96;std::swap<code> 替换你自己变量的交换前， 确保它是</code> noexcept&#96;的。</li>
</ul>
<h4 id="3-使用-noexcept-关键字提高效率"><a href="#3-使用-noexcept-关键字提高效率" class="headerlink" title="3. 使用 noexcept 关键字提高效率"></a>3. 使用 <code>noexcept</code> 关键字提高效率</h4><ul>
<li>在<code>C++11</code>以及以后标准， <code>noexcept</code> 让编译器知道某函数不会抛出异常。</li>
<li>如果你提供了<code>noexcept swap（）</code>， 容器在任意移动的过程中应该优先使用它来优化性能。</li>
</ul>
<h4 id="示例：-合理封装-swap-的成员函数"><a href="#示例：-合理封装-swap-的成员函数" class="headerlink" title="示例： 合理封装 swap 的成员函数"></a>示例： <strong>合理封装 <code>swap </code>的成员函数</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Widget</span> (std::string name, <span class="hljs-type">int</span> id)<br>        : _name(std::<span class="hljs-built_in">move</span>(name))<br>            , _id(id)<br>        &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        _name.<span class="hljs-built_in">swap</span>(other._name);<br>        std::<span class="hljs-built_in">swap</span>(_id, other._id);<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    <span class="hljs-type">int</span> _id<br>&#125;;<br><br><span class="hljs-comment">// 提供 std::swap 特化，便于使用 ADL 查找你的 swap</span><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt; (Widget&amp; a, Widget&amp;b) <span class="hljs-keyword">noexcept</span> &#123;<br>        a.<span class="hljs-built_in">swap</span>(b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不推荐！这种拷贝型很可能让你在临时对象构造或者赋值的过程中抛出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; a, Widget&amp; b)</span> </span>&#123;<br>    Widget temp = a; <br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="拓展建议："><a href="#拓展建议：" class="headerlink" title="拓展建议："></a>拓展建议：</h3><h4 id="1-copy-and-swap-习惯用法依赖-noexcept"><a href="#1-copy-and-swap-习惯用法依赖-noexcept" class="headerlink" title="1. copy-and-swap 习惯用法依赖 noexcept"></a>1. <code>copy-and-swap</code> 习惯用法依赖 noexcept</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Wiget</span>(<span class="hljs-type">const</span> Widget&amp; other);<br>    widget&amp; <span class="hljs-keyword">operator</span>=(Widget other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-built_in">swap</span>(other);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 这个模式背后的思想是：</span><br><span class="hljs-comment">// 1. 先拷贝 rhs（安全，不会影响当前对象）；</span><br><span class="hljs-comment">// 2. 再交换当前对象和 rhs 的内容；</span><br><span class="hljs-comment">// 3. 原先的 rhs 被析构，释放旧资源，当前对象拥有新值。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>如果 <code>swap()</code> 抛异常，<code>operator=</code> 将无法保持类的不变式。</li>
<li>因此 <code>copy-and-swap</code> 模式的前提是：<strong><code>swap()</code> 必须 <code>noexcept</code></strong>。</li>
</ul>
<h4 id="2-拓展：什么类型容易抛出异常呢？"><a href="#2-拓展：什么类型容易抛出异常呢？" class="headerlink" title="2.  拓展：什么类型容易抛出异常呢？"></a>2.  拓展：什么类型容易抛出异常呢？</h4><ol>
<li><p><strong>依赖动态内存分配的类型</strong>，</p>
<ol>
<li>比如 <code>std::vector</code>, <code>std::string</code>, <code>std::map</code>，如果内存不够，会抛出异常（<code>std::bad_alloc</code>）</li>
</ol>
</li>
<li><p><strong>类里有STL容器成员</strong>，</p>
<ul>
<li><pre><code class="language-c++">class A {
    std::vector&lt;int&gt; data;
};
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**资源管理类 （RAII）**</span><br><br><span class="hljs-bullet">   1.</span> 管文件、锁、网络,比如 <span class="hljs-code">`std::ifstream`</span>, 打开失败可能抛异常<br><br><span class="hljs-bullet">4.</span> <span class="hljs-strong">**自定义 swap 没写 noexcept**</span><br><br><span class="hljs-bullet">   1.</span> 如果 swap 里面用了可能抛异常的操作（如 vector swap），就不安全<br><br>------<br><br><span class="hljs-section">### 小结</span><br><br><span class="hljs-code">`swap()`</span> 会不会抛异常，取决于它所交换的成员变量是否在 <span class="hljs-code">`swap`</span> 的过程中可能抛出异常。<span class="hljs-strong">**在实现 `swap（）`时，应当将它标记为 `noexcept`， 并确保其中所有 `swap()`操作本身也是`noexcept`的，**</span>从而保证 <span class="hljs-code">`copy-and-swap`</span> 模式的异常安全！<br><br>反正就一句话，有堆内存或<span class="hljs-code">`` STL`</span> 容器的类型，<span class="hljs-code">`swap`</span> 可能抛异常；原始类型和简单 <span class="hljs-code">` struct `</span>一般不会抛!<br><br>------<br><br><span class="hljs-section">## 条款26：尽可能延后变量定义式的出现时间</span><br><br><span class="hljs-quote">&gt; <span class="hljs-emphasis">*Postpone variable definitions as long as possible*</span></span><br><br><span class="hljs-section">### 核心理念</span><br><br>在<span class="hljs-code">`C++`</span>中，你最好将变量的定义<span class="hljs-strong">**延后到真正需要并能立即初始化的时候**</span>。这样可以<span class="hljs-strong">**避免不必要的构造和析构操作，减少资源浪费**</span>；如果构造函数抛出异常，也能确保<span class="hljs-strong">**异常发生在  `try `块内部，可以及时捕获**</span>；另一方面使用起来<span class="hljs-strong">**逻辑更清晰，代码紧凑一点也不容易出错**</span>。<br><br><span class="hljs-section">### 深度解析</span><br><br><span class="hljs-section">#### 1.避免无意义的构造、析构</span><br><br><span class="hljs-bullet">-</span> 如果你提前定义了一个变量但后面没用到，它的构造和析构就是<span class="hljs-strong">**纯浪费**</span>。<br><span class="hljs-bullet">-</span> 特别是像 <span class="hljs-code">`std::vector`</span>、<span class="hljs-code">`std::string`</span>、文件流等这些<span class="hljs-strong">**资源敏感型对象**</span>，构造一次就有开销。<br><span class="hljs-bullet">-</span> 等到真要用的时候再创建，才是对资源负责的做法。<br><br><span class="hljs-section">####  2. 提升异常安全性</span><br><br><span class="hljs-bullet">-</span> 构造函数一旦抛异常，而变量又定义在 <span class="hljs-code">`try`</span> 块外，就<span class="hljs-strong">**无法被捕获**</span>，可能导致程序崩溃。<br><span class="hljs-bullet">-</span>  <span class="hljs-strong">**应在 `try` 内构造对象**</span>，而不是在 <span class="hljs-code">`try`</span> 外先定义<br><br><span class="hljs-section">#### 3. 更少的作用域， 管理更简单，代码更清晰。	</span><br><br><span class="hljs-bullet">-</span> 延迟定义自然缩短变量生命周期，使作用域最小化，<span class="hljs-strong">**被误用或重复使用的可能性越低**</span>。。<br><span class="hljs-bullet">-</span> 延迟定义能让变量和它的用途靠得很近，<span class="hljs-strong">**逻辑更紧凑，可读性更好**</span>。<br><br>------<br><br><span class="hljs-section">#### 总结</span><br><br><span class="hljs-quote">&gt; 合理推迟变量定义时机，是写出资源高效、安全且可读性强代码的重要习惯。</span><br><br>-------<br><br><span class="hljs-section">## 条款27：避免返回局部变量的指针或引用</span><br><br><span class="hljs-quote">&gt; <span class="hljs-emphasis">*Avoid returning pointers or references to local objects*</span></span><br><br><span class="hljs-section">### 核心理念</span><br><br>绝不能返回指向局部变量的指针或者引用，因为局部变量在函数结束时销毁，指针或引用将变成悬空指针，一旦被访问，可能会引发未定义行为。<br><br><span class="hljs-section">### 深度解析</span><br><br><span class="hljs-section">#### 1.局部对象的生命周期短暂</span><br><br><span class="hljs-bullet">-</span> 函数结束后，局部对象被销毁，返回的指针或引用指向无效内存。<br><br><span class="hljs-section">####  2. 访问悬空指针导致未定义行为</span><br><br><span class="hljs-bullet">-</span> 局部变量通常被分配在栈空间上，函数返回时，栈指针向上移动，局部变量所占用的内存被释放。<br><span class="hljs-bullet">-</span> 函数返回后，局部变量的内存空间并不会被立即清空，而是标记为&quot;可重用&quot;。<br><span class="hljs-bullet">-</span> 所以访问局部变量的悬空指针，等同于访问一个已经被&quot;释放&quot;或者被其他数据覆盖的栈内存区域，CPU无法阻止这类，产生的未定义行为就很容易引起程序崩溃等安全问题！<br><br><span class="hljs-section">#### 3. 确保返回的指针或引用指向有效对象</span><br><br><span class="hljs-bullet">-</span> 有些场景不得不返回指针或引用，（比如为了避免拷贝开销，或者访问已经存在的对象）<br><span class="hljs-bullet">-</span> 但必须保证<span class="hljs-strong">**返回的地址指向的对象生命周期比调用者更长**</span>，避免悬挂指针。<br><br><span class="hljs-section">### 拓展建议</span><br><br><span class="hljs-section">#### 1. 优先按值返回对象。</span><br><br><span class="hljs-bullet">-</span> #### 虽然传统按值返回相当于给调用者拷贝了一份局部对象的副本。<span class="hljs-strong">**但在 C++ 11中，返回对象的值结合移动语义和返回值优化（RVO，）直接在调用者内存构造返回对象，跳过拷贝已经足够高效，无需刻意返回引用或指针来提高性能。**</span><br><br><span class="hljs-bullet">-</span> 当 RVO 不能应用时，编译器使用<span class="hljs-strong">**移动构造函数**</span>替代拷贝构造，<span class="hljs-strong">**转移资源所有权，极大减少性能开销**</span>。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**拷贝语义**</span>是把对象的内容（比如堆上的数组、字符串缓冲区等）完整复制一份，两个对象各自拥有独立的资源，开销较大。<br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**移动语义**</span>则是把原对象内部的指针或者资源句柄直接&quot;搬给&quot;新对象，新对象接管资源所有权，原对象则置为空或恢复到一个&quot;空壳&quot;状态，避免了实际数据的复制。<br><br><span class="hljs-code">```c++</span><br><span class="hljs-code">std::vector&lt;int&gt; v1 = &#123;1, 2, 3, 4&#125;;</span><br><span class="hljs-code"></span><br><span class="hljs-code">// 传统拷贝：复制整个数组，两个 vector 各有独立内存</span><br><span class="hljs-code">std::vector&lt;int&gt; v2 = v1;  </span><br><span class="hljs-code"></span><br><span class="hljs-code">// 移动语义：v2 直接拿走 v1 的内部数组指针，v1 变为空</span><br><span class="hljs-code">std::vector&lt;int&gt; v3 = std::move(v1);</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="2-使用智能指针管理需要返回的动态对象。"><a href="#2-使用智能指针管理需要返回的动态对象。" class="headerlink" title="2. 使用智能指针管理需要返回的动态对象。"></a>2. 使用智能指针管理需要返回的动态对象。</h4><ul>
<li><p>当函数创建一个动态分配的对象（用 <code>new</code>），且该对象的生命周期需要超出函数本身（即不能局限在函数内部，可能被多个函数或对象共享使用），这时直接返回裸指针非常危险：</p>
</li>
<li><p>若要返回指针，请使用智能指针（<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）管理对象生命周期，防止悬空指针和内存泄漏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getUniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 动态分配，返回智能指针</span><br>&#125;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getUniquePtr2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* rawPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// new 分配普通指针</span><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(rawPtr);  <span class="hljs-comment">// 用 unique_ptr 包装返回</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p = <span class="hljs-built_in">getUniquePtr</span>();<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p = <span class="hljs-built_in">getUniquePtr</span>();<br>    std::cout &lt;&lt; *p &lt;&lt; std::endl;  <span class="hljs-comment">// 安全访问</span><br>    <span class="hljs-comment">// 不用手动 delete，智能指针自动释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>调用者不需要担心内存何时释放，智能指针会自动帮你管理。</p>
<ul>
<li><p><code>unique_ptr</code> 表示只有一个所有者，明确谁负责销毁。</p>
</li>
<li><p><code>shared_ptr</code> 表示多个所有者共享，直到最后一个销毁才释放资源。</p>
</li>
<li><pre><code class="language-c++">std::unique_ptr&lt;Foo&gt; createUniqueFoo() {
    return std::make_unique&lt;Foo&gt;();  // 返回唯一所有权，调用者接管
}

std::shared_ptr&lt;Foo&gt; createSharedFoo() {
    return std::make_shared&lt;Foo&gt;();  // 返回共享所有权，多个调用者可共享
}
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br><br>### 总结<br><br>&gt; 返回局部对象的指针或引用是大忌，合理使用按值返回和智能指针，才能写出安全高效的现代 C++ 代码。<br><br><br><br>## 条款<span class="hljs-number">28</span>：避免返回句柄到对象内部成分<br><br><br><br>#### 一、什么是 <span class="hljs-string">&quot;句柄&quot;</span> 与 <span class="hljs-string">&quot;对象内部成分&quot;</span>？<br><br>- **句柄（Handle）**：在 C++ 中通常指**指针、引用或迭代器**，它们能直接访问对象的内部数据或成员。<br>- **对象内部成分**：指类中被封装的私有成员变量（如指针、数组、容器等）或嵌套对象。<br><br>### 🔍核心观点<br><br>&gt; **返回句柄（指针 / 引用 / 迭代器）会绕过接口层**，让外部代码直接触碰内部实现。这样就破坏了**封装的本质：隔离变化，隐藏实现细节。**例如，如果类中某资源已经析构，却依然被外部对象持有句柄，就会不可控，这种失控很有可能引发悬空指针、数据越界等运行时未定义行为！无论从数据一致性的破坏、生命周期的风险还是违反类内不变式等角度来看，都应该**尽量避免将类内资源控制权直接交给外部，尽量帮助 `const`成员函数的行为像 `const`,将发生 `dangling handls` 的可能性降到最低。**这样才能遵循<span class="hljs-string">&quot;最小暴露原则&quot;</span>，用访问接口替代句柄返回。<br><br>### 🧱关键要点解析<br><br>####  <span class="hljs-number">1</span>， 封装破坏：从 <span class="hljs-string">&quot;接口控制&quot;</span> 到 <span class="hljs-string">&quot;直接操作&quot;</span> 的失控<br><br>- 封装要求通过公有方法（如`setAge()`）管理私有数据，而返回句柄（如`int&amp; getAge()`）允许外部直接修改`age`，绕过方法内的校验逻辑（如年龄不能为负数）。<br><br>- ```C++<br>  <span class="hljs-keyword">class</span> Date &#123;<br>  private:<br>      int day, month, year;<br>  public:<br>      int&amp; getDay() &#123; return day; &#125;  <span class="hljs-comment">// 错误：外部可直接赋值day=-5</span><br>      void setDay(int d) &#123; <span class="hljs-keyword">if</span> (d&gt;<span class="hljs-number">0</span> &amp;&amp; d&lt;=<span class="hljs-number">31</span>) day = d; &#125;  <span class="hljs-comment">// 正确的校验逻辑被绕过</span><br>  &#125;;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2，-数据一致性：业务规则失效的隐患"><a href="#2，-数据一致性：业务规则失效的隐患" class="headerlink" title="2， 数据一致性：业务规则失效的隐患"></a>2， 数据一致性：业务规则失效的隐患</h4><ul>
<li>类的内部数据需满足特定约束（如容器大小<code>size &gt;= 0</code>），句柄返回允许外部破坏这些约束。</li>
<li>金融类<code>Account</code>的余额<code>balance</code>通过句柄被设为负数，绕过 “不能透支” 的业务规则；</li>
<li>数组类<code>Array</code>的长度<code>length</code>被直接修改，导致访问越界。</li>
</ul>
<h4 id="3，-生命周期风险：悬垂句柄的致命陷阱"><a href="#3，-生命周期风险：悬垂句柄的致命陷阱" class="headerlink" title="3， 生命周期风险：悬垂句柄的致命陷阱"></a>3， 生命周期风险：悬垂句柄的致命陷阱</h4><ul>
<li>句柄指向的内部对象已经被销毁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">private</span>:<br>	cahr* data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> data;<br>	&#125;<br>	~<span class="hljs-built_in">Resource</span>() &#123;<br>		<span class="hljs-keyword">delete</span> [] date;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">char</span>*ptr = res.<span class="hljs-built_in">getData</span>();	<br>res.~<span class="hljs-built_in">Resource</span>();     <span class="hljs-comment">// 销毁对象	</span><br>*ptr = <span class="hljs-string">&#x27;a&#x27;</span>;			 <span class="hljs-comment">// 访问已释放的内存，引发段错误</span><br></code></pre></td></tr></table></figure>

<ul>
<li>容器迭代器因为修改容器失效</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br>vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">// 容器结构改变，it失效</span><br>*it = <span class="hljs-number">10</span>；				<span class="hljs-comment">//访问了失效迭代器</span><br></code></pre></td></tr></table></figure>

<h4 id="4，-类不变式（Invariant）的破坏"><a href="#4，-类不变式（Invariant）的破坏" class="headerlink" title="4， 类不变式（Invariant）的破坏"></a>4， 类不变式（Invariant）的破坏</h4><ul>
<li><p><strong>不变式定义</strong>：类在任何操作后必须保持的状态约束（如<code>Rectangle</code>的宽高必须为正）。</p>
</li>
<li><p><strong>句柄的威胁</strong>：外部通过句柄修改数据，可能导致不变式失效。</p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> width, height;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> width;<br>	&#125;	<span class="hljs-comment">// 允许外部设width = -10；</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5，const成员函数的防御：让-“只读”-真正只读"><a href="#5，const成员函数的防御：让-“只读”-真正只读" class="headerlink" title="5，const成员函数的防御：让 “只读” 真正只读"></a>5，<code>const</code>成员函数的防御：让 “只读” 真正只读</h4><ul>
<li><p><code>const</code>成员函数应避免返回非<code>const</code>句柄，防止通过句柄修改<code>const</code>对象的内部数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstObj</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;  <span class="hljs-comment">// 允许修改const对象的value！</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;  <span class="hljs-comment">// 只读引用，这才是正确做法！！！</span><br>&#125;;<br><span class="hljs-type">const</span> ConstObj obj;<br>obj.<span class="hljs-built_in">getValue</span>() = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 编译通过，但修改了const对象</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结：封装的本质是-“控制权”-的保留"><a href="#总结：封装的本质是-“控制权”-的保留" class="headerlink" title="总结：封装的本质是 “控制权” 的保留"></a>总结：封装的本质是 “控制权” 的保留</h3><blockquote>
<p>返回句柄的核心问题在于将对象内部数据的 “控制权” 让渡给外部，导致类无法保证自身状态的合法性。遵循条款 28 的本质是：<strong>让对象对自己的状态完全负责，外部仅能通过安全接口进行交互</strong>，这是面向对象设计中 “封装性” 的核心价值。</p>
</blockquote>
<h2 id="条款29：为”异常安全”而努力是值得的！"><a href="#条款29：为”异常安全”而努力是值得的！" class="headerlink" title="条款29：为”异常安全”而努力是值得的！"></a>条款29：为”异常安全”而努力是值得的！</h2><blockquote>
<p><em>Striving for exception safety is worth it!</em></p>
</blockquote>
<h3 id="核心理念-25"><a href="#核心理念-25" class="headerlink" title="核心理念"></a>核心理念</h3><p>在 C++ 中，<strong>异常安全</strong>是指即使发生异常，函数也不会泄露资源或导致数据结构的损坏。为了实现这一点，异常安全函数通常会提供以下三种可能的保证：</p>
<ul>
<li><strong>基本保证</strong>：即使发生异常，程序内的资源将得到正确释放，且所有对象保持一致性。虽然状态不会被破坏，但数据结构可能处于一种不可预料的状态。</li>
<li><strong>强烈保证</strong>：如果发生异常，程序状态不发生改变。调用这样的函数时，要有一个认识：若函数成功执行，程序将达到预期的状态；若发生异常，程序将返回到函数调用前的状态。</li>
<li><strong>不抛异常保证</strong>：承诺函数执行过程中绝对不会抛出异常。对内置类型（如 <code>int</code>、指针等）进行的操作都提供 <code>nothrow</code> 保证，这是异常安全代码的基础。</li>
</ul>
<h3 id="深度解析-25"><a href="#深度解析-25" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-异常安全的三种保证"><a href="#1-异常安全的三种保证" class="headerlink" title="1. 异常安全的三种保证"></a>1. <strong>异常安全的三种保证</strong></h4><ul>
<li><strong>基本保证</strong>：<ul>
<li>如果函数抛出异常，资源会得到释放，数据结构会保持一致性，但状态无法回滚到原始状态。换句话说，内部数据可能会发生变化，但没有泄露资源或进入不一致的状态。</li>
</ul>
</li>
<li><strong>强烈保证</strong>：<ul>
<li><strong>强烈保证</strong>的核心是”如果发生异常，程序状态不发生改变”。它确保函数要么完全成功，要么完全失败，若发生异常，程序将恢复到调用函数之前的状态。这种保证通常通过 <strong>copy-and-swap</strong> 模式来实现。</li>
<li><strong>copy-and-swap</strong> 模式通过拷贝构造一个临时对象，执行操作并交换对象的状态，从而保证函数即使在发生异常时也能保持程序的状态一致性。</li>
</ul>
</li>
<li><strong>不抛异常保证</strong>：<ul>
<li>函数承诺执行过程中绝对不会抛出任何异常。内置类型（如 <code>int</code>、<code>char*</code> 等）通常会提供 <code>nothrow</code> 保证。对于函数来说，能够提供不抛异常保证是异常安全代码的基础。</li>
</ul>
</li>
</ul>
<h4 id="2-强烈保证的实现：copy-and-swap模式"><a href="#2-强烈保证的实现：copy-and-swap模式" class="headerlink" title="2. 强烈保证的实现：copy-and-swap模式"></a>2. <strong>强烈保证的实现：copy-and-swap模式</strong></h4><p><strong>copy-and-swap</strong> 是实现强烈保证的经典方法。通过这种方式，函数的执行被”分为两步”：首先执行拷贝构造，创建一个临时副本；接着，如果没有发生异常，交换两个对象的状态。若发生异常，临时对象会被销毁，原对象保持不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-built_in">swap</span>(other);  <span class="hljs-comment">// 使用 copy-and-swap 模式实现强烈保证</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_data, other._data);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; _data;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>operator=</code> 使用了拷贝构造创建一个临时对象，这样即使赋值过程中发生异常，原对象和临时对象的状态也能互换，保持强烈保证。</p>
<h4 id="3-异常安全性传播规则"><a href="#3-异常安全性传播规则" class="headerlink" title="3. 异常安全性传播规则"></a>3. <strong>异常安全性传播规则</strong></h4><p>函数的异常安全保证通常等于它所调用的其他函数的最弱保证。如果你调用的函数提供的是 <strong>基本保证</strong>，那么你自己的函数也只能提供 <strong>基本保证</strong>。例如：</p>
<ul>
<li>如果你调用的底层函数无法提供强烈保证，那么你自己的函数即使尝试实现强烈保证，也会受到限制，最终只能提供基本保证。</li>
</ul>
<p>这种传播规则意味着，编写异常安全代码时，除了保证自己的函数具备异常安全性外，还应确保所调用的函数具备相应的异常安全保证。</p>
<h4 id="4-异常安全与资源管理"><a href="#4-异常安全与资源管理" class="headerlink" title="4. 异常安全与资源管理"></a>4. <strong>异常安全与资源管理</strong></h4><p>资源管理类（如 <code>std::vector</code>、<code>std::string</code>）已经实现了强烈保证，因此直接使用这些类时，可以依赖其提供的异常安全保障。RAII（资源获取即初始化）原则在此类管理中起到了关键作用，确保资源在析构时自动释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandler</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FileHandler</span>(<span class="hljs-type">const</span> std::string&amp; filename) : <span class="hljs-built_in">file_</span>(std::<span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;r&quot;</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (!file_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;File open failed&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FileHandler</span>() &#123;<br>        <span class="hljs-keyword">if</span> (file_) std::<span class="hljs-built_in">fclose</span>(file_);<br>    &#125;<br><br>    <span class="hljs-comment">// 提供强烈保证的移动构造和赋值</span><br>    <span class="hljs-built_in">FileHandler</span>(FileHandler&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">file_</span>(other.file_) &#123;<br>        other.file_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    FileHandler&amp; <span class="hljs-keyword">operator</span>=(FileHandler&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">if</span> (file_) std::<span class="hljs-built_in">fclose</span>(file_);<br>            file_ = other.file_;<br>            other.file_ = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    FILE* file_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-选择适当的异常安全保证"><a href="#5-选择适当的异常安全保证" class="headerlink" title="5. 选择适当的异常安全保证"></a>5. <strong>选择适当的异常安全保证</strong></h4><p>对于每个函数，选择适当的异常安全保证是很重要的。一般而言，提供 <strong>强烈保证</strong> 是理想的，但并不是所有函数都能实现或适用这一保证，尤其是在可能抛出异常的情况下，提供 <strong>基本保证</strong> 或 <strong>不抛异常保证</strong> 更加现实。</p>
<p>在大多数情况下，提供 <strong>强烈保证</strong> 或 <strong>基本保证</strong> 是最常见的选择。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>为异常安全而努力是值得的</strong>。通过提供 <strong>基本保证</strong>、<strong>强烈保证</strong> 和 <strong>不抛异常保证</strong>，你可以确保函数即使在遇到异常时也不会破坏数据结构或泄露资源。虽然 <strong>强烈保证</strong> 是最理想的，但它并不适用于所有场景。我们应该根据实际情况，尽力为函数提供合适的异常安全保证，确保程序在异常发生时保持稳定和一致。</p>
<ul>
<li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以copy-and-swap 实现出来， 但”强烈保证”并非对素有函数都可实现或者具备现实意义。</li>
<li>函数提供的”异常安全保证”通常最高值等于其所调用之各个函数的”异常安全保证”中的最弱者。</li>
</ul>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><blockquote>
<p><em>Understand the ins and outs of inlining</em></p>
</blockquote>
<h3 id="核心理念-26"><a href="#核心理念-26" class="headerlink" title="核心理念"></a>核心理念</h3><p><code>inline</code>函数是一把双刃剑：它能通过消除函数调用开销来提升性能，但过度使用会导致代码膨胀、调试困难和二进制兼容性问题。理解<code>inline</code>的工作机制、适用场景和潜在陷阱，是写出高效C++代码的关键。</p>
<p><strong>关键原则：将大多数inlining限制在小型、被频繁调用的函数身上，这可使日后的调试过程和二进制升级更容易，也可以使潜在的代码膨胀问题最小化。</strong></p>
<h3 id="深度解析-26"><a href="#深度解析-26" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-inline的本质：建议而非强制"><a href="#1-inline的本质：建议而非强制" class="headerlink" title="1. inline的本质：建议而非强制"></a>1. <strong>inline的本质：建议而非强制</strong></h4><ul>
<li><strong>编译器的自主权</strong>：<code>inline</code>只是对编译器的建议，编译器有完全的自主权决定是否进行内联展开。</li>
<li><strong>隐式inline</strong>：类内定义的成员函数（包括<code>friend</code>函数）默认被视为<code>inline</code>候选。</li>
<li><strong>显式inline</strong>：通过<code>inline</code>关键字明确声明的函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;  <span class="hljs-comment">// 隐式inline候选</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <br>    <span class="hljs-comment">// friend函数在类内定义也是隐式inline候选</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Widget&amp; w) &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; w.value;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 显式inline声明</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-编译器拒绝内联的常见情况"><a href="#2-编译器拒绝内联的常见情况" class="headerlink" title="2. 编译器拒绝内联的常见情况"></a>2. <strong>编译器拒绝内联的常见情况</strong></h4><p>编译器通常会拒绝内联以下类型的函数：</p>
<ul>
<li><strong>复杂函数</strong>：包含循环、递归、复杂控制结构的函数</li>
<li><strong>虚函数</strong>：运行时才能确定调用哪个函数，无法在编译时内联</li>
<li><strong>通过函数指针调用</strong>：调用地址在运行时确定</li>
<li><strong>过大的函数</strong>：会导致显著的代码膨胀</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 复杂处理逻辑 */</span> &#125;  <span class="hljs-comment">// 虚函数，通常不会内联</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">complexFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 包含循环的函数，编译器可能拒绝内联</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) &#123;<br>        <span class="hljs-comment">// 复杂处理...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">void</span> (*funcPtr)() = complexFunction;<br>    <span class="hljs-built_in">funcPtr</span>();  <span class="hljs-comment">// 通过函数指针调用，无法内联</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-代码膨胀问题"><a href="#3-代码膨胀问题" class="headerlink" title="3. 代码膨胀问题"></a>3. <strong>代码膨胀问题</strong></h4><p><strong>内联展开的代价</strong>：每个函数调用处都会插入函数的完整代码副本，导致目标代码体积增大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">debugInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[DEBUG] &quot;</span> + <span class="hljs-built_in">getCurrentTime</span>() + <span class="hljs-string">&quot;: &quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span> </span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-built_in">debugInfo</span>(<span class="hljs-string">&quot;Function 1 called&quot;</span>); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span> </span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-built_in">debugInfo</span>(<span class="hljs-string">&quot;Function 2 called&quot;</span>); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">()</span> </span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-built_in">debugInfo</span>(<span class="hljs-string">&quot;Function 3 called&quot;</span>); <br>&#125;<br><br><span class="hljs-comment">// 如果内联，debugInfo的代码会在每个调用点都复制一份</span><br><span class="hljs-comment">// 可能导致显著的代码膨胀</span><br></code></pre></td></tr></table></figure>

<p><strong>平衡策略</strong>：</p>
<ul>
<li><strong>小函数优先</strong>：1-3行的简单函数是最佳候选</li>
<li><strong>频繁调用</strong>：被高频调用的函数内联收益更大</li>
<li><strong>性能关键路径</strong>：在性能瓶颈处谨慎使用</li>
</ul>
<h4 id="4-调试困难"><a href="#4-调试困难" class="headerlink" title="4. 调试困难"></a>4. <strong>调试困难</strong></h4><p>内联函数在调试时无法设置断点，因为它们在编译后已经”消失”了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = a * <span class="hljs-number">2</span>;      <span class="hljs-comment">// 调试时无法在这里设置断点</span><br>    <span class="hljs-keyword">return</span> temp + b;       <span class="hljs-comment">// 或者这里</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">calculate</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 断点只能设在调用处</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>调试建议</strong>：</p>
<ul>
<li>开发期间暂时移除<code>inline</code></li>
<li>使用编译器的调试友好选项</li>
<li>Release版本才启用激进的内联优化</li>
</ul>
<h4 id="5-二进制兼容性问题"><a href="#5-二进制兼容性问题" class="headerlink" title="5. 二进制兼容性问题"></a>5. <strong>二进制兼容性问题</strong></h4><p>内联函数的修改会影响所有使用它的编译单元，破坏二进制兼容性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// library.h (版本1.0)</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">// 版本1.0</span><br>&#125;<br><br><span class="hljs-comment">// library.h (版本1.1) </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">110</span>;  <span class="hljs-comment">// 版本1.1，修改了实现</span><br>&#125;<br><br><span class="hljs-comment">// client.cpp 用版本1.0编译，但链接了版本1.1的库</span><br><span class="hljs-comment">// 可能会出现版本不一致的问题</span><br></code></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ul>
<li>库的公共接口避免使用内联函数</li>
<li>使用编译时版本检查</li>
<li>提供稳定的ABI（应用程序二进制接口）</li>
</ul>
<h4 id="6-模板函数的特殊考虑"><a href="#6-模板函数的特殊考虑" class="headerlink" title="6. 模板函数的特殊考虑"></a>6. <strong>模板函数的特殊考虑</strong></h4><p><strong>常见误区</strong>：认为模板函数在头文件中定义就应该声明为<code>inline</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 错误思维：模板在头文件中，就声明为inline</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">processContainer</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; container)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : container) &#123;<br>        <span class="hljs-comment">// 复杂处理逻辑...</span><br>        <span class="hljs-built_in">complexProcessing</span>(item);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ✅ 正确做法：只对简单模板函数使用inline</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">square</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> value * value;  <span class="hljs-comment">// 简单、适合内联</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complexTemplateFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; data)</span> </span>&#123;  <span class="hljs-comment">// 不声明inline</span><br>    <span class="hljs-comment">// 复杂逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>正确原则</strong>：</p>
<ul>
<li>模板函数是否内联应基于函数复杂度，而非是否在头文件中</li>
<li>简单的模板函数（如访问器、简单计算）适合内联</li>
<li>复杂的模板函数应避免内联</li>
</ul>
<h4 id="7-最佳实践指南"><a href="#7-最佳实践指南" class="headerlink" title="7. 最佳实践指南"></a>7. <strong>最佳实践指南</strong></h4><p><strong>适合内联的函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x_, y_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 简单访问器，适合内联</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y_; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 简单设置器，适合内联</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; x_ = x; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> </span>&#123; y_ = y; &#125;<br>    <br>    <span class="hljs-comment">// ✅ 简单计算，适合内联</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(x_ * x_ + y_ * y_);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>不适合内联的函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 复杂逻辑，不适合内联</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeDataset</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Data&gt;&amp; dataset)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; data : dataset) &#123;<br>            <span class="hljs-built_in">validateData</span>(data);<br>            <span class="hljs-built_in">transformData</span>(data);<br>            <span class="hljs-built_in">persistData</span>(data);<br>            <span class="hljs-built_in">generateReport</span>(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ❌ 虚函数，通常不会被内联</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(<span class="hljs-type">const</span> Event&amp; event)</span> </span>&#123;<br>        <span class="hljs-comment">// 事件处理逻辑...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><code>inline</code>函数是性能优化的重要工具，但需要谨慎使用：</p>
<p><strong>何时使用inline：</strong></p>
<ul>
<li>小型函数（1-5行代码）</li>
<li>被频繁调用的函数</li>
<li>简单的访问器和设置器</li>
<li>性能关键路径上的简单计算</li>
</ul>
<p><strong>何时避免inline：</strong></p>
<ul>
<li>包含循环、递归的复杂函数</li>
<li>虚函数（编译器通常会忽略）</li>
<li>库的公共接口函数</li>
<li>调试阶段的函数</li>
</ul>
<p><strong>关键原则：</strong></p>
<ul>
<li>将大多数inlining限制在小型、被调用频繁的函数身上</li>
<li>不要只因为function templates出现在头文件，就将它们声明为inline</li>
<li>在性能和代码膨胀之间找到平衡点</li>
<li>优先考虑代码的可维护性和调试便利性</li>
</ul>
<p>friend 函数为何也默认 inline？类外定义 friend 函数，不是 inline</p>
<ul>
<li>将大多数inlining限制在小型、被调用频繁的函数身上。这可使日后的调试过程和二进制升级更容易，也可以使潜在的代码膨胀问题最小化，使得程序的速度提升机会最小化。</li>
<li>不要只因为 function templates 出现在头文件，就将它们声明为inline。</li>
</ul>
<hr>
<h2 id="条款31：将文件之间的编译依存关系降至最低"><a href="#条款31：将文件之间的编译依存关系降至最低" class="headerlink" title="条款31：将文件之间的编译依存关系降至最低"></a>条款31：将文件之间的编译依存关系降至最低</h2><blockquote>
<p><em>Minimize compilation dependencies between files</em></p>
</blockquote>
<h3 id="核心理念-27"><a href="#核心理念-27" class="headerlink" title="核心理念"></a>核心理念</h3><blockquote>
<p>在大型 C++ 项目中，应尽量减少一个模块对另一个模块的实现细节的依赖。<br> <strong>相依于声明式，不要相依于定义式</strong>，是最基本的原则。</p>
</blockquote>
<p>为此，推荐使用 <strong>Handle Classes</strong> 和 <strong>Interface Classes</strong> 等设计手段，同时保持头文件结构 <strong>完整且仅包含声明（Full and Declaration-Only）</strong>，以降低编译依赖，提高封装性与编译效率。</p>
<h3 id="深度解析-27"><a href="#深度解析-27" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1，-依赖声明式，不依赖定义式"><a href="#1，-依赖声明式，不依赖定义式" class="headerlink" title="1， 依赖声明式，不依赖定义式"></a>1， 依赖声明式，不依赖定义式</h4><ul>
<li><strong>声明式依赖</strong>：只需前向声明即可完成编译，不引入头文件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;  <span class="hljs-comment">// 前向声明，避免引入#include外部欧文件，可以显著减少依赖传播</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    Engine* engine;  <span class="hljs-comment">// 声明依赖即可，无需包含 Engine.h</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>定义式依赖</strong>：需要包含完整类型定义，导致编译依赖传播。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Engine.h&quot;</span>  <span class="hljs-comment">// 引入定义，引入了所有 Engine 的实现细节</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    Engine engine;   <span class="hljs-comment">// 依赖实现细节，需要完整类型定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="2，-使用-Handle-Class（Pimpl-惯用法）"><a href="#2，-使用-Handle-Class（Pimpl-惯用法）" class="headerlink" title="2， 使用 Handle Class（Pimpl 惯用法）"></a>2， 使用 Handle Class（Pimpl 惯用法）</h4><ul>
<li>Pimpl（Pointer to Implementation）是一种将实现细节<strong>封装在另一个类中</strong>的技术，只在头文件中暴露指向实现类的指针，避免头文件暴露任何实现细节。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Widget.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetImpl</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    WidgetImpl* pImpl;  <span class="hljs-comment">// 实现被隐藏</span><br>&#125;;<br></code></pre></td></tr></table></figure>





<ul>
<li>支持”编译依存性最小化”的一般构想是： 相依与声明式，不要相依于定义式。基于此构想的俩个手段是 Handle classes 和 Interfaceclasses。</li>
<li>程序库头文件应该以 “完成仅有声明式” （full and declaration-only forms）的形式存在。这种做法不论是否涉及templates 都适用。</li>
</ul>
<h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><blockquote>
<p><em>Make sure public inheritance models “is-a”</em></p>
</blockquote>
<h3 id="核心理念-28"><a href="#核心理念-28" class="headerlink" title="核心理念"></a>核心理念</h3><p><code>public</code>继承意味着**”is-a”<strong>关系。这不是一个编程技巧，而是一个</strong>语义契约**：派生类对象就是一个基类对象，基类的所有性质都必须适用于派生类。违反这个原则会导致设计缺陷，在编译期可能通过，但在逻辑上是错误的。</p>
<p><strong>核心原则：适用于<code>base classes</code>身上的每一件事情一定也适用于<code>derived classes</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象。</strong></p>
<h3 id="深度解析-28"><a href="#深度解析-28" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-is-a关系的本质"><a href="#1-is-a关系的本质" class="headerlink" title="1. is-a关系的本质"></a>1. <strong>is-a关系的本质</strong></h4><p><strong>is-a关系不是继承的副产品，而是继承的目的</strong>。当我们说 <code>Student</code> 继承 <code>Person</code> 时，我们是在说：”每一个学生都是一个人”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// 重写，但仍然是Person的行为</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processPersons</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Person*&gt;&amp; people)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; person : people) &#123;<br>        person-&gt;<span class="hljs-built_in">walk</span>();      <span class="hljs-comment">// ✅ 每个Student都能walk</span><br>        person-&gt;<span class="hljs-built_in">eat</span>();       <span class="hljs-comment">// ✅ 每个Student都能eat</span><br>        person-&gt;<span class="hljs-built_in">introduce</span>(); <span class="hljs-comment">// ✅ 每个Student都能introduce</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Person*&gt; people;<br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>());   <span class="hljs-comment">// ✅ 学生是人</span><br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>());<br>    <br>    <span class="hljs-built_in">processPersons</span>(people);  <span class="hljs-comment">// 所有Person的行为都适用于Student</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-常见的is-a关系违反案例"><a href="#2-常见的is-a关系违反案例" class="headerlink" title="2. 常见的is-a关系违反案例"></a>2. <strong>常见的is-a关系违反案例</strong></h4><p><strong>案例1：企鹅不会飞的经典问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 错误设计：违反了is-a关系</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m flying!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 企鹅不会飞，这里应该怎么办？</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Penguins can&#x27;t fly!&quot;</span>);  <span class="hljs-comment">// 运行时错误</span><br>        <span class="hljs-comment">// 或者什么都不做？这违反了接口契约</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeBirdFly</span><span class="hljs-params">(Bird&amp; bird)</span> </span>&#123;<br>    bird.<span class="hljs-built_in">fly</span>();  <span class="hljs-comment">// 如果传入企鹅，会抛出异常！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>正确设计：重新审视继承层次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确设计：明确区分能飞和不能飞的鸟</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 不在这里定义fly，因为不是所有鸟都会飞</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m flying!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> : <span class="hljs-keyword">public</span> Bird &#123;  <span class="hljs-comment">// 企鹅是鸟，但不是会飞的鸟</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m swimming!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Eagle</span> : <span class="hljs-keyword">public</span> FlyingBird &#123;  <span class="hljs-comment">// 老鹰是会飞的鸟</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">soar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Soaring high!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>案例2：正方形和长方形的陷阱</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 看似合理但有问题的设计</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> width)</span> </span>&#123; width_ = width; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> height)</span> </span>&#123; height_ = height; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> width_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> height_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> width_ * height_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> width_, height_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> width)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        width_ = height_ = width;  <span class="hljs-comment">// 正方形的宽高必须相等</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> height)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        width_ = height_ = height; <span class="hljs-comment">// 正方形的宽高必须相等</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> width_;  <span class="hljs-comment">// 实际上只需要一个维度</span><br>&#125;;<br><br><span class="hljs-comment">// 这个函数期望Rectangle的行为</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRectangle</span><span class="hljs-params">(Rectangle&amp; rect)</span> </span>&#123;<br>    <span class="hljs-type">int</span> oldHeight = rect.<span class="hljs-built_in">getHeight</span>();<br>    rect.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 期望：高度不变，只有宽度改变</span><br>    <span class="hljs-built_in">assert</span>(rect.<span class="hljs-built_in">getHeight</span>() == oldHeight);  <span class="hljs-comment">// 如果传入Square会失败！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>问题分析</strong>：</p>
<ul>
<li>数学上正方形是特殊的长方形</li>
<li>但在面向对象设计中，正方形违反了长方形的行为契约</li>
<li>长方形的行为期望：设置宽度不会影响高度</li>
<li>正方形必须违反这个期望</li>
</ul>
<h4 id="3-is-a关系的验证方法"><a href="#3-is-a关系的验证方法" class="headerlink" title="3. is-a关系的验证方法"></a>3. <strong>is-a关系的验证方法</strong></h4><p><strong>语言测试法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 能说&quot;每个Student都是Person&quot;吗？ ✅</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123; &#125;;<br><br><span class="hljs-comment">// 能说&quot;每个Rectangle都是Point&quot;吗？ ❌ </span><br><span class="hljs-comment">// class Rectangle : public Point &#123; &#125;;  // 错误！</span><br><br><span class="hljs-comment">// 能说&quot;每个Car都是Vehicle&quot;吗？ ✅</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">public</span> Vehicle &#123; &#125;;<br></code></pre></td></tr></table></figure>

<p><strong>行为一致性测试</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类的所有public行为是否都适用于派生类？</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;        <span class="hljs-comment">// 所有车辆都能启动吗？</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 所有车辆都能加速吗？</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brake</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;        <span class="hljs-comment">// 所有车辆都能刹车吗？</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span> : <span class="hljs-keyword">public</span> Vehicle &#123;<br>    <span class="hljs-comment">// ✅ 电动车可以启动、加速、刹车</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> : <span class="hljs-keyword">public</span> Vehicle &#123;<br>    <span class="hljs-comment">// ❓ 自行车能&quot;启动&quot;吗？可能需要重新设计层次</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-设计建议：正确建立is-a关系"><a href="#4-设计建议：正确建立is-a关系" class="headerlink" title="4. 设计建议：正确建立is-a关系"></a>4. <strong>设计建议：正确建立is-a关系</strong></h4><p><strong>建议1：优先组合而非继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 与其让Car继承Engine，不如让Car包含Engine</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;  <span class="hljs-comment">// Car不是Engine，Car有Engine</span><br><span class="hljs-keyword">private</span>:<br>    Engine engine_;  <span class="hljs-comment">// 组合关系</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startCar</span><span class="hljs-params">()</span> </span>&#123; engine_.<span class="hljs-built_in">start</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stopCar</span><span class="hljs-params">()</span> </span>&#123; engine_.<span class="hljs-built_in">stop</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>建议2：使用接口分离原则</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义行为接口而不是具体类继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Flyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Swimmable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Swimmable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> : <span class="hljs-keyword">public</span> Bird, <span class="hljs-keyword">public</span> Flyable, <span class="hljs-keyword">public</span> Swimmable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 鸭子飞行 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 鸭子游泳 */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> : <span class="hljs-keyword">public</span> Bird, <span class="hljs-keyword">public</span> Swimmable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 企鹅游泳 */</span> &#125;<br>    <span class="hljs-comment">// 企鹅不实现Flyable，因为企鹅不会飞</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>建议3：运用Liskov替换原则</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Liskov替换原则：派生类对象应该能够替换基类对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> radius) : <span class="hljs-built_in">radius_</span>(radius) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius_ * radius_;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing circle with radius &quot;</span> &lt;&lt; radius_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius_;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 任何期望Shape的地方都可以使用Circle</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processShape</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; shape)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Area: &quot;</span> &lt;&lt; shape.<span class="hljs-built_in">area</span>() &lt;&lt; std::endl;<br>    shape.<span class="hljs-built_in">draw</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-实际应用中的权衡"><a href="#5-实际应用中的权衡" class="headerlink" title="5. 实际应用中的权衡"></a>5. <strong>实际应用中的权衡</strong></h4><p>有时现实世界的关系和软件设计中的关系不完全一致，需要根据<strong>软件的需求</strong>来决定继承关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 现实中：正方形是长方形</span><br><span class="hljs-comment">// 软件中：可能需要不同的设计</span><br><br><span class="hljs-comment">// 选择1：分离设计</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quadrilateral</span> &#123;  <span class="hljs-comment">// 四边形基类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Quadrilateral &#123;<br>    <span class="hljs-comment">// 长方形特有的行为</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Quadrilateral &#123;<br>    <span class="hljs-comment">// 正方形特有的行为</span><br>&#125;;<br><br><span class="hljs-comment">// 选择2：如果确实需要继承，确保行为一致</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 只定义所有子类都遵循的行为</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><strong>public继承的核心要点：</strong></p>
<ol>
<li><strong>语义契约</strong>：public继承表达的是”is-a”关系，不是代码复用机制</li>
<li><strong>行为一致性</strong>：派生类必须能在所有基类能工作的地方正常工作</li>
<li><strong>接口完整性</strong>：基类的所有public接口都必须对派生类有意义</li>
<li><strong>设计验证</strong>：通过语言测试和行为测试验证继承关系的合理性</li>
</ol>
<p><strong>设计建议：</strong></p>
<ul>
<li>优先考虑组合而非继承</li>
<li>使用接口分离，避免强迫派生类实现不相关的功能</li>
<li>遵循Liskov替换原则</li>
<li>根据软件需求而非现实关系设计继承层次</li>
</ul>
<p><strong>记住：<code>public</code>继承意味着”is-a”。适用于<code>base classes</code>身上的每一件事情一定也适用于<code>derived classes</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象。</strong></p>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><blockquote>
<p><em>Avoid hiding inherited names</em></p>
</blockquote>
<h3 id="核心理念-29"><a href="#核心理念-29" class="headerlink" title="核心理念"></a>核心理念</h3><p>在 C++ 继承体系中，派生类中的名称会<strong>自动遮掩</strong>基类中的同名成员，即使它们的函数签名完全不同。这种名称查找机制基于<strong>作用域规则</strong>而非重载规则，可能导致基类的某些重载版本意外”消失”。在 <code>public</code> 继承中，这通常不是我们想要的行为，需要通过 <strong><code>using</code> 声明</strong>或<strong>转交函数</strong>来恢复被遮掩的名称。</p>
<h3 id="深度解析-29"><a href="#深度解析-29" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-名称遮掩的机制原理"><a href="#1-名称遮掩的机制原理" class="headerlink" title="1. 名称遮掩的机制原理"></a>1. <strong>名称遮掩的机制原理</strong></h4><p>C++ 的名称查找遵循<strong>作用域优先</strong>原则，而不是重载匹配原则。当编译器在派生类中找到匹配的名称时，就会停止向上查找，即使基类中有更合适的重载版本。</p>
<p><strong>为什么会发生名称遮掩？</strong></p>
<ul>
<li><strong>作用域规则</strong>：派生类的作用域嵌套在基类作用域内，内层作用域的名称会遮掩外层作用域的同名标识符</li>
<li><strong>查找顺序</strong>：编译器首先在派生类作用域中查找名称，找到后就停止，不再查找基类作用域</li>
<li><strong>与重载无关</strong>：即使函数签名完全不同，只要名称相同就会发生遮掩</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;           <span class="hljs-comment">// 基类的重载版本</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;                <span class="hljs-comment">// 基类的重载版本</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 遮掩了 Base::mf1(int)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;                      <span class="hljs-comment">// 遮掩了 Base::mf3() 和 Base::mf3(double)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <br>    d.<span class="hljs-built_in">mf1</span>();        <span class="hljs-comment">// ✅ 正确：调用 Derived::mf1()</span><br>    d.<span class="hljs-built_in">mf1</span>(x);       <span class="hljs-comment">// ❌ 错误：Base::mf1(int) 被遮掩，无法调用</span><br>    d.<span class="hljs-built_in">mf2</span>();        <span class="hljs-comment">// ✅ 正确：调用继承的 Base::mf2()</span><br>    d.<span class="hljs-built_in">mf3</span>();        <span class="hljs-comment">// ✅ 正确：调用 Derived::mf3()</span><br>    d.<span class="hljs-built_in">mf3</span>(x);       <span class="hljs-comment">// ❌ 错误：Base::mf3(double) 被遮掩，无法调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-public继承中名称遮掩的问题"><a href="#2-public继承中名称遮掩的问题" class="headerlink" title="2. public继承中名称遮掩的问题"></a>2. <strong>public继承中名称遮掩的问题</strong></h4><p>在 <code>public</code> 继承中，名称遮掩违反了 <strong>is-a</strong> 关系的基本原则。如果 <code>Derived</code> 是一种 <code>Base</code>，那么任何适用于 <code>Base</code> 对象的操作都应该适用于 <code>Derived</code> 对象。</p>
<p><strong>违反 is-a 关系的示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; language)</span></span>;    <span class="hljs-comment">// 重载：指定语言说话</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 只重写了无参版本，但遮掩了有参版本</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p;<br>    Student s;<br>    <br>    p.<span class="hljs-built_in">speak</span>();                    <span class="hljs-comment">// ✅ 正确</span><br>    p.<span class="hljs-built_in">speak</span>(<span class="hljs-string">&quot;English&quot;</span>);           <span class="hljs-comment">// ✅ 正确</span><br>    <br>    s.<span class="hljs-built_in">speak</span>();                    <span class="hljs-comment">// ✅ 正确</span><br>    s.<span class="hljs-built_in">speak</span>(<span class="hljs-string">&quot;English&quot;</span>);           <span class="hljs-comment">// ❌ 错误！违反了 is-a 关系</span><br>    <span class="hljs-comment">// Student 应该能做 Person 能做的一切事情</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-解决方案一：using-声明"><a href="#3-解决方案一：using-声明" class="headerlink" title="3. 解决方案一：using 声明"></a>3. <strong>解决方案一：using 声明</strong></h4><p><code>using</code> 声明可以将基类的名称引入派生类的作用域，使所有同名的基类成员都变得可见。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁高效</strong>：一条 <code>using</code> 声明就能引入所有重载版本</li>
<li><strong>自动更新</strong>：如果基类增加新的重载，派生类自动获得</li>
<li><strong>性能无开销</strong>：编译时解析，无运行时成本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::mf1;          <span class="hljs-comment">// 引入 Base::mf1 的所有重载版本</span><br>    <span class="hljs-keyword">using</span> Base::mf3;          <span class="hljs-comment">// 引入 Base::mf3 的所有重载版本</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;       <span class="hljs-comment">// 重写 Base::mf1()，但不遮掩 Base::mf1(int)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// 重写 Base::mf3()，但不遮掩 Base::mf3(double)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <br>    d.<span class="hljs-built_in">mf1</span>();        <span class="hljs-comment">// ✅ 调用 Derived::mf1()</span><br>    d.<span class="hljs-built_in">mf1</span>(x);       <span class="hljs-comment">// ✅ 调用 Base::mf1(int) - using 声明使其可见</span><br>    d.<span class="hljs-built_in">mf3</span>();        <span class="hljs-comment">// ✅ 调用 Derived::mf3()</span><br>    d.<span class="hljs-built_in">mf3</span>(x);       <span class="hljs-comment">// ✅ 调用 Base::mf3(double) - using 声明使其可见</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-解决方案二：转交函数（Forwarding-Functions）"><a href="#4-解决方案二：转交函数（Forwarding-Functions）" class="headerlink" title="4. 解决方案二：转交函数（Forwarding Functions）"></a>4. <strong>解决方案二：转交函数（Forwarding Functions）</strong></h4><p>当你不想继承基类的<strong>所有</strong>重载版本，而只想让特定版本可见时，可以使用转交函数。这在<strong>私有继承</strong>中特别有用。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>精确控制</strong>：可以选择性地暴露特定的重载版本</li>
<li><strong>适用于私有继承</strong>：<code>using</code> 声明在私有继承中会改变访问级别，而转交函数不会</li>
<li><strong>可以进行转换</strong>：在转交过程中可以进行参数类型转换或添加默认参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">private</span> Base &#123;    <span class="hljs-comment">// 私有继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 转交函数：选择性地暴露基类函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>&#123; Base::<span class="hljs-built_in">mf1</span>(); &#125;           <span class="hljs-comment">// 只暴露无参版本</span><br>    <br>    <span class="hljs-comment">// 可以在转交时进行类型转换</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span> </span>&#123; Base::<span class="hljs-built_in">mf3</span>(); &#125;                   <span class="hljs-comment">// 暴露 Base::mf3()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; Base::<span class="hljs-built_in">mf3</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(x)); &#125;  <span class="hljs-comment">// 转换参数类型</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <br>    d.<span class="hljs-built_in">mf1</span>();        <span class="hljs-comment">// ✅ 通过转交函数调用 Base::mf1()</span><br>    <span class="hljs-comment">// d.mf1(10);   // ❌ 错误：没有为 mf1(int) 提供转交函数</span><br>    d.<span class="hljs-built_in">mf3</span>();        <span class="hljs-comment">// ✅ 通过转交函数调用 Base::mf3()</span><br>    d.<span class="hljs-built_in">mf3</span>(<span class="hljs-number">10</span>);      <span class="hljs-comment">// ✅ 通过转交函数调用，参数被转换为 double</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-模板类中的名称遮掩"><a href="#5-模板类中的名称遮掩" class="headerlink" title="5. 模板类中的名称遮掩"></a>5. <strong>模板类中的名称遮掩</strong></h4><p>在模板继承中，名称遮掩问题更加复杂，因为编译器不会在依赖型基类中查找名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        <span class="hljs-comment">// 需要明确指定基类作用域或使用 using 声明</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(info);              <span class="hljs-comment">// 方法1：使用 this-&gt;</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(info);  <span class="hljs-comment">// 方法2：明确指定作用域</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 或者使用 using 声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;    <span class="hljs-comment">// 方法3：using 声明</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span> </span>&#123;<br>        <span class="hljs-built_in">sendClear</span>(info);    <span class="hljs-comment">// 现在可以直接使用</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="6-选择合适的解决方案"><a href="#6-选择合适的解决方案" class="headerlink" title="6. 选择合适的解决方案"></a>6. <strong>选择合适的解决方案</strong></h4><table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td><strong>public 继承，需要所有重载</strong></td>
<td><code>using</code> 声明</td>
<td>简洁，自动包含新增重载</td>
</tr>
<tr>
<td><strong>private 继承</strong></td>
<td>转交函数</td>
<td>避免意外改变访问级别</td>
</tr>
<tr>
<td><strong>只需要特定重载</strong></td>
<td>转交函数</td>
<td>精确控制暴露的接口</td>
</tr>
<tr>
<td><strong>需要参数转换</strong></td>
<td>转交函数</td>
<td>可以在转交时修改参数</td>
</tr>
<tr>
<td><strong>模板继承</strong></td>
<td><code>using</code> 声明或明确作用域</td>
<td>解决依赖型名称查找问题</td>
</tr>
</tbody></table>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>名称遮掩是 C++ 继承机制中一个重要但容易被忽视的陷阱。理解其根本原因（<strong>作用域优先于重载匹配</strong>）是避免相关问题的关键。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>名称遮掩基于作用域规则</strong>，不是重载匹配规则</li>
<li><strong>在 public 继承中应避免名称遮掩</strong>，以维护 is-a 关系</li>
<li><strong><code>using</code> 声明</strong>适用于大多数场景，简洁高效</li>
<li><strong>转交函数</strong>提供更精确的控制，适用于特殊需求</li>
<li><strong>在模板继承中</strong>需要特别注意依赖型名称的查找问题</li>
</ul>
<p>通过合理使用这些技术，可以确保继承层次中的接口完整性和一致性，避免因名称遮掩导致的意外行为。</p>
<h2 id="条款34：区分实现继承和接口继承"><a href="#条款34：区分实现继承和接口继承" class="headerlink" title="条款34：区分实现继承和接口继承"></a>条款34：区分实现继承和接口继承</h2><blockquote>
<p><em>Differentiate between inheritance of interface and inheritance of implementation</em></p>
</blockquote>
<h3 id="核心理念-30"><a href="#核心理念-30" class="headerlink" title="核心理念"></a>核心理念</h3><p>在 C++ 中，<code>public inheritance</code>（公开继承）并非单纯的”继承”一个类的所有功能，而是可以分为两部分：<strong>接口继承</strong>和<strong>实现继承</strong>。这两者的区别至关重要，影响到如何设计类体系、避免不必要的错误，并确保代码的灵活性与可维护性。</p>
<ul>
<li><strong>接口继承</strong>：派生类继承了基类中的函数声明（如纯虚函数 <code>fly</code>），这意味着派生类必须提供自己对该接口的实现，或者使用基类提供的默认实现。</li>
<li><strong>实现继承</strong>：基类提供了实现（如 <code>defaultFly</code>），派生类可以选择<strong>调用这个默认实现</strong>，也可以选择<strong>自己提供实现</strong>，完全由派生类的需求来决定。</li>
</ul>
<h3 id="深度解析-30"><a href="#深度解析-30" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-什么是接口继承？"><a href="#1-什么是接口继承？" class="headerlink" title="1. 什么是接口继承？"></a>1. <strong>什么是接口继承？</strong></h4><p>接口继承是指继承一个类中声明的函数（即接口），而不关心函数的具体实现。派生类需要提供自己的实现。通常这种继承方式通过<strong>纯虚函数</strong>（pure virtual function）来定义。</p>
<ul>
<li><strong>为什么要使用接口继承？</strong><ul>
<li>这种方式使得派生类被强制实现某些函数，但具体的实现细节是由派生类来决定的。</li>
<li>基类只提供接口，派生类则负责如何实现这些功能。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数，只有接口，没有实现</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>Shape</code> 类提供了 <code>draw</code> 的接口，但没有提供实现，任何派生类（如 <code>Rectangle</code> 和 <code>Circle</code>）都必须实现 <code>draw</code> 函数，提供具体的绘制方式。</p>
<h4 id="2-什么是实现继承？"><a href="#2-什么是实现继承？" class="headerlink" title="2. 什么是实现继承？"></a>2. <strong>什么是实现继承？</strong></h4><p>实现继承是指派生类不仅继承了函数的接口，还继承了函数的默认实现。派生类可以选择性地覆盖这个实现。通常通过<strong>简单虚拟函数</strong>（simple virtual function）或者<strong>非虚拟函数</strong>来实现。</p>
<ul>
<li><strong>为什么要使用实现继承？</strong><ul>
<li>基类提供了一些常见的实现，派生类如果没有特别的需求，可以直接继承基类的实现。如果需要，派生类还可以覆盖默认的实现。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>：<br>	<span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> error（<span class="hljs-type">const</span> string* msg) &#123;<br>	std::cout &lt;&lt; |<span class="hljs-string">&quot;Error:&quot;</span> &lt;&lt; msg &lt;&lt; std::endl; <span class="hljs-comment">//基类提供的默认实现;</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Shape</code> 类提供了 <code>error</code> 函数的默认实现，派生类可以直接继承这个实现，或者根据需要覆写它。</p>
<h4 id="3-接口和实现分离的设计方式"><a href="#3-接口和实现分离的设计方式" class="headerlink" title="3. 接口和实现分离的设计方式"></a>3. <strong>接口和实现分离的设计方式</strong></h4><p>最佳实践是将接口和实现分离，以确保派生类能够灵活控制是否继承实现，或是否需要提供自己的实现。</p>
<ul>
<li><strong>如何实现分离？</strong><ul>
<li>基类中的纯虚函数（接口）只声明行为，不包含实现。基类中的其他成员函数则提供默认实现，派生类可以选择继承这些实现或覆盖它们。</li>
<li>如果派生类没有合适的实现，它可以继承基类的默认实现；如果需要特殊行为，它可以覆盖基类的实现。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数，只有接口</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Flying the default way&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 默认实现</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-如何避免错误的继承？"><a href="#4-如何避免错误的继承？" class="headerlink" title="4. 如何避免错误的继承？"></a>4. <strong>如何避免错误的继承？</strong></h4><p>通过将接口与实现分开，可以避免派生类无意间继承错误的实现。举个例子，如果派生类 <code>ModelC</code> 没有覆盖 <code>fly</code> 函数，<code>Airplane</code> 提供的默认行为（<code>defaultFly</code>）就可能会被意外继承，从而导致不合适的行为。</p>
<p>一种改进的方法是：将默认实现提取到独立的非虚拟函数中，并将接口函数声明为纯虚拟函数，从而强制派生类显式提供实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 假设有一个 Airport 类，用于表示目的地</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airport</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Airport&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 基类：Airplane</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚拟函数：仅继承接口，派生类必须提供自己的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>;  <br><br>    <span class="hljs-comment">// 简单虚拟函数：继承接口和默认实现，派生类可以选择重写默认实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying the default way to &quot;</span> &lt;&lt; destination.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 非虚拟函数：继承接口和强制实现，派生类不能更改实现</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">objectID</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">12345</span>; &#125;  <span class="hljs-comment">// 强制实现，派生类不能重写</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类：ModelA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span> : <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-built_in">defaultFly</span>(destination);  <span class="hljs-comment">// 使用基类提供的默认实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类：ModelB</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span> : <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying ModelB to &quot;</span> &lt;&lt; destination.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 自定义实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类：ModelC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span> : <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ModelC 需要自己实现 fly 函数，因为是纯虚拟函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying ModelC to &quot;</span> &lt;&lt; destination.<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot; with custom flight path.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Airport destination;<br><br>    <span class="hljs-comment">// 测试 ModelA（使用默认实现）</span><br>    Airplane* planeA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ModelA</span>();<br>    planeA-&gt;<span class="hljs-built_in">fly</span>(destination);  <span class="hljs-comment">// Output: Flying the default way to Airport</span><br><br>    <span class="hljs-comment">// 测试 ModelB（自定义实现）</span><br>    Airplane* planeB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ModelB</span>();<br>    planeB-&gt;<span class="hljs-built_in">fly</span>(destination);  <span class="hljs-comment">// Output: Flying ModelB to Airport</span><br><br>    <span class="hljs-comment">// 测试 ModelC（自定义实现）</span><br>    Airplane* planeC = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ModelC</span>();<br>    planeC-&gt;<span class="hljs-built_in">fly</span>(destination);  <span class="hljs-comment">// Output: Flying ModelC to Airport with custom flight path.</span><br><br>    <span class="hljs-comment">// 测试 non-virtual function objectID</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Plane A ID: &quot;</span> &lt;&lt; planeA-&gt;<span class="hljs-built_in">objectID</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// Output: Plane A ID: 12345</span><br><br>    <span class="hljs-keyword">delete</span> planeA;<br>    <span class="hljs-keyword">delete</span> planeB;<br>    <span class="hljs-keyword">delete</span> planeC;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>Flying the <span class="hljs-keyword">default</span> way to Airport<br>Flying ModelB to Airport<br>Flying ModelC to Airport with custom flight path.<br>Plane A ID: <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<h4 id="5-如何选择继承的方式？"><a href="#5-如何选择继承的方式？" class="headerlink" title="5. 如何选择继承的方式？"></a>5. <strong>如何选择继承的方式？</strong></h4><p>每个函数声明的方式决定了它将如何被继承：</p>
<ul>
<li><strong>纯虚函数（Pure Virtual Function）</strong>：仅继承接口，派生类必须提供自己的实现。</li>
<li><strong>简单虚拟函数（Simple Virtual Function）</strong>：继承接口和默认实现，派生类可以选择重写默认实现。</li>
<li><strong>非虚拟函数（Non-Virtual Function）</strong>：继承接口和强制实现，派生类不能更改实现。</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>理解并区分<strong>接口继承</strong>和<strong>实现继承</strong>是良好设计类层次结构的基础。通过正确地使用纯虚函数、简单虚拟函数和非虚拟函数，我们可以精确控制派生类应继承什么，避免不必要的错误，确保代码的可维护性和灵活性。</p>
<ul>
<li><strong>接口继承</strong>：只继承接口，派生类必须实现。</li>
<li><strong>实现继承</strong>：继承接口和默认实现，派生类可以重写。</li>
<li><strong>强制实现继承</strong>：继承接口和强制实现，派生类不能修改。</li>
</ul>
<h2 id="条款35：考虑virtual函数以外的选择"><a href="#条款35：考虑virtual函数以外的选择" class="headerlink" title="条款35：考虑virtual函数以外的选择"></a>条款35：考虑<code>virtual</code>函数以外的选择</h2><blockquote>
<p><em>Consider alternative to virtual functions</em></p>
</blockquote>
<h3 id="核心理念-31"><a href="#核心理念-31" class="headerlink" title="核心理念"></a>核心理念</h3><p>在 C++ 设计中， 虚函数并不是实现多态的唯一方式。在设计复杂系统时，尤其是需要提高性能或者避免过度继承时。可以通过Non-Virtual Interface（NVI）手法和Strategy模式来实现更加灵活和高效的设计。</p>
<p>这些方法能够帮助减少不必要的依赖和提升代码的扩展性。</p>
<h3 id="深度解析-31"><a href="#深度解析-31" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-Non-Virtual-Interface-NVI-手法"><a href="#1-Non-Virtual-Interface-NVI-手法" class="headerlink" title="1. Non-Virtual Interface (NVI) 手法"></a>1. <strong>Non-Virtual Interface (NVI) 手法</strong></h4><p>NVI是一种设计模式，他将<code>virtual</code>函数封装在一个<code>non-virtual</code>函数中，这样用户只能通过非虚函数访问接口，而虚函数则是私有的。使用NVI设计可以在调用虚函数之前或者之后做一些额外的记录，比如日志记录、资源管理等。</p>
<p><strong>NVI 有哪些优点?</strong></p>
<ul>
<li><strong>提高封装性</strong>：用户不能直接调用虚拟函数，只能通过公开的非虚函数进行操作，避免了不必要的依赖。</li>
<li><strong>事前事后操作</strong>：我们可以在调用虚拟函数之前做一些准备工作，在调用之后做一些清理工作，例如加锁&#x2F;解锁、验证条件等。</li>
<li><strong>更清晰的责任划分</strong>：通过 NVI，我们清晰地区分了函数的接口（由非虚函数提供）和实现（由虚拟函数提供）。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 做一些事前工作，如加锁、记录日志等</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();<br>        <span class="hljs-comment">// 做一些事后工作，如解锁、验证健康状态等</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 默认的健康值计算逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//healthValue是公开的非虚函数，外部只能通过它来获取健康值，而 doHealthValue 是私有虚函数，只有在 healthValue 内部调用。</span><br></code></pre></td></tr></table></figure>





<h4 id="2-Strategy模式"><a href="#2-Strategy模式" class="headerlink" title="2. Strategy模式"></a>2. Strategy模式</h4><p>Strategy模式提供了一种将行为（比如计算健康值）从对象内部转移到外部策略类的方式。通过传入不同的策略对象，可以在运行时改变对象的行为，提供强大灵活性；</p>
<ul>
<li><strong>Strategy模式有哪些优点？</strong><ul>
<li><strong>提高灵活性</strong>：策略可以在运行时动态替换。比如，某个敌人可以有一种计算健康值的策略，而另一个敌人可以使用不同的策略，而不需要修改 <code>GameCharacter</code> 类的代码。</li>
<li><strong>解耦行为与对象</strong>：通过将行为提取到外部，可以减少 <code>GameCharacter</code> 类的复杂度，也使得新的计算策略可以容易地集成到现有系统中。</li>
<li><strong>支持多个策略</strong>：同一个类的不同实例可以使用不同的策略，从而支持多样化的行为</li>
</ul>
</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> HealthCalcFunc = std::function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">const</span> GameCharacter&amp;)&gt;;<br><br>    <span class="hljs-built_in">GameCharacter</span>(HealthCalcFunc hcf = defaultHealthCalc) : <span class="hljs-built_in">healthFunc</span>(hcf) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp; gc)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 默认计算健康值的策略</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//GameCharacter 类通过 HealthCalcFunc（一个 std::function）来委托健康值的计算，可以在运行时动态更换计算策略。</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="tr1-function-替代函数指针"><a href="#tr1-function-替代函数指针" class="headerlink" title="tr1::function 替代函数指针"></a>tr1::function 替代函数指针</h4><p><code>tr1::function</code> 是一个模板类，它可以保存任何类型的可调用对象（如普通函数、成员函数、函数对象等）。通过使用 <code>tr1::function</code>，我们可以将行为封装得更加灵活，同时避免使用裸露的函数指针。</p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>支持多种可调用类型</strong>：<code>tr1::function</code> 可以保存普通函数、成员函数、函数对象等，提供了更强的灵活性。</li>
<li><strong>类型安全</strong>：它比传统的函数指针更加安全，可以进行类型检查，避免类型不匹配的错误。</li>
<li><strong>简化管理</strong>：相比函数指针，<code>tr1::function</code> 在管理上更加简便，尤其是在处理回调和动态行为时。</li>
</ul>
</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> HealthCalcFunc = std::function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">const</span> GameCharacter&amp;)&gt;;<br><br>    <span class="hljs-built_in">GameCharacter</span>(HealthCalcFunc hcf = defaultHealthCalc) : <span class="hljs-built_in">healthFunc</span>(hcf) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp; gc)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 默认健康计算逻辑</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//HealthCalcFunc 类型可以接收任何符合签名的可调用对象，使得 healthValue 函数能够更加灵活地接受不同的计算策略。</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-虚拟函数替代为另一个继承体系中的虚拟函数"><a href="#4-虚拟函数替代为另一个继承体系中的虚拟函数" class="headerlink" title="4. 虚拟函数替代为另一个继承体系中的虚拟函数"></a>4. <strong>虚拟函数替代为另一个继承体系中的虚拟函数</strong></h4><p>这里所说的”虚拟函数替代为另一个继承体系中的虚拟函数”，意味着我们不再把所有的功能都聚集在 <code>GameCharacter</code> 类或其直接派生类中，而是将某些功能拆分到不同的类层次中，以减少类的职责复杂性。</p>
<p>通常情况下吗，类的继承体系主要依赖于单一的虚拟函数接口来提供多态性。但有时，一个类可能承担了过多指责，导致其继承层过于庞大、复杂。因此，将某些行为提取到不同的、独立的继承体系中是个很好的解决方案；</p>
<ul>
<li><p><strong>有哪些优点呢？</strong></p>
<ul>
<li><strong>清晰的职责划分</strong>：通过将健康计算逻辑从 <code>GameCharacter</code> 类中拆分到一个独立的继承体系中，<code>GameCharacter</code> 只专注于角色的其他功能，如属性管理、状态跟踪等，而将健康计算的职责交给 <code>HealthCalcFunc</code> 及其派生类。</li>
<li><strong>更好的可扩展性</strong>：如果以后需要增加新的健康计算方式（如不同角色的健康计算策略），我们可以创建新的 <code>HealthCalcFunc</code> 派生类，而不需要修改现有的 <code>GameCharacter</code> 类。</li>
<li><strong>减少不必要的依赖</strong>：通过将健康计算从 <code>GameCharacter</code> 类中分离出来，其他类（例如敌人、NPC、玩家等）也可以灵活地使用不同的健康计算策略，而不需要继承复杂的 <code>GameCharacter</code> 类结构。</li>
<li><strong>避免虚拟函数链的复杂性</strong>：传统的做法可能会让所有计算逻辑都依赖于虚拟函数（如 <code>healthValue</code>），这会导致继承链过长，增加类的复杂度。而通过替代为另一套继承体系，我们可以简化类的设计，使得每个类只负责自己的职责。</li>
</ul>
</li>
<li><p>如何避免设计中的潜在问题</p>
<ul>
<li><p><strong>避免过度分散功能</strong>：将功能拆分到独立的继承体系中虽然带来灵活性，但也可能导致类和功能分散。需要在设计时仔细权衡，避免拆分过度，导致设计过于复杂或难以理解。</p>
</li>
<li><p><strong>接口与实现分离</strong>：拆分到独立继承体系时，应该确保接口与实现的分离。<code>HealthCalcFunc</code> 只提供接口，具体实现（如 <code>DefaultHealthCalc</code> 和 <code>FastHealthCalc</code>）则由派生类提供。</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 基类：健康计算策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCalcFunc</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">class</span> GameCharacter&amp; gc)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数，所有健康计算策略都必须实现这个函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HealthCalcFunc</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 添加虚析构函数，确保派生类能正确析构</span><br>&#125;;<br><br><span class="hljs-comment">// 默认健康计算策略（例如基础的健康值计算）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultHealthCalc</span> : <span class="hljs-keyword">public</span> HealthCalcFunc &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">class</span> GameCharacter&amp; gc)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 假设默认健康值为100</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 战士健康计算策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WarriorHealthCalc</span> : <span class="hljs-keyword">public</span> HealthCalcFunc &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">class</span> GameCharacter&amp; gc)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 假设战士的健康值计算公式：基础值 + 50</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">150</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 法师健康计算策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MageHealthCalc</span> : <span class="hljs-keyword">public</span> HealthCalcFunc &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">class</span> GameCharacter&amp; gc)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 假设法师的健康值计算公式：基础值 + 30</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">130</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 游戏角色类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数接受健康计算策略指针，默认为默认策略</span><br>    <span class="hljs-built_in">GameCharacter</span>(HealthCalcFunc* hcf = &amp;defaultHealthCalc) : <span class="hljs-built_in">pHealthCalc</span>(hcf) &#123;&#125;<br><br>    <span class="hljs-comment">// 计算健康值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pHealthCalc-&gt;<span class="hljs-built_in">calc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc* pHealthCalc;  <span class="hljs-comment">// 保存健康计算策略的指针</span><br>    <span class="hljs-type">static</span> DefaultHealthCalc defaultHealthCalc;  <span class="hljs-comment">// 默认的健康计算策略</span><br>&#125;;<br><br><span class="hljs-comment">// 定义默认的健康计算策略（静态成员）</span><br>DefaultHealthCalc GameCharacter::defaultHealthCalc;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建不同的健康计算策略</span><br>    WarriorHealthCalc warriorCalc;<br>    MageHealthCalc mageCalc;<br><br>    <span class="hljs-comment">// 创建不同的游戏角色</span><br>    GameCharacter defaultChar;  <span class="hljs-comment">// 使用默认健康计算策略</span><br>    <span class="hljs-function">GameCharacter <span class="hljs-title">warriorChar</span><span class="hljs-params">(&amp;warriorCalc)</span></span>;  <span class="hljs-comment">// 使用战士健康计算策略</span><br>    <span class="hljs-function">GameCharacter <span class="hljs-title">mageChar</span><span class="hljs-params">(&amp;mageCalc)</span></span>;  <span class="hljs-comment">// 使用法师健康计算策略</span><br><br>    <span class="hljs-comment">// 输出每个角色的健康值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Default Character Health: &quot;</span> &lt;&lt; defaultChar.<span class="hljs-built_in">healthValue</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 100</span><br><br></code></pre></td></tr></table></figure>

<h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>使用虚拟函数虽然很方便，但在性能和设计上可能带来一些问题。通过 <strong>Non-Virtual Interface (NVI)</strong> 手法、<strong>Strategy 模式</strong> 和 <strong>tr1::function</strong>，我们可以避免直接依赖虚拟函数，提升代码的灵活性、封装性和性能。</p>
<ul>
<li><strong>NVI 手法</strong>：通过非虚函数封装虚拟函数，实现清晰的责任划分和事前事后操作。</li>
<li><strong>Strategy 模式</strong>：通过策略对象动态改变对象的行为，使得行为可以在运行时选择，提升灵活性。</li>
<li><strong>tr1::function</strong>：比函数指针更强大，支持多种可调用对象，类型安全，简化管理。</li>
<li><strong>继承体系中的虚拟函数替代</strong>：通过拆分功能到不同的继承体系中，提高扩展性并减少实现耦合。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="为什么-tr1-function-比普通指针更安全？"><a href="#为什么-tr1-function-比普通指针更安全？" class="headerlink" title="为什么 tr1::function 比普通指针更安全？"></a>为什么 <code>tr1::function</code> 比普通指针更安全？</h4><ol>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li><code>tr1::function</code> 是类型安全的，它会在编译时确保传入的可调用对象与声明的类型一致。相比之下，函数指针在传递时没有类型检查，可能会导致类型不匹配，从而引发运行时错误。</li>
<li><code>tr1::function</code> 内部封装了一个指向基类的指针，而这个基类用一个纯虚函数统一接口，用于执行实际调用，通过继承基类实现 <code>invoke</code>。编译时，<code>std::function</code> 能够验证传入的函数签名是否匹配，如果一个不匹配的函数指针被复制给<code>std：：function</code>，编译器就能立即检测到并报错。</li>
</ul>
</li>
<li><p><strong>自动管理生命周期</strong>：</p>
<ul>
<li><code>tr1::function</code> 内部使用智能指针自动管理内存，确保封装的对象能够及时销毁；而普通函数指针必须由开发者手动管理；</li>
<li>当你将某个对象（例如一个 lambda 或函数指针）赋值给 <code>std::function</code> 时，它会自动管理该对象的生命周期，即使对象的作用域超出，<code>std::function</code> 仍会确保对象不会在使用过程中被销毁。而普通函数只是个裸指针，容易内存泄漏或产生悬空指针；</li>
</ul>
</li>
<li><p><strong>支持多种可调用对象</strong>：</p>
<ul>
<li><code>tr1::function</code> 通过类型擦除技术封装了不同类型的可调用对象，允许将不同类型的函数统一存储和调用，避免了为每种类型编写不同的处理逻辑。</li>
<li><code>std::function</code> 利用虚函数和动态绑定，能将普通函数指针、成员函数指针、函数对象（实现了operator的类）、lambda 表达式等不同类型的可调用对象封装为统一的类型。底层实现通过继承和多态管理不同类型的可调用对象，而普通函数指针不能做到这一点。</li>
</ul>
</li>
<li><p><strong>支持 <code>nullptr</code></strong></p>
<ul>
<li><p><code>tr1::function</code> 支持通过 <code>nullptr</code> 表示没有函数对象，调用前可以安全地检查是否有效，避免访问空指针。</p>
</li>
<li><p><code>std::function</code> 的内部实现允许其存储一个空状态（即 <code>nullptr</code>）。使用前，你可以通过显式检查 <code>std::function</code> 是否为空来避免调用空指针。而普通函数指针没有这种空状态支持，必须手动检查是否为 <code>nullptr</code>，容易遗漏，导致崩溃或未定义行为。</p>
</li>
</ul>
</li>
<li><p><strong>错误处理和异常安全</strong></p>
<ul>
<li><p><code>tr1::function</code> 在调用过程中自动处理异常，确保即使发生异常，内部的资源也会被安全释放。</p>
</li>
<li><p>它的内部通过智能指针（std::unique_ptr）和RAII原则来保证调用封装的可调用对象发生异常时的资源正确释放；当 <code>std::function</code> 对象被销毁时，它会自动释放存储的可调用对象，确保即使在调用期间发生异常，也不会发生内存泄漏。</p>
</li>
</ul>
</li>
</ol>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><blockquote>
<p><em>Never redefine an inherited non-virtual function</em></p>
</blockquote>
<h3 id="核心理念-32"><a href="#核心理念-32" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>绝不应该重新定义继承而来的non-virtual函数</strong>，因为non-virtual函数是静态绑定的，重新定义会导致行为不一致，违背了public继承的”is-a”关系。如果派生类需要不同的行为，要么使函数为虚函数，要么重新考虑继承关系的设计。</p>
<h3 id="深度解析-32"><a href="#深度解析-32" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-non-virtual函数的静态绑定特性"><a href="#1-non-virtual函数的静态绑定特性" class="headerlink" title="1. non-virtual函数的静态绑定特性"></a>1. <strong>non-virtual函数的静态绑定特性</strong></h4><p><strong>🤔 疑问点：为什么重新定义non-virtual函数会导致行为不一致？</strong></p>
<p>这是因为non-virtual函数采用静态绑定机制，编译器在编译时就根据指针或引用的声明类型来决定调用哪个版本的函数，而不是根据对象的实际类型。这意味着同一个对象通过不同类型的指针调用同一个函数时，可能会执行完全不同的代码，违背了面向对象编程中”对象行为应该一致”的基本原则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonVirtualFunc</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// non-virtual函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::nonVirtualFunc()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">virtualFunc</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// virtual函数对比</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::virtualFunc()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 错误：重新定义non-virtual函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonVirtualFunc</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::nonVirtualFunc()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确：重写virtual函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">virtualFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::virtualFunc()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateBindingDifference</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* pB = &amp;d;<br>    Derived* pD = &amp;d;<br>    <br>    <span class="hljs-comment">// non-virtual函数：静态绑定，行为不一致</span><br>    pB-&gt;<span class="hljs-built_in">nonVirtualFunc</span>();  <span class="hljs-comment">// 输出：Base::nonVirtualFunc()</span><br>    pD-&gt;<span class="hljs-built_in">nonVirtualFunc</span>();  <span class="hljs-comment">// 输出：Derived::nonVirtualFunc()</span><br>    <br>    <span class="hljs-comment">// virtual函数：动态绑定，行为一致</span><br>    pB-&gt;<span class="hljs-built_in">virtualFunc</span>();     <span class="hljs-comment">// 输出：Derived::virtualFunc()</span><br>    pD-&gt;<span class="hljs-built_in">virtualFunc</span>();     <span class="hljs-comment">// 输出：Derived::virtualFunc()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-违背is-a关系的语义"><a href="#2-违背is-a关系的语义" class="headerlink" title="2. 违背is-a关系的语义"></a>2. <strong>违背is-a关系的语义</strong></h4><p><strong>🤔 疑问点：重新定义non-virtual函数为什么会破坏is-a关系？</strong></p>
<p>public继承表达的是”is-a”关系，意味着派生类对象应该能够在任何需要基类对象的地方完美替代基类对象。当你重新定义non-virtual函数时，实际上是在告诉编译器”派生类在某些情况下的行为与基类不同”，这直接违背了Liskov替换原则，使得派生类对象无法完全替代基类对象，破坏了继承关系的语义完整性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startEngine</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// non-virtual：所有车辆都这样启动</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Engine starting...&quot;</span> &lt;&lt; std::endl;<br>        engineRunning_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// virtual：不同车辆加速方式不同</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Vehicle accelerating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> engineRunning_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> engineRunning_ = <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span> : <span class="hljs-keyword">public</span> Vehicle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 错误：重新定义non-virtual函数破坏了is-a关系</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startEngine</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Electric motor starting silently...&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 这破坏了Vehicle的invariant！</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确：重写virtual函数提供特定实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Electric car accelerating smoothly&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-正确的设计方案"><a href="#3-正确的设计方案" class="headerlink" title="3. 正确的设计方案"></a>3. <strong>正确的设计方案</strong></h4><p><strong>🤔 疑问点：如果派生类确实需要不同的行为，应该怎么办？</strong></p>
<p>当派生类需要不同于基类的行为时，正确的做法不是重新定义non-virtual函数，而是重新审视设计。你有几个选择：让基类函数成为virtual以支持多态行为，重新组织继承层次确保每个类都符合其基类契约，或者使用组合而非继承。关键是要保持设计的一致性和可预测性。</p>
<p><strong>方案1：使函数成为virtual</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 如果需要派生类特定行为，使用virtual</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Some generic animal sound&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal moving&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// non-virtual函数应该表示所有派生类共同的不变行为</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">breathe</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Breathing...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Woof!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Dog running&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// breathe()不需要重写，所有动物都一样呼吸</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>方案2：重新设计继承层次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确的设计：重新组织继承层次</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Bird</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlightlessBird</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Walking...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Eagle</span> : <span class="hljs-keyword">public</span> FlyingBird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Eagle hunting&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Eagle sleeping in nest&quot;</span> &lt;&lt; std::endl; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Eagle soaring high&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> : <span class="hljs-keyword">public</span> FlightlessBird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Penguin catching fish&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Penguin huddling for warmth&quot;</span> &lt;&lt; std::endl; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Penguin waddling&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Penguin swimming gracefully&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><p><strong>绝不重新定义继承而来的non-virtual函数的原因：</strong></p>
<ol>
<li><strong>静态绑定导致行为不一致</strong>：通过不同类型指针调用会有不同行为</li>
<li><strong>违背is-a关系</strong>：破坏了public继承的语义契约</li>
<li><strong>违反Liskov替换原则</strong>：派生类对象不能完全替代基类对象</li>
<li><strong>混淆客户代码</strong>：相同接口产生不同行为</li>
</ol>
<p><strong>正确的设计选择：</strong></p>
<ul>
<li><strong>需要多态行为</strong>：使用virtual函数</li>
<li><strong>需要一致行为</strong>：保持non-virtual函数不变</li>
<li><strong>需要不同行为</strong>：重新设计继承层次或使用组合</li>
<li><strong>性能关键</strong>：考虑CRTP或其他编译时多态技术</li>
</ul>
<p><strong>设计原则：</strong></p>
<ul>
<li><strong>non-virtual函数表示不变性</strong>：所有派生类都应该有相同行为</li>
<li><strong>virtual函数表示可变性</strong>：派生类可以提供特定实现</li>
<li><strong>public继承表示is-a关系</strong>：派生类应该能够完全替代基类</li>
</ul>
<p><strong>记住：绝不重新定义继承而来的non-virtual函数，因为这会导致行为不一致并违背public继承的is-a关系。如果需要不同的行为，要么使函数成为virtual，要么重新考虑设计。</strong></p>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><blockquote>
<p><em>Never redefine a function’s inherited default parameter value</em></p>
</blockquote>
<h3 id="核心理念-33"><a href="#核心理念-33" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>绝不应该重新定义继承而来的虚函数的缺省参数值</strong>，因为虚函数是动态绑定的，但缺省参数值却是静态绑定的。这种不一致会导致调用派生类函数时使用基类的缺省参数值，产生令人困惑的行为。正确的做法是在基类中定义合适的缺省参数值，或者使用其他设计模式避免这个问题。</p>
<h3 id="深度解析-33"><a href="#深度解析-33" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-缺省参数值的静态绑定特性"><a href="#1-缺省参数值的静态绑定特性" class="headerlink" title="1. 缺省参数值的静态绑定特性"></a>1. <strong>缺省参数值的静态绑定特性</strong></h4><p><strong>🤔 疑问点：为什么虚函数的缺省参数值不能被正确重新定义？</strong></p>
<p>这个问题源于C++的设计细节：虚函数采用动态绑定（运行时根据对象实际类型决定调用哪个函数），但缺省参数值却采用静态绑定（编译时根据指针类型决定使用哪个缺省值）。这种”混合绑定”机制导致了一种奇特现象：你可能调用的是派生类的函数实现，但使用的却是基类的缺省参数值，造成行为的不一致和困惑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; Red, Green, Blue &#125;;<br>    <br>    <span class="hljs-comment">// 虚函数with缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Color color = Red)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Shape with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ❌ 错误：重新定义缺省参数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Color color = Green)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Rectangle with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 正确：不重新定义缺省参数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Color color = Red)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Circle with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateDefaultParameterProblem</span><span class="hljs-params">()</span> </span>&#123;<br>    Shape* shapes[] = &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>()<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 通过基类指针调用，使用缺省参数</span><br>    shapes[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 输出：Drawing Rectangle with color 0 (Red)</span><br>                        <span class="hljs-comment">// 调用了Rectangle::draw()但使用了Shape的缺省参数！</span><br>    <br>    shapes[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 输出：Drawing Circle with color 0 (Red)</span><br>                        <span class="hljs-comment">// 正常行为</span><br>    <br>    <span class="hljs-keyword">delete</span> shapes[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">delete</span> shapes[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-正确的设计方案"><a href="#2-正确的设计方案" class="headerlink" title="2. 正确的设计方案"></a>2. <strong>正确的设计方案</strong></h4><p><strong>🤔 疑问点：如何避免缺省参数值重新定义带来的问题？</strong></p>
<p>解决这个问题的核心思路是”分离关注点”——将缺省参数的管理责任从virtual函数中分离出来。你可以保持所有重写函数使用相同的缺省参数值，或者使用NVI（Non-Virtual Interface）模式将缺省参数放在non-virtual函数中，让virtual函数专注于实现多态行为。这样既保持了接口的一致性，又实现了行为的多样性。</p>
<p><strong>方案1：不重新定义缺省参数值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FeedingTime</span> &#123; Morning, Afternoon, Evening &#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(FeedingTime time = Morning)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Feeding animal at time &quot;</span> &lt;&lt; time &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 正确：保持相同的缺省参数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(FeedingTime time = Morning)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Feeding dog at time &quot;</span> &lt;&lt; time &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ✅ 更简单：不写缺省参数，自动继承基类的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(FeedingTime time)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Feeding cat at time &quot;</span> &lt;&lt; time &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>方案2：使用Non-Virtual Interface (NVI)模式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; Red, Green, Blue &#125;;<br>    <br>    <span class="hljs-comment">// non-virtual公共接口，提供缺省参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Color color = Red)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">doDraw</span>(color);<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// virtual实现函数，不提供缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(Color color)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Shape with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// ✅ 只重写实现函数，无缺省参数问题</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(Color color)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Rectangle with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(Color color)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Circle with color &quot;</span> &lt;&lt; color &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><p><strong>绝不重新定义继承而来的缺省参数值的原因：</strong></p>
<ol>
<li><strong>静态绑定 vs 动态绑定</strong>：缺省参数静态绑定，虚函数动态绑定</li>
<li><strong>行为不一致</strong>：同一对象通过不同指针类型调用会有不同的缺省参数</li>
<li><strong>违背直觉</strong>：程序员期望的行为与实际行为不符</li>
<li><strong>调试困难</strong>：错误不易发现，运行时行为难以预测</li>
</ol>
<p><strong>正确的解决方案：</strong></p>
<ul>
<li><strong>保持一致的缺省参数</strong>：在所有重写函数中使用相同的缺省参数</li>
<li><strong>使用NVI模式</strong>：将缺省参数放在non-virtual函数中</li>
<li><strong>使用重载</strong>：提供多个函数版本而不是缺省参数</li>
<li><strong>使用配置对象</strong>：将参数封装在结构体中</li>
</ul>
<p><strong>设计指导原则：</strong></p>
<ul>
<li><strong>virtual函数应该专注于行为多态</strong>：不要混合参数默认值的复杂性</li>
<li><strong>缺省参数应该在接口层面统一</strong>：避免在继承层次中变化</li>
<li><strong>优先考虑显式参数</strong>：明确性胜过便利性</li>
</ul>
<p><strong>记住：绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定的，而虚函数是动态绑定的，这会导致调用派生类函数时使用基类的缺省参数值。</strong></p>
<h2 id="条款38：-通过复合塑模出has-a或”根据某物实现出”"><a href="#条款38：-通过复合塑模出has-a或”根据某物实现出”" class="headerlink" title="条款38： 通过复合塑模出has-a或”根据某物实现出”"></a>条款38： 通过复合塑模出has-a或”根据某物实现出”</h2><blockquote>
<p><em>Model “has-a” or “is-implemented-in-terms-of” through composition</em></p>
</blockquote>
<h3 id="核心理念-34"><a href="#核心理念-34" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>复合（composition）<strong>意味着某种类型的对象内含其他类型的对象。复合可以意味着</strong>has-a</strong>（有一个）或<strong>is-implemented-in-terms-of</strong>（根据某物实现出）关系。在应用域中，复合意味着has-a；在实现域中，复合意味着is-implemented-in-terms-of。理解这两种关系的区别，并正确使用复合而非继承，是面向对象设计的重要技能。</p>
<h3 id="深度解析-34"><a href="#深度解析-34" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-复合的两种语义"><a href="#1-复合的两种语义" class="headerlink" title="1. 复合的两种语义"></a>1. <strong>复合的两种语义</strong></h4><p><strong>has-a关系（应用域）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;        <span class="hljs-comment">// Person有一个名字</span><br>    Address address_;         <span class="hljs-comment">// Person有一个地址</span><br>    PhoneNumber phone_;       <span class="hljs-comment">// Person有一个电话号码</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Address&amp; addr, <span class="hljs-type">const</span> PhoneNumber&amp; phone)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">address_</span>(addr), <span class="hljs-built_in">phone_</span>(phone) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Address&amp; <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> address_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> PhoneNumber&amp; <span class="hljs-title">getPhone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> phone_; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string street_;<br>    std::string city_;<br>    std::string zipCode_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Address</span>(<span class="hljs-type">const</span> std::string&amp; street, <span class="hljs-type">const</span> std::string&amp; city, <span class="hljs-type">const</span> std::string&amp; zip)<br>        : <span class="hljs-built_in">street_</span>(street), <span class="hljs-built_in">city_</span>(city), <span class="hljs-built_in">zipCode_</span>(zip) &#123;&#125;<br>    <br>    <span class="hljs-function">std::string <span class="hljs-title">getFullAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> street_ + <span class="hljs-string">&quot;, &quot;</span> + city_ + <span class="hljs-string">&quot; &quot;</span> + zipCode_;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>is-implemented-in-terms-of关系（实现域）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❌ 错误设计：Set不是List，不应该继承</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span> : <span class="hljs-keyword">public</span> std::list&lt;T&gt; &#123; ... &#125;;<br><br><span class="hljs-comment">// ✅ 正确设计：Set根据List实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::list&lt;T&gt; rep_;  <span class="hljs-comment">// Set根据list实现</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">member</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(rep_.<span class="hljs-built_in">begin</span>(), rep_.<span class="hljs-built_in">end</span>(), item) != rep_.<span class="hljs-built_in">end</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">member</span>(item)) &#123;<br>            rep_.<span class="hljs-built_in">push_back</span>(item);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(rep_.<span class="hljs-built_in">begin</span>(), rep_.<span class="hljs-built_in">end</span>(), item);<br>        <span class="hljs-keyword">if</span> (it != rep_.<span class="hljs-built_in">end</span>()) &#123;<br>            rep_.<span class="hljs-built_in">erase</span>(it);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rep_.<span class="hljs-built_in">size</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rep_.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-继承-vs-复合的选择指南"><a href="#2-继承-vs-复合的选择指南" class="headerlink" title="2. 继承 vs 复合的选择指南"></a>2. <strong>继承 vs 复合的选择指南</strong></h4><p><strong>何时使用public继承（is-a关系）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确：学生是人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string studentId_;<br>    std::vector&lt;Course&gt; courses_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Address&amp; addr, <br>            <span class="hljs-type">const</span> PhoneNumber&amp; phone, <span class="hljs-type">const</span> std::string&amp; id)<br>        : <span class="hljs-built_in">Person</span>(name, addr, phone), <span class="hljs-built_in">studentId_</span>(id) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enrollCourse</span><span class="hljs-params">(<span class="hljs-type">const</span> Course&amp; course)</span> </span>&#123;<br>        courses_.<span class="hljs-built_in">push_back</span>(course);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Student可以做Person能做的一切事情</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>何时使用复合（has-a关系）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ✅ 正确：汽车有引擎，不是引擎</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine engine_;           <span class="hljs-comment">// Car有一个Engine</span><br>    Transmission transmission_; <span class="hljs-comment">// Car有一个Transmission</span><br>    std::vector&lt;Wheel&gt; wheels_; <span class="hljs-comment">// Car有多个Wheel</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">const</span> Engine&amp; engine, <span class="hljs-type">const</span> Transmission&amp; trans, <br>        <span class="hljs-type">const</span> std::vector&lt;Wheel&gt;&amp; wheels)<br>        : <span class="hljs-built_in">engine_</span>(engine), <span class="hljs-built_in">transmission_</span>(trans), <span class="hljs-built_in">wheels_</span>(wheels) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        engine_.<span class="hljs-built_in">start</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span> </span>&#123;<br>        engine_.<span class="hljs-built_in">increaseRPM</span>();<br>        transmission_.<span class="hljs-built_in">shiftGear</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-复合的优势"><a href="#3-复合的优势" class="headerlink" title="3. 复合的优势"></a>3. <strong>复合的优势</strong></h4><p><strong>更好的封装性</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TCPSocket socket_;        <span class="hljs-comment">// 实现细节被完全隐藏</span><br>    MessageBuffer buffer_;    <span class="hljs-comment">// 客户无法直接访问</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> socket_.<span class="hljs-built_in">connect</span>(host, port);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendQuery</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; sql)</span> </span>&#123;<br>        <span class="hljs-function">Message <span class="hljs-title">msg</span><span class="hljs-params">(sql)</span></span>;<br>        <span class="hljs-keyword">return</span> socket_.<span class="hljs-built_in">send</span>(buffer_.<span class="hljs-built_in">serialize</span>(msg));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 客户无法调用socket_的其他方法，只能使用设计的接口</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p><strong>复合的核心价值：</strong></p>
<ol>
<li><strong>表达正确的关系</strong>：has-a或is-implemented-in-terms-of</li>
<li><strong>更好的封装</strong>：隐藏实现细节</li>
<li><strong>避免接口污染</strong>：只暴露必要的操作</li>
<li><strong>灵活的设计</strong>：运行时可替换组件</li>
</ol>
<p><strong>记住：复合的意义和public继承完全不同。在应用域，复合意味着has-a（有一个）；在实现域，复合意味着is-implemented-in-terms-of（根据某物实现出）。</strong></p>
<h2 id="条款39：-明智而审慎地使用private继承"><a href="#条款39：-明智而审慎地使用private继承" class="headerlink" title="条款39： 明智而审慎地使用private继承"></a>条款39： 明智而审慎地使用private继承</h2><blockquote>
<p><em>Use private inheritance judiciously</em></p>
</blockquote>
<h3 id="核心理念-35"><a href="#核心理念-35" class="headerlink" title="核心理念"></a>核心理念</h3><p><strong>private继承意味着”is-implemented-in-terms-of”（根据某物实现出）关系</strong>。当派生类private继承基类时，编译器不会自动将派生类对象转换为基类对象。private继承纯粹只是一种实现技术，通常意味着”只有实现部分被继承，接口部分应略去”。在大多数情况下，复合比private继承更好，但当需要访问protected成员或重写虚函数时，private继承是必要的。</p>
<h3 id="深度解析-35"><a href="#深度解析-35" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-private继承的基本特性"><a href="#1-private继承的基本特性" class="headerlink" title="1. private继承的基本特性"></a>1. <strong>private继承的基本特性</strong></h4><p>private继承与public继承在语义和行为上都有显著差异，理解这些根本区别是正确使用private继承的前提。</p>
<p><strong>与public继承的区别</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 定时器每隔一定时间调用一次</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> frequency_;<br>&#125;;<br><br><span class="hljs-comment">// ❌ public继承：Widget is-a Timer（语义错误）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> Timer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// ✅ private继承：Widget根据Timer实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">private</span> Timer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// Timer的public接口在这里变成private</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testInheritance</span><span class="hljs-params">()</span> </span>&#123;<br>    Widget w;<br>    Timer* pt = &amp;w;  <span class="hljs-comment">// ❌ 错误！private继承不允许自动转换</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-何时使用private继承"><a href="#2-何时使用private继承" class="headerlink" title="2. 何时使用private继承"></a>2. <strong>何时使用private继承</strong></h4><p>虽然复合通常是更好的选择，但有两种特定场景下private继承不仅合理，而且是必要的。</p>
<p><strong>场景1：需要访问protected成员</strong>：</p>
<p>当需要使用基类的protected成员而又不希望暴露”is-a”关系时，private继承是唯一的解决方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseEngine</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logOperation</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; operation)</span> </span>&#123;<br>        <span class="hljs-comment">// 写入数据库操作日志</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateCredentials</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; user, <span class="hljs-type">const</span> std::string&amp; password)</span> </span>&#123;<br>        <span class="hljs-comment">// 验证用户凭证</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// ✅ private继承可以访问protected成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDatabase</span> : <span class="hljs-keyword">private</span> DatabaseEngine &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现连接逻辑</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; user, <span class="hljs-type">const</span> std::string&amp; password)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">validateCredentials</span>(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;admin123&quot;</span>)) &#123;  <span class="hljs-comment">// ✅ 可以访问protected</span><br>            <span class="hljs-built_in">logOperation</span>(<span class="hljs-string">&quot;ADD_USER&quot;</span>);                     <span class="hljs-comment">// ✅ 可以访问protected</span><br>            <span class="hljs-comment">// 添加用户逻辑</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>场景2：需要重写虚函数</strong>：</p>
<p>当需要重写基类的虚函数但不想建立”is-a”关系时，private继承提供了最直接的实现方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHandler</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onMouseClick</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onKeyPress</span><span class="hljs-params">(<span class="hljs-type">char</span> key)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onWindowResize</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ private继承可以重写虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> : <span class="hljs-keyword">private</span> EventHandler &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onMouseClick</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Button clicked at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 自定义按钮点击处理逻辑</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerWithWindow</span><span class="hljs-params">(Window* window)</span> </span>&#123;<br>        window-&gt;<span class="hljs-built_in">setEventHandler</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 传递给窗口系统</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h3><p><strong>private继承的核心特点：</strong></p>
<ol>
<li><strong>表达”is-implemented-in-terms-of”关系</strong></li>
<li><strong>禁止外部的类型转换</strong></li>
<li><strong>可以访问protected成员</strong></li>
<li><strong>可以重写虚函数</strong></li>
</ol>
<p><strong>记住：private继承意味着”is-implemented-in-terms-of”。它通常比复合级别低，但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的虚函数时，这么设计是合理的。</strong></p>
<h2 id="条款40：-明智而审慎地使用多重继承"><a href="#条款40：-明智而审慎地使用多重继承" class="headerlink" title="条款40： 明智而审慎地使用多重继承"></a>条款40： 明智而审慎地使用多重继承</h2><blockquote>
<p><em>Use multiple inheritance judiciously</em></p>
</blockquote>
<h3 id="核心理念-36"><a href="#核心理念-36" class="headerlink" title="核心理念"></a>核心理念</h3><p>**多重继承（Multiple Inheritance, MI）**比单一继承复杂，可能导致歧义性，以及对虚基类的需要。但多重继承也有合理的用途：比如”接口类”和”辅助实现类”的结合。虚继承会增加大小、速度、初始化（及赋值）复杂度等等成本，如果虚基类不带任何数据，将是最具实用价值的情况。多重继承的确有正当用途，其中一种情节涉及”public继承某个接口类”和”private继承某个协助实现的类”的两相组合。</p>
<h3 id="深度解析-36"><a href="#深度解析-36" class="headerlink" title="深度解析"></a>深度解析</h3><h4 id="1-多重继承的基本概念"><a href="#1-多重继承的基本概念" class="headerlink" title="1. 多重继承的基本概念"></a>1. <strong>多重继承的基本概念</strong></h4><p>多重继承允许一个类从多个基类继承，这为实现复杂的接口组合提供了可能，但也带来了新的复杂性。</p>
<p><strong>多重继承的语法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">File</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Serializable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">deserialize</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Serializable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 多重继承：继承两个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigFile</span> : <span class="hljs-keyword">public</span> File, <span class="hljs-keyword">public</span> Serializable &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string filename_;<br>    std::map&lt;std::string, std::string&gt; config_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConfigFile</span>(<span class="hljs-type">const</span> std::string&amp; filename) : <span class="hljs-built_in">filename_</span>(filename) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 实现File接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Opening config file: &quot;</span> &lt;&lt; filename_ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Closing config file&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Reading configuration&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Writing configuration&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实现Serializable接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Serializing config to JSON&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deserializing config from JSON&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-钻石继承问题（Diamond-Problem）"><a href="#2-钻石继承问题（Diamond-Problem）" class="headerlink" title="2. 钻石继承问题（Diamond Problem）"></a>2. <strong>钻石继承问题（Diamond Problem）</strong></h4><p>当多个基类共享同一个祖先类时，就会出现钻石继承问题，需要通过虚继承来解决二义性和重复继承的问题。</p>
<p><strong>解决方案：虚继承</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string name_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; is eating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// ✅ 使用虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mammal</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">Animal</span>(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">giveBirth</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; is giving birth&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WingedAnimal</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">WingedAnimal</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">Animal</span>(name) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; is flying&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span> : <span class="hljs-keyword">public</span> Mammal, <span class="hljs-keyword">public</span> WingedAnimal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ⚠️ 注意：最派生类负责初始化虚基类</span><br>    <span class="hljs-built_in">Bat</span>(<span class="hljs-type">const</span> std::string&amp; name) <br>        : <span class="hljs-built_in">Animal</span>(name),           <span class="hljs-comment">// 必须直接初始化虚基类</span><br>          <span class="hljs-built_in">Mammal</span>(name), <br>          <span class="hljs-built_in">WingedAnimal</span>(name) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-多重继承的合理应用场景"><a href="#3-多重继承的合理应用场景" class="headerlink" title="3. 多重继承的合理应用场景"></a>3. <strong>多重继承的合理应用场景</strong></h4><p>虽然多重继承复杂，但在某些设计模式中确实有其合理用途，特别是在接口设计和功能组合方面。</p>
<p><strong>场景1：接口分离原则</strong>：</p>
<p>当一个类需要实现多个不相关的接口时，多重继承可以保持接口的独立性和清晰性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输入接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Readable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">canRead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Readable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 输出接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">canWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Writable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 实现多个接口的文件流</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStream</span> : <span class="hljs-keyword">public</span> Readable, <span class="hljs-keyword">public</span> Writable &#123;<br><span class="hljs-keyword">private</span>:<br>    std::fstream file_;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FileStream</span>(<span class="hljs-type">const</span> std::string&amp; filename) <br>        : <span class="hljs-built_in">file_</span>(filename, std::ios::in | std::ios::out) &#123;&#125;<br>    <br>    <span class="hljs-comment">// 实现Readable接口</span><br>    <span class="hljs-function">std::string <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::string line;<br>        std::<span class="hljs-built_in">getline</span>(file_, line);<br>        <span class="hljs-keyword">return</span> line;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canRead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_.<span class="hljs-built_in">good</span>() &amp;&amp; file_.<span class="hljs-built_in">is_open</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实现Writable接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        file_ &lt;&lt; data;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> file_.<span class="hljs-built_in">good</span>() &amp;&amp; file_.<span class="hljs-built_in">is_open</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-28"><a href="#总结-28" class="headerlink" title="总结"></a>总结</h3><p><strong>多重继承的核心价值：</strong></p>
<ol>
<li><strong>接口分离</strong>：实现多个独立的接口</li>
<li><strong>代码复用</strong>：组合接口类和实现类</li>
<li><strong>设计灵活性</strong>：支持复杂的继承关系</li>
</ol>
<p><strong>使用多重继承的准则：</strong></p>
<ol>
<li><strong>避免钻石继承</strong>：尽量使用虚继承来处理</li>
<li><strong>优先接口继承</strong>：多重继承最好用于纯接口类</li>
<li><strong>谨慎使用虚基类</strong>：只有在必要时才使用，并保持虚基类简单</li>
</ol>
<p><strong>记住：多重继承比单一继承复杂，它可能导致新的歧义性，以及对虚继承的需要。虚继承会增加大小、速度、初始化复杂度等成本。如果虚基类不带任何数据，将是最具实用价值的情况。多重继承的确有正当用途，其中一种情节涉及”public继承某个接口类”和”private继承某个协助实现的类”的两相组合。</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%8A%80%E6%9C%AF/C/" class="category-chain-item">C++</a>
  
  

  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%98%85%E8%AF%BB/" class="category-chain-item">阅读</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%98%85%E8%AF%BB/reading/" class="category-chain-item">读书笔记</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="print-no-link">#读书笔记</a>
      
        <a href="/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="print-no-link">#最佳实践</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Effective C++ 改善程序与设计的55个具体做法</div>
      <div>https://ashrw24.github.io/2025/11/20/Effective C++ 改善程序与设计的55个具体做法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>真新镇之小智</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              CC BY-SA 4.0
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/20/intro/" title="修行之路：我的技术与生活">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">修行之路：我的技术与生活</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> <span>愿代码与你同在</span> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
